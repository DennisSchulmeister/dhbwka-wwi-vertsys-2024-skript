"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AstVisitor = exports.AstVisitorError = exports.UnaryOp = exports.BinaryOp = exports.ExprType = exports.isLhsExpr = exports.InputType = exports.PrintSep = exports.CondLoopStructure = exports.CaseExprType = exports.isSingularTypeExpr = exports.DataTypeExprType = exports.DimType = exports.StmtType = exports.isFnProcOrDefFnProc = void 0;
var error_with_loc_1 = __importDefault(require("./error-with-loc"));
var types_1 = require("./types");
function isFnProcOrDefFnProc(proc) {
    return (0, types_1.isFnOrDefFn)(proc.type);
}
exports.isFnProcOrDefFnProc = isFnProcOrDefFnProc;
var StmtType;
(function (StmtType) {
    StmtType["LABEL"] = "label";
    StmtType["DIM"] = "dim";
    StmtType["ASSIGN"] = "assign";
    StmtType["CONST"] = "const";
    StmtType["GOTO"] = "goto";
    StmtType["IF"] = "if";
    StmtType["SELECT"] = "select";
    StmtType["COND_LOOP"] = "condLoop";
    StmtType["UNCOND_LOOP"] = "uncondLoop";
    StmtType["EXIT_LOOP"] = "exitLoop";
    StmtType["FOR"] = "for";
    StmtType["NEXT"] = "next";
    StmtType["EXIT_FOR"] = "exitFor";
    StmtType["GOSUB"] = "gosub";
    StmtType["RETURN"] = "return";
    StmtType["CALL"] = "call";
    StmtType["EXIT_PROC"] = "exitProc";
    StmtType["END"] = "end";
    StmtType["SWAP"] = "swap";
    StmtType["PRINT"] = "print";
    StmtType["INPUT"] = "input";
    StmtType["DEF_TYPE"] = "defType";
    StmtType["DATA"] = "data";
    StmtType["READ"] = "read";
    StmtType["RESTORE"] = "restore";
})(StmtType = exports.StmtType || (exports.StmtType = {}));
var DimType;
(function (DimType) {
    DimType["LOCAL"] = "local";
    DimType["SHARED"] = "shared";
    DimType["STATIC"] = "static";
})(DimType = exports.DimType || (exports.DimType = {}));
var DataTypeExprType;
(function (DataTypeExprType) {
    DataTypeExprType["ELEMENTARY"] = "elementary";
    DataTypeExprType["ARRAY"] = "array";
    DataTypeExprType["UDT"] = "udt";
})(DataTypeExprType = exports.DataTypeExprType || (exports.DataTypeExprType = {}));
function isSingularTypeExpr(typeExpr) {
    return typeExpr.type !== DataTypeExprType.ARRAY;
}
exports.isSingularTypeExpr = isSingularTypeExpr;
var CaseExprType;
(function (CaseExprType) {
    /** Single value expression. */
    CaseExprType["VALUE"] = "value";
    /** Range, e.g. 1 TO 5. */
    CaseExprType["RANGE"] = "range";
    /** Comparison operator, e.g. IS >= 5. */
    CaseExprType["COMP"] = "comp";
})(CaseExprType = exports.CaseExprType || (exports.CaseExprType = {}));
var CondLoopStructure;
(function (CondLoopStructure) {
    CondLoopStructure["COND_EXPR_BEFORE_STMTS"] = "condExprBeforeStmts";
    CondLoopStructure["COND_EXPR_AFTER_STMTS"] = "condExprAfterStmts";
})(CondLoopStructure = exports.CondLoopStructure || (exports.CondLoopStructure = {}));
/** An unimplemented statement that we can ignore for codegen purposes. */
var PrintSep;
(function (PrintSep) {
    PrintSep["COMMA"] = "comma";
    PrintSep["SEMICOLON"] = "semicolon";
})(PrintSep = exports.PrintSep || (exports.PrintSep = {}));
var InputType;
(function (InputType) {
    /** INPUT. */
    InputType["TOKENIZED"] = "tokenized";
    /** LINE INPUT. */
    InputType["LINE"] = "line";
})(InputType = exports.InputType || (exports.InputType = {}));
function isLhsExpr(expr) {
    return [ExprType.VAR_REF, ExprType.SUBSCRIPT, ExprType.MEMBER].includes(expr.type);
}
exports.isLhsExpr = isLhsExpr;
var ExprType;
(function (ExprType) {
    ExprType["LITERAL"] = "literal";
    ExprType["VAR_REF"] = "varRef";
    ExprType["FN_CALL"] = "fnCall";
    ExprType["BINARY_OP"] = "binaryOp";
    ExprType["UNARY_OP"] = "unaryOp";
    ExprType["SUBSCRIPT"] = "subscript";
    ExprType["MEMBER"] = "member";
})(ExprType = exports.ExprType || (exports.ExprType = {}));
var BinaryOp;
(function (BinaryOp) {
    BinaryOp["ADD"] = "add";
    BinaryOp["SUB"] = "sub";
    BinaryOp["MUL"] = "mul";
    BinaryOp["DIV"] = "div";
    BinaryOp["INTDIV"] = "intdiv";
    BinaryOp["EXP"] = "exp";
    BinaryOp["MOD"] = "mod";
    BinaryOp["AND"] = "and";
    BinaryOp["OR"] = "or";
    BinaryOp["EQ"] = "eq";
    BinaryOp["NE"] = "ne";
    BinaryOp["GT"] = "gt";
    BinaryOp["GTE"] = "gte";
    BinaryOp["LT"] = "lt";
    BinaryOp["LTE"] = "lte";
})(BinaryOp = exports.BinaryOp || (exports.BinaryOp = {}));
var UnaryOp;
(function (UnaryOp) {
    UnaryOp["NOT"] = "not";
    UnaryOp["NEG"] = "sub";
    UnaryOp["PARENS"] = "parens";
})(UnaryOp = exports.UnaryOp || (exports.UnaryOp = {}));
/** Error thrown by AST visitors. */
var AstVisitorError = /** @class */ (function (_super) {
    __extends(AstVisitorError, _super);
    function AstVisitorError(message, _a) {
        var _b = _a === void 0 ? {} : _a, sourceFileName = _b.sourceFileName, node = _b.node;
        return _super.call(this, message, { sourceFileName: sourceFileName, loc: node === null || node === void 0 ? void 0 : node.loc }) || this;
    }
    return AstVisitorError;
}(error_with_loc_1.default));
exports.AstVisitorError = AstVisitorError;
/** Base class for AST visitors. */
var AstVisitor = /** @class */ (function () {
    function AstVisitor() {
    }
    /** Invokes the visitor method corresponding to the specified AstNode. */
    AstVisitor.prototype.accept = function (node) {
        switch (node.type) {
            case types_1.ProcType.SUB:
            case types_1.ProcType.FN:
            case types_1.ProcType.DEF_FN:
                return this.visitProc(node);
            case StmtType.LABEL:
                return this.visitLabelStmt(node);
            case StmtType.DIM:
                return this.visitDimStmt(node);
            case StmtType.ASSIGN:
                return this.visitAssignStmt(node);
            case StmtType.CONST:
                return this.visitConstStmt(node);
            case StmtType.GOTO:
                return this.visitGotoStmt(node);
            case StmtType.IF:
                return this.visitIfStmt(node);
            case StmtType.SELECT:
                return this.visitSelectStmt(node);
            case StmtType.COND_LOOP:
                return this.visitCondLoopStmt(node);
            case StmtType.UNCOND_LOOP:
                return this.visitUncondLoopStmt(node);
            case StmtType.EXIT_LOOP:
                return this.visitExitLoopStmt(node);
            case StmtType.FOR:
                return this.visitForStmt(node);
            case StmtType.NEXT:
                return this.visitNextStmt(node);
            case StmtType.EXIT_FOR:
                return this.visitExitForStmt(node);
            case StmtType.GOSUB:
                return this.visitGosubStmt(node);
            case StmtType.RETURN:
                return this.visitReturnStmt(node);
            case StmtType.CALL:
                return this.visitCallStmt(node);
            case StmtType.EXIT_PROC:
                return this.visitExitProcStmt(node);
            case StmtType.END:
                return this.visitEndStmt(node);
            case StmtType.SWAP:
                return this.visitSwapStmt(node);
            case StmtType.PRINT:
                return this.visitPrintStmt(node);
            case StmtType.INPUT:
                return this.visitInputStmt(node);
            case StmtType.DEF_TYPE:
                return this.visitDefTypeStmt(node);
            case StmtType.DATA:
                return this.visitDataStmt(node);
            case StmtType.READ:
                return this.visitReadStmt(node);
            case StmtType.RESTORE:
                return this.visitRestoreStmt(node);
            case ExprType.LITERAL:
                return this.visitLiteralExpr(node);
            case ExprType.VAR_REF:
                return this.visitVarRefExpr(node);
            case ExprType.FN_CALL:
                return this.visitFnCallExpr(node);
            case ExprType.BINARY_OP:
                return this.visitBinaryOpExpr(node);
            case ExprType.UNARY_OP:
                return this.visitUnaryOpExpr(node);
            case ExprType.SUBSCRIPT:
                return this.visitSubscriptExpr(node);
            case ExprType.MEMBER:
                return this.visitMemberExpr(node);
            default:
                throw new Error("Unknown node type: ".concat(JSON.stringify(node)));
        }
    };
    /** Invokes the corresponding visitor methods for each of the provided AstNodes. */
    AstVisitor.prototype.acceptAll = function (nodes) {
        var _this = this;
        return nodes.map(function (node) { return _this.accept(node); });
    };
    /** Throws an AstVisitorError for the corresponding AstNode. */
    AstVisitor.prototype.throwError = function (message, node) {
        throw new AstVisitorError(message, {
            sourceFileName: this.sourceFileName,
            node: node,
        });
    };
    return AstVisitor;
}());
exports.AstVisitor = AstVisitor;
