import moo from 'moo';
/** QBasic keywords.
 *
 * Note that the values must be lowercase!
 */
export declare enum Keywords {
    AND = "and",
    AS = "as",
    CALL = "call",
    CASE = "case",
    COLOR = "color",
    CONST = "const",
    DATA = "data",
    DECLARE = "declare",
    DEF = "def",
    DEFINT = "defint",
    DEFSNG = "defsng",
    DEFDBL = "defdbl",
    DEFLNG = "deflng",
    DEFSTR = "defstr",
    DIM = "dim",
    DO = "do",
    DOUBLE = "double",
    ELSE = "else",
    ELSEIF = "elseif",
    END = "end",
    EXIT = "exit",
    FUNCTION = "function",
    FOR = "for",
    GOSUB = "gosub",
    GOTO = "goto",
    IF = "if",
    IS = "is",
    INPUT = "input",
    INTEGER = "integer",
    LET = "let",
    LINE = "line",
    LOCATE = "locate",
    LONG = "long",
    LOOP = "loop",
    MOD = "mod",
    NEXT = "next",
    NOT = "not",
    OR = "or",
    PRINT = "print",
    READ = "read",
    REM = "rem",
    RESTORE = "restore",
    RETURN = "return",
    SEG = "seg",
    SELECT = "select",
    SHARED = "shared",
    SINGLE = "single",
    STATIC = "static",
    STEP = "step",
    STOP = "stop",
    STRING = "string",
    SUB = "sub",
    SYSTEM = "system",
    SWAP = "swap",
    THEN = "then",
    TO = "to",
    TYPE = "type",
    UNTIL = "until",
    USING = "using",
    VIEW = "view",
    WEND = "wend",
    WHILE = "while"
}
/** Extended token. */
export interface Token extends moo.Token {
    isFirstTokenOnLine?: boolean;
}
/** Lexer for QBasic.
 *
 * This class wraps the moo lexer with some additional capabilities:
 *
 *   - Discard irrelevant tokens, based on https://github.com/no-context/moo/issues/81.
 *   - Set isFirstTokenOnLine flag on tokens to help disambiguate labels from statements.
 *   - Support lookahead with peek().
 *   - Store the last token for debugging output.
 */
declare class Lexer {
    private readonly mooLexer;
    constructor(mooLexer: moo.Lexer);
    next(): Token | undefined;
    peek(): Token | undefined;
    save(): moo.LexerState;
    reset(chunk?: string, state?: moo.LexerState): this;
    formatError(token: Token, message?: string): string;
    has(tokenType: string): boolean;
    lastToken: Token | undefined;
    private isNextTokenFirstOnLine;
    private tokenQueue;
}
declare const lexer: Lexer;
export default lexer;
