"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Keywords = void 0;
var moo_1 = __importDefault(require("moo"));
/** QBasic keywords.
 *
 * Note that the values must be lowercase!
 */
var Keywords;
(function (Keywords) {
    Keywords["AND"] = "and";
    Keywords["AS"] = "as";
    Keywords["CALL"] = "call";
    Keywords["CASE"] = "case";
    Keywords["COLOR"] = "color";
    Keywords["CONST"] = "const";
    Keywords["DATA"] = "data";
    Keywords["DECLARE"] = "declare";
    Keywords["DEF"] = "def";
    Keywords["DEFINT"] = "defint";
    Keywords["DEFSNG"] = "defsng";
    Keywords["DEFDBL"] = "defdbl";
    Keywords["DEFLNG"] = "deflng";
    Keywords["DEFSTR"] = "defstr";
    Keywords["DIM"] = "dim";
    Keywords["DO"] = "do";
    Keywords["DOUBLE"] = "double";
    Keywords["ELSE"] = "else";
    Keywords["ELSEIF"] = "elseif";
    Keywords["END"] = "end";
    Keywords["EXIT"] = "exit";
    Keywords["FUNCTION"] = "function";
    Keywords["FOR"] = "for";
    Keywords["GOSUB"] = "gosub";
    Keywords["GOTO"] = "goto";
    Keywords["IF"] = "if";
    Keywords["IS"] = "is";
    Keywords["INPUT"] = "input";
    Keywords["INTEGER"] = "integer";
    Keywords["LET"] = "let";
    Keywords["LINE"] = "line";
    Keywords["LOCATE"] = "locate";
    Keywords["LONG"] = "long";
    Keywords["LOOP"] = "loop";
    Keywords["MOD"] = "mod";
    Keywords["NEXT"] = "next";
    Keywords["NOT"] = "not";
    Keywords["OR"] = "or";
    Keywords["PRINT"] = "print";
    Keywords["READ"] = "read";
    Keywords["REM"] = "rem";
    Keywords["RESTORE"] = "restore";
    Keywords["RETURN"] = "return";
    Keywords["SEG"] = "seg";
    Keywords["SELECT"] = "select";
    Keywords["SHARED"] = "shared";
    Keywords["SINGLE"] = "single";
    Keywords["STATIC"] = "static";
    Keywords["STEP"] = "step";
    Keywords["STOP"] = "stop";
    Keywords["STRING"] = "string";
    Keywords["SUB"] = "sub";
    Keywords["SYSTEM"] = "system";
    Keywords["SWAP"] = "swap";
    Keywords["THEN"] = "then";
    Keywords["TO"] = "to";
    Keywords["TYPE"] = "type";
    Keywords["UNTIL"] = "until";
    Keywords["USING"] = "using";
    Keywords["VIEW"] = "view";
    Keywords["WEND"] = "wend";
    Keywords["WHILE"] = "while";
})(Keywords = exports.Keywords || (exports.Keywords = {}));
/** moo lexer used internally by Lexer. */
var mooLexer = moo_1.default.states({
    main: {
        WHITESPACE: {
            match: /\s+/,
            type: function (text) { return (text.includes('\n') ? 'NEWLINE' : ''); },
            lineBreaks: true,
        },
        COMMENT: {
            match: /'/,
            push: 'comment',
        },
        IDENTIFIER: {
            match: /[a-zA-Z_][a-zA-Z0-9_]*(?:\$|%|#|&|!)?/,
            type: caseInsensitiveKeywords(Keywords),
        },
        STRING_LITERAL: {
            match: /"[^"]*"/,
            value: function (text) { return text.substr(1, text.length - 2); },
        },
        NUMERIC_LITERAL: /(?:\d*\.\d+|\d+)/,
        HEX_LITERAL: {
            match: /&[hH][\da-fA-F]+&?/,
            type: function () { return 'NUMERIC_LITERAL'; },
            value: function (text) { return "".concat(parseInt(text.substr(2), 16)); },
        },
        OCT_LITERAL: {
            match: /&[oO]?[0-7]+&?/,
            type: function () { return 'NUMERIC_LITERAL'; },
            value: function (text) { return "".concat(parseInt(text.match(/[0-7]+/)[0], 8)); },
        },
        COLON: ':',
        SEMICOLON: ';',
        COMMA: ',',
        DOT: '.',
        LPAREN: '(',
        RPAREN: ')',
        ADD: '+',
        SUB: '-',
        MUL: '*',
        EXP: '^',
        DIV: '/',
        INTDIV: '\\',
        // Note: order matters in the comparison operators!
        EQ: '=',
        NE: '<>',
        GTE: '>=',
        LTE: '<=',
        GT: '>',
        LT: '<',
    },
    comment: {
        COMMENT: {
            match: /[^\n]+/,
            pop: 1,
        },
        NEWLINE: {
            match: /\n/,
            pop: 1,
            lineBreaks: true,
        },
    },
}, 'main');
var TOKEN_TYPES_TO_DISCARD = ['WHITESPACE', 'COMMENT', 'REM'];
/** Lexer for QBasic.
 *
 * This class wraps the moo lexer with some additional capabilities:
 *
 *   - Discard irrelevant tokens, based on https://github.com/no-context/moo/issues/81.
 *   - Set isFirstTokenOnLine flag on tokens to help disambiguate labels from statements.
 *   - Support lookahead with peek().
 *   - Store the last token for debugging output.
 */
var Lexer = /** @class */ (function () {
    function Lexer(mooLexer) {
        this.mooLexer = mooLexer;
        this.lastToken = undefined;
        this.isNextTokenFirstOnLine = true;
        this.tokenQueue = [];
    }
    Lexer.prototype.next = function () {
        if (this.tokenQueue.length > 0) {
            return this.tokenQueue.pop();
        }
        var token;
        do {
            token = this.mooLexer.next();
            if (token) {
                this.lastToken = token;
                token.isFirstTokenOnLine = this.isNextTokenFirstOnLine;
                if (token.type === 'NEWLINE') {
                    this.isNextTokenFirstOnLine = true;
                }
                else {
                    this.isNextTokenFirstOnLine = false;
                }
                if (token.type === 'REM') {
                    this.mooLexer.pushState('comment');
                }
            }
        } while (token &&
            token.type &&
            TOKEN_TYPES_TO_DISCARD.includes(token.type));
        return token;
    };
    Lexer.prototype.peek = function () {
        var token = this.next();
        this.tokenQueue.push(token);
        return token;
    };
    Lexer.prototype.save = function () {
        return this.mooLexer.save();
    };
    Lexer.prototype.reset = function (chunk, state) {
        this.mooLexer.reset(chunk, state);
        this.isNextTokenFirstOnLine = true;
        this.lastToken = undefined;
        this.tokenQueue = [];
        return this;
    };
    Lexer.prototype.formatError = function (token, message) {
        return this.mooLexer.formatError(token, message);
    };
    Lexer.prototype.has = function (tokenType) {
        return this.mooLexer.has(tokenType);
    };
    return Lexer;
}());
// Based on https://github.com/no-context/moo/pull/85#issue-178701835
function caseInsensitiveKeywords(map) {
    var keywordsTransformFn = moo_1.default.keywords(map);
    return function (text) { return keywordsTransformFn(text.toLowerCase()); };
}
var lexer = new Lexer(mooLexer);
exports.default = lexer;
