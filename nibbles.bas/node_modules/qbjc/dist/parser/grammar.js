"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// Generated automatically by nearley, version 2.20.1
// http://github.com/Hardmath123/nearley
// Bypasses TS6133. Allow declared but unused functions.
// @ts-ignore
function id(d) { return d[0]; }
var lodash_1 = __importDefault(require("lodash"));
var lexer_1 = __importDefault(require("./lexer"));
var ast_1 = require("../lib/ast");
var types_1 = require("../lib/types");
// ----
// Helper functions.
// ----
function discard() { return null; }
function useLoc(tokenOrAstNode) {
    if ('loc' in tokenOrAstNode) {
        return { loc: tokenOrAstNode.loc };
    }
    else if (('line' in tokenOrAstNode) && ('col' in tokenOrAstNode)) {
        return { loc: { line: tokenOrAstNode.line, col: tokenOrAstNode.col } };
    }
    else {
        throw new Error("Invalid tokenOrAstNode: ".concat(JSON.stringify(tokenOrAstNode)));
    }
}
function buildBinaryOpExpr(_a) {
    var $1 = _a[0], $2 = _a[1], $3 = _a[2];
    return __assign({ type: ast_1.ExprType.BINARY_OP, op: id($2).type.toLowerCase(), leftExpr: $1, rightExpr: $3 }, useLoc($1));
}
function buildUnaryOpExpr(_a) {
    var $1 = _a[0], $2 = _a[1];
    return __assign({ type: ast_1.ExprType.UNARY_OP, op: id($1).type.toLowerCase(), rightExpr: $2 }, useLoc(id($1)));
}
function buildDataItem(tokenOrAstNode, value) {
    var _a = useLoc(tokenOrAstNode).loc, line = _a.line, col = _a.col;
    return [[line, col], value];
}
;
;
;
;
var grammar = {
    Lexer: lexer_1.default,
    ParserRules: [
        { "name": "module$ebnf$1", "symbols": ["stmtSep"], "postprocess": id },
        { "name": "module$ebnf$1", "symbols": [], "postprocess": function () { return null; } },
        { "name": "module$ebnf$2", "symbols": ["moduleComponentWithSep"] },
        { "name": "module$ebnf$2", "symbols": ["module$ebnf$2", "moduleComponentWithSep"], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "module", "symbols": ["module$ebnf$1", "module$ebnf$2"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1];
                return $2.reduce(function (a, b) { return ({
                    stmts: __spreadArray(__spreadArray([], a.stmts, true), b.stmts, true),
                    procs: __spreadArray(__spreadArray([], a.procs, true), b.procs, true),
                    udts: __spreadArray(__spreadArray([], a.udts, true), b.udts, true),
                }); });
            }
        },
        { "name": "moduleComponentWithSep", "symbols": ["stmtWithSep"], "postprocess": function (_a) {
                var $1 = _a[0];
                return ({
                    stmts: [$1],
                    procs: [],
                    udts: [],
                });
            }
        },
        { "name": "moduleComponentWithSep", "symbols": ["proc", "stmtSep"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1];
                return ({
                    stmts: [],
                    procs: $1 ? [$1] : [],
                    udts: [],
                });
            }
        },
        { "name": "moduleComponentWithSep", "symbols": ["udt", "stmtSep"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1];
                return ({
                    stmts: [],
                    procs: [],
                    udts: $1 ? [$1] : [],
                });
            }
        },
        { "name": "proc", "symbols": ["fnProc"], "postprocess": id },
        { "name": "proc", "symbols": ["subProc"], "postprocess": id },
        { "name": "proc", "symbols": ["defFnExprProc"], "postprocess": id },
        { "name": "proc", "symbols": ["procDecl"], "postprocess": discard },
        { "name": "fnProc$ebnf$1$subexpression$1", "symbols": [(lexer_1.default.has("LPAREN") ? { type: "LPAREN" } : LPAREN), "params", (lexer_1.default.has("RPAREN") ? { type: "RPAREN" } : RPAREN)] },
        { "name": "fnProc$ebnf$1", "symbols": ["fnProc$ebnf$1$subexpression$1"], "postprocess": id },
        { "name": "fnProc$ebnf$1", "symbols": [], "postprocess": function () { return null; } },
        { "name": "fnProc$ebnf$2", "symbols": [(lexer_1.default.has("STATIC") ? { type: "STATIC" } : STATIC)], "postprocess": id },
        { "name": "fnProc$ebnf$2", "symbols": [], "postprocess": function () { return null; } },
        { "name": "fnProc", "symbols": [(lexer_1.default.has("FUNCTION") ? { type: "FUNCTION" } : FUNCTION), (lexer_1.default.has("IDENTIFIER") ? { type: "IDENTIFIER" } : IDENTIFIER), "fnProc$ebnf$1", "fnProc$ebnf$2", "stmts", (lexer_1.default.has("END") ? { type: "END" } : END), (lexer_1.default.has("FUNCTION") ? { type: "FUNCTION" } : FUNCTION)], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1], $3 = _a[2], $4 = _a[3], $5 = _a[4], $6 = _a[5], $7 = _a[6];
                return (__assign({ type: types_1.ProcType.FN, name: $2.value, params: $3 ? $3[1] : [], stmts: $5, isDefaultStatic: !!$4 }, useLoc($1)));
            }
        },
        { "name": "subProc$ebnf$1$subexpression$1", "symbols": [(lexer_1.default.has("LPAREN") ? { type: "LPAREN" } : LPAREN), "params", (lexer_1.default.has("RPAREN") ? { type: "RPAREN" } : RPAREN)] },
        { "name": "subProc$ebnf$1", "symbols": ["subProc$ebnf$1$subexpression$1"], "postprocess": id },
        { "name": "subProc$ebnf$1", "symbols": [], "postprocess": function () { return null; } },
        { "name": "subProc$ebnf$2", "symbols": [(lexer_1.default.has("STATIC") ? { type: "STATIC" } : STATIC)], "postprocess": id },
        { "name": "subProc$ebnf$2", "symbols": [], "postprocess": function () { return null; } },
        { "name": "subProc", "symbols": [(lexer_1.default.has("SUB") ? { type: "SUB" } : SUB), (lexer_1.default.has("IDENTIFIER") ? { type: "IDENTIFIER" } : IDENTIFIER), "subProc$ebnf$1", "subProc$ebnf$2", "stmts", (lexer_1.default.has("END") ? { type: "END" } : END), (lexer_1.default.has("SUB") ? { type: "SUB" } : SUB)], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1], $3 = _a[2], $4 = _a[3], $5 = _a[4], $6 = _a[5], $7 = _a[6];
                return (__assign({ type: types_1.ProcType.SUB, name: $2.value, params: $3 ? $3[1] : [], stmts: $5, isDefaultStatic: !!$4 }, useLoc($1)));
            }
        },
        { "name": "defFnExprProc$ebnf$1$subexpression$1", "symbols": [(lexer_1.default.has("LPAREN") ? { type: "LPAREN" } : LPAREN), "params", (lexer_1.default.has("RPAREN") ? { type: "RPAREN" } : RPAREN)] },
        { "name": "defFnExprProc$ebnf$1", "symbols": ["defFnExprProc$ebnf$1$subexpression$1"], "postprocess": id },
        { "name": "defFnExprProc$ebnf$1", "symbols": [], "postprocess": function () { return null; } },
        { "name": "defFnExprProc", "symbols": [(lexer_1.default.has("DEF") ? { type: "DEF" } : DEF), (lexer_1.default.has("IDENTIFIER") ? { type: "IDENTIFIER" } : IDENTIFIER), "defFnExprProc$ebnf$1", (lexer_1.default.has("EQ") ? { type: "EQ" } : EQ), "expr"], "postprocess": function (_a, position, reject) {
                var $1 = _a[0], $2 = _a[1], $3 = _a[2], $4 = _a[3], $5 = _a[4];
                if (!$2.value.toLowerCase().startsWith('fn')) {
                    return reject;
                }
                return __assign({ type: types_1.ProcType.DEF_FN, name: $2.value, params: $3 ? $3[1] : [], stmts: [
                        __assign({ type: ast_1.StmtType.ASSIGN, targetExpr: __assign({ type: ast_1.ExprType.VAR_REF, name: $2.value }, useLoc($4)), valueExpr: $5 }, useLoc($4))
                    ], isDefaultStatic: false }, useLoc($1));
            }
        },
        { "name": "procDecl$subexpression$1", "symbols": [(lexer_1.default.has("FUNCTION") ? { type: "FUNCTION" } : FUNCTION)] },
        { "name": "procDecl$subexpression$1", "symbols": [(lexer_1.default.has("SUB") ? { type: "SUB" } : SUB)] },
        { "name": "procDecl$ebnf$1$subexpression$1", "symbols": [(lexer_1.default.has("LPAREN") ? { type: "LPAREN" } : LPAREN), "params", (lexer_1.default.has("RPAREN") ? { type: "RPAREN" } : RPAREN)] },
        { "name": "procDecl$ebnf$1", "symbols": ["procDecl$ebnf$1$subexpression$1"], "postprocess": id },
        { "name": "procDecl$ebnf$1", "symbols": [], "postprocess": function () { return null; } },
        { "name": "procDecl", "symbols": [(lexer_1.default.has("DECLARE") ? { type: "DECLARE" } : DECLARE), "procDecl$subexpression$1", (lexer_1.default.has("IDENTIFIER") ? { type: "IDENTIFIER" } : IDENTIFIER), "procDecl$ebnf$1"], "postprocess": discard },
        { "name": "params", "symbols": [], "postprocess": function () { return []; } },
        { "name": "params$ebnf$1", "symbols": [] },
        { "name": "params$ebnf$1$subexpression$1", "symbols": ["param", (lexer_1.default.has("COMMA") ? { type: "COMMA" } : COMMA)] },
        { "name": "params$ebnf$1", "symbols": ["params$ebnf$1", "params$ebnf$1$subexpression$1"], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "params", "symbols": ["params$ebnf$1", "param"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1];
                return __spreadArray(__spreadArray([], ($1 ? $1.map(function (_a) {
                    var $1_1 = _a[0], $1_2 = _a[1];
                    return $1_1;
                }) : []), true), [$2], false);
            }
        },
        { "name": "param", "symbols": [(lexer_1.default.has("IDENTIFIER") ? { type: "IDENTIFIER" } : IDENTIFIER), "singularTypeExprOrDefault"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1];
                return (__assign({ name: $1.value, typeExpr: $2 }, useLoc($1)));
            }
        },
        { "name": "param", "symbols": [(lexer_1.default.has("IDENTIFIER") ? { type: "IDENTIFIER" } : IDENTIFIER), (lexer_1.default.has("LPAREN") ? { type: "LPAREN" } : LPAREN), (lexer_1.default.has("RPAREN") ? { type: "RPAREN" } : RPAREN), "singularTypeExprOrDefault"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1], $3 = _a[2], $4 = _a[3];
                return (__assign({ name: $1.value, typeExpr: __assign({ type: ast_1.DataTypeExprType.ARRAY, elementTypeExpr: $4, dimensionSpecExprs: [] }, useLoc($1)) }, useLoc($1)));
            }
        },
        { "name": "udt", "symbols": [(lexer_1.default.has("TYPE") ? { type: "TYPE" } : TYPE), (lexer_1.default.has("IDENTIFIER") ? { type: "IDENTIFIER" } : IDENTIFIER), "fieldExprs", (lexer_1.default.has("END") ? { type: "END" } : END), (lexer_1.default.has("TYPE") ? { type: "TYPE" } : TYPE)], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1], $3 = _a[2], $4 = _a[3], $5 = _a[4];
                return (__assign({ name: $2.value, fieldSpecExprs: $3 }, useLoc($1)));
            }
        },
        { "name": "fieldExprs$ebnf$1", "symbols": ["stmtSep"], "postprocess": id },
        { "name": "fieldExprs$ebnf$1", "symbols": [], "postprocess": function () { return null; } },
        { "name": "fieldExprs", "symbols": ["fieldExprs$ebnf$1"], "postprocess": function () { return []; } },
        { "name": "fieldExprs$ebnf$2", "symbols": ["stmtSep"], "postprocess": id },
        { "name": "fieldExprs$ebnf$2", "symbols": [], "postprocess": function () { return null; } },
        { "name": "fieldExprs$ebnf$3", "symbols": [] },
        { "name": "fieldExprs$ebnf$3$subexpression$1", "symbols": ["fieldExpr", "stmtSep"] },
        { "name": "fieldExprs$ebnf$3", "symbols": ["fieldExprs$ebnf$3", "fieldExprs$ebnf$3$subexpression$1"], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "fieldExprs$ebnf$4", "symbols": ["stmtSep"], "postprocess": id },
        { "name": "fieldExprs$ebnf$4", "symbols": [], "postprocess": function () { return null; } },
        { "name": "fieldExprs", "symbols": ["fieldExprs$ebnf$2", "fieldExprs$ebnf$3", "fieldExpr", "fieldExprs$ebnf$4"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1], $3 = _a[2], $4 = _a[3];
                return __spreadArray(__spreadArray([], ($2 ? $2.map(function (_a) {
                    var $2_1 = _a[0], $2_2 = _a[1];
                    return $2_1;
                }) : []), true), [
                    $3,
                ], false);
            }
        },
        { "name": "fieldExpr", "symbols": [(lexer_1.default.has("IDENTIFIER") ? { type: "IDENTIFIER" } : IDENTIFIER), "singularTypeExpr"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1];
                return (__assign({ name: $1.value, typeExpr: $2 }, useLoc($1)));
            }
        },
        { "name": "stmts$ebnf$1", "symbols": ["stmtSep"], "postprocess": id },
        { "name": "stmts$ebnf$1", "symbols": [], "postprocess": function () { return null; } },
        { "name": "stmts$ebnf$2", "symbols": [] },
        { "name": "stmts$ebnf$2", "symbols": ["stmts$ebnf$2", "stmtWithSep"], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "stmts", "symbols": ["stmts$ebnf$1", "stmts$ebnf$2"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1];
                return $2;
            } },
        { "name": "stmtSep$ebnf$1$subexpression$1", "symbols": [(lexer_1.default.has("COLON") ? { type: "COLON" } : COLON)] },
        { "name": "stmtSep$ebnf$1$subexpression$1", "symbols": [(lexer_1.default.has("NEWLINE") ? { type: "NEWLINE" } : NEWLINE)] },
        { "name": "stmtSep$ebnf$1", "symbols": ["stmtSep$ebnf$1$subexpression$1"] },
        { "name": "stmtSep$ebnf$1$subexpression$2", "symbols": [(lexer_1.default.has("COLON") ? { type: "COLON" } : COLON)] },
        { "name": "stmtSep$ebnf$1$subexpression$2", "symbols": [(lexer_1.default.has("NEWLINE") ? { type: "NEWLINE" } : NEWLINE)] },
        { "name": "stmtSep$ebnf$1", "symbols": ["stmtSep$ebnf$1", "stmtSep$ebnf$1$subexpression$2"], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "stmtSep", "symbols": ["stmtSep$ebnf$1"], "postprocess": discard },
        { "name": "stmtWithSep$ebnf$1", "symbols": ["stmtSep"], "postprocess": id },
        { "name": "stmtWithSep$ebnf$1", "symbols": [], "postprocess": function () { return null; } },
        { "name": "stmtWithSep", "symbols": ["labelStmt", "stmtWithSep$ebnf$1"], "postprocess": id },
        { "name": "stmtWithSep", "symbols": ["nonLabelStmt", "stmtSep"], "postprocess": id },
        { "name": "stmtWithSep$ebnf$2", "symbols": ["stmtSep"], "postprocess": id },
        { "name": "stmtWithSep$ebnf$2", "symbols": [], "postprocess": function () { return null; } },
        { "name": "stmtWithSep", "symbols": ["singleLineIfStmt", "stmtWithSep$ebnf$2"], "postprocess": id },
        { "name": "nonLabelStmt", "symbols": ["dimStmt"], "postprocess": id },
        { "name": "nonLabelStmt", "symbols": ["assignStmt"], "postprocess": id },
        { "name": "nonLabelStmt", "symbols": ["constStmt"], "postprocess": id },
        { "name": "nonLabelStmt", "symbols": ["gotoStmt"], "postprocess": id },
        { "name": "nonLabelStmt", "symbols": ["blockIfStmt"], "postprocess": id },
        { "name": "nonLabelStmt", "symbols": ["selectStmt"], "postprocess": id },
        { "name": "nonLabelStmt", "symbols": ["whileStmt"], "postprocess": id },
        { "name": "nonLabelStmt", "symbols": ["doWhileStmt"], "postprocess": id },
        { "name": "nonLabelStmt", "symbols": ["doUntilStmt"], "postprocess": id },
        { "name": "nonLabelStmt", "symbols": ["loopWhileStmt"], "postprocess": id },
        { "name": "nonLabelStmt", "symbols": ["loopUntilStmt"], "postprocess": id },
        { "name": "nonLabelStmt", "symbols": ["doLoopStmt"], "postprocess": id },
        { "name": "nonLabelStmt", "symbols": ["exitLoopStmt"], "postprocess": id },
        { "name": "nonLabelStmt", "symbols": ["forStmt"], "postprocess": id },
        { "name": "nonLabelStmt", "symbols": ["nextStmt"], "postprocess": id },
        { "name": "nonLabelStmt", "symbols": ["exitForStmt"], "postprocess": id },
        { "name": "nonLabelStmt", "symbols": ["gosubStmt"], "postprocess": id },
        { "name": "nonLabelStmt", "symbols": ["returnStmt"], "postprocess": id },
        { "name": "nonLabelStmt", "symbols": ["callStmt"], "postprocess": id },
        { "name": "nonLabelStmt", "symbols": ["exitProcStmt"], "postprocess": id },
        { "name": "nonLabelStmt", "symbols": ["endStmt"], "postprocess": id },
        { "name": "nonLabelStmt", "symbols": ["swapStmt"], "postprocess": id },
        { "name": "nonLabelStmt", "symbols": ["printStmt"], "postprocess": id },
        { "name": "nonLabelStmt", "symbols": ["inputStmt"], "postprocess": id },
        { "name": "nonLabelStmt", "symbols": ["defTypeStmt"], "postprocess": id },
        { "name": "nonLabelStmt", "symbols": ["dataStmt"], "postprocess": id },
        { "name": "nonLabelStmt", "symbols": ["readStmt"], "postprocess": id },
        { "name": "nonLabelStmt", "symbols": ["restoreStmt"], "postprocess": id },
        { "name": "nonLabelStmt", "symbols": ["callStmtWithOptParams"], "postprocess": id },
        { "name": "nonLabelStmt", "symbols": ["defSegStmt"], "postprocess": id },
        { "name": "nonLabelStmt", "symbols": ["viewPrintStmt"], "postprocess": id },
        { "name": "labelStmt", "symbols": [(lexer_1.default.has("NUMERIC_LITERAL") ? { type: "NUMERIC_LITERAL" } : NUMERIC_LITERAL)], "postprocess": function (_a, _, reject) {
                var $1 = _a[0];
                return $1.isFirstTokenOnLine ? __assign({ type: ast_1.StmtType.LABEL, label: $1.value }, useLoc($1)) : reject;
            }
        },
        { "name": "labelStmt", "symbols": [(lexer_1.default.has("IDENTIFIER") ? { type: "IDENTIFIER" } : IDENTIFIER), (lexer_1.default.has("COLON") ? { type: "COLON" } : COLON)], "postprocess": function (_a, _, reject) {
                var $1 = _a[0], $2 = _a[1];
                // A line like "f: f:" should parse as a label "f" followed by an invocation of the
                // sub "f", so need to explicitly disambiguate here.
                return $1.isFirstTokenOnLine ? __assign({ type: ast_1.StmtType.LABEL, label: $1.value }, useLoc($1)) : reject;
            }
        },
        { "name": "dimStmt$ebnf$1", "symbols": [(lexer_1.default.has("SHARED") ? { type: "SHARED" } : SHARED)], "postprocess": id },
        { "name": "dimStmt$ebnf$1", "symbols": [], "postprocess": function () { return null; } },
        { "name": "dimStmt", "symbols": [(lexer_1.default.has("DIM") ? { type: "DIM" } : DIM), "dimStmt$ebnf$1", "varDecls"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1], $3 = _a[2];
                return (__assign({ type: ast_1.StmtType.DIM, dimType: $2 ? ast_1.DimType.SHARED : ast_1.DimType.LOCAL, varDecls: $3 }, useLoc($1)));
            }
        },
        { "name": "dimStmt", "symbols": [(lexer_1.default.has("STATIC") ? { type: "STATIC" } : STATIC), "varDecls"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1];
                return (__assign({ type: ast_1.StmtType.DIM, dimType: ast_1.DimType.STATIC, varDecls: $2 }, useLoc($1)));
            }
        },
        { "name": "dimStmt", "symbols": [(lexer_1.default.has("SHARED") ? { type: "SHARED" } : SHARED), "varDecls"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1];
                return (__assign({ type: ast_1.StmtType.DIM, dimType: ast_1.DimType.SHARED, varDecls: $2 }, useLoc($1)));
            }
        },
        { "name": "varDecls$ebnf$1", "symbols": [] },
        { "name": "varDecls$ebnf$1$subexpression$1", "symbols": ["varDecl", (lexer_1.default.has("COMMA") ? { type: "COMMA" } : COMMA)] },
        { "name": "varDecls$ebnf$1", "symbols": ["varDecls$ebnf$1", "varDecls$ebnf$1$subexpression$1"], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "varDecls", "symbols": ["varDecls$ebnf$1", "varDecl"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1];
                return __spreadArray(__spreadArray([], ($1 ? $1.map(function (_a) {
                    var $1_1 = _a[0], $1_2 = _a[1];
                    return $1_1;
                }) : []), true), [
                    $2,
                ], false);
            }
        },
        { "name": "varDecl", "symbols": [(lexer_1.default.has("IDENTIFIER") ? { type: "IDENTIFIER" } : IDENTIFIER), "singularTypeExprOrDefault"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1];
                return (__assign({ name: $1.value, typeExpr: $2 }, useLoc($1)));
            }
        },
        { "name": "varDecl$ebnf$1", "symbols": ["dimensionSpecExprs"], "postprocess": id },
        { "name": "varDecl$ebnf$1", "symbols": [], "postprocess": function () { return null; } },
        { "name": "varDecl", "symbols": [(lexer_1.default.has("IDENTIFIER") ? { type: "IDENTIFIER" } : IDENTIFIER), (lexer_1.default.has("LPAREN") ? { type: "LPAREN" } : LPAREN), "varDecl$ebnf$1", (lexer_1.default.has("RPAREN") ? { type: "RPAREN" } : RPAREN), "singularTypeExprOrDefault"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1], $3 = _a[2], $4 = _a[3], $5 = _a[4];
                return (__assign({ name: $1.value, typeExpr: __assign({ type: ast_1.DataTypeExprType.ARRAY, elementTypeExpr: $5, dimensionSpecExprs: $3 !== null && $3 !== void 0 ? $3 : [] }, useLoc($1)) }, useLoc($1)));
            }
        },
        { "name": "dimensionSpecExprs$ebnf$1", "symbols": [] },
        { "name": "dimensionSpecExprs$ebnf$1$subexpression$1", "symbols": ["dimensionSpecExpr", (lexer_1.default.has("COMMA") ? { type: "COMMA" } : COMMA)] },
        { "name": "dimensionSpecExprs$ebnf$1", "symbols": ["dimensionSpecExprs$ebnf$1", "dimensionSpecExprs$ebnf$1$subexpression$1"], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "dimensionSpecExprs", "symbols": ["dimensionSpecExprs$ebnf$1", "dimensionSpecExpr"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1];
                return __spreadArray(__spreadArray([], ($1 ? $1.map(function (_a) {
                    var $1_1 = _a[0], $1_2 = _a[1];
                    return $1_1;
                }) : []), true), [
                    $2,
                ], false);
            }
        },
        { "name": "dimensionSpecExpr", "symbols": ["expr"], "postprocess": function (_a) {
                var $1 = _a[0];
                return (__assign({ maxIdxExpr: $1 }, useLoc($1)));
            } },
        { "name": "dimensionSpecExpr", "symbols": ["expr", (lexer_1.default.has("TO") ? { type: "TO" } : TO), "expr"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1], $3 = _a[2];
                return (__assign({ minIdxExpr: $1, maxIdxExpr: $3 }, useLoc($1)));
            }
        },
        { "name": "assignStmt$ebnf$1", "symbols": [(lexer_1.default.has("LET") ? { type: "LET" } : LET)], "postprocess": id },
        { "name": "assignStmt$ebnf$1", "symbols": [], "postprocess": function () { return null; } },
        { "name": "assignStmt", "symbols": ["assignStmt$ebnf$1", "lhsExpr", (lexer_1.default.has("EQ") ? { type: "EQ" } : EQ), "expr"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1], $3 = _a[2], $4 = _a[3];
                return (__assign({ type: ast_1.StmtType.ASSIGN, targetExpr: $2, valueExpr: $4 }, useLoc($1 || $2)));
            }
        },
        { "name": "constStmt", "symbols": [(lexer_1.default.has("CONST") ? { type: "CONST" } : CONST), "constDefs"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1];
                return (__assign({ type: ast_1.StmtType.CONST, constDefs: $2 }, useLoc($1)));
            }
        },
        { "name": "constDefs$ebnf$1", "symbols": [] },
        { "name": "constDefs$ebnf$1$subexpression$1", "symbols": ["constDef", (lexer_1.default.has("COMMA") ? { type: "COMMA" } : COMMA)] },
        { "name": "constDefs$ebnf$1", "symbols": ["constDefs$ebnf$1", "constDefs$ebnf$1$subexpression$1"], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "constDefs", "symbols": ["constDefs$ebnf$1", "constDef"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1];
                return __spreadArray(__spreadArray([], ($1 ? $1.map(function (_a) {
                    var $1_1 = _a[0], $1_2 = _a[1];
                    return $1_1;
                }) : []), true), [
                    $2,
                ], false);
            }
        },
        { "name": "constDef", "symbols": [(lexer_1.default.has("IDENTIFIER") ? { type: "IDENTIFIER" } : IDENTIFIER), (lexer_1.default.has("EQ") ? { type: "EQ" } : EQ), "expr"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1], $3 = _a[2];
                return (__assign({ name: $1.value, valueExpr: $3 }, useLoc($1)));
            }
        },
        { "name": "gotoStmt", "symbols": [(lexer_1.default.has("GOTO") ? { type: "GOTO" } : GOTO), "labelRef"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1];
                return (__assign({ type: ast_1.StmtType.GOTO, destLabel: $2 }, useLoc($1)));
            }
        },
        { "name": "singleLineIfStmt$ebnf$1$subexpression$1", "symbols": [(lexer_1.default.has("ELSE") ? { type: "ELSE" } : ELSE), "singleLineStmts"] },
        { "name": "singleLineIfStmt$ebnf$1", "symbols": ["singleLineIfStmt$ebnf$1$subexpression$1"], "postprocess": id },
        { "name": "singleLineIfStmt$ebnf$1", "symbols": [], "postprocess": function () { return null; } },
        { "name": "singleLineIfStmt", "symbols": [(lexer_1.default.has("IF") ? { type: "IF" } : IF), "expr", (lexer_1.default.has("THEN") ? { type: "THEN" } : THEN), "singleLineStmts", "singleLineIfStmt$ebnf$1", (lexer_1.default.has("NEWLINE") ? { type: "NEWLINE" } : NEWLINE)], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1], $3 = _a[2], $4 = _a[3], $5 = _a[4], $6 = _a[5], $7 = _a[6];
                return (__assign({ type: ast_1.StmtType.IF, ifBranches: [__assign({ condExpr: $2, stmts: $4 }, useLoc($1))], elseBranch: $5 ? __assign({ stmts: $5[1] }, useLoc($5[0])) : null }, useLoc($1)));
            }
        },
        { "name": "blockIfStmt$ebnf$1", "symbols": [] },
        { "name": "blockIfStmt$ebnf$1$subexpression$1", "symbols": [(lexer_1.default.has("ELSEIF") ? { type: "ELSEIF" } : ELSEIF), "expr", (lexer_1.default.has("THEN") ? { type: "THEN" } : THEN), (lexer_1.default.has("NEWLINE") ? { type: "NEWLINE" } : NEWLINE), "stmts"] },
        { "name": "blockIfStmt$ebnf$1", "symbols": ["blockIfStmt$ebnf$1", "blockIfStmt$ebnf$1$subexpression$1"], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "blockIfStmt$ebnf$2$subexpression$1", "symbols": [(lexer_1.default.has("ELSE") ? { type: "ELSE" } : ELSE), "stmts"] },
        { "name": "blockIfStmt$ebnf$2", "symbols": ["blockIfStmt$ebnf$2$subexpression$1"], "postprocess": id },
        { "name": "blockIfStmt$ebnf$2", "symbols": [], "postprocess": function () { return null; } },
        { "name": "blockIfStmt", "symbols": [(lexer_1.default.has("IF") ? { type: "IF" } : IF), "expr", (lexer_1.default.has("THEN") ? { type: "THEN" } : THEN), (lexer_1.default.has("NEWLINE") ? { type: "NEWLINE" } : NEWLINE), "stmts", "blockIfStmt$ebnf$1", "blockIfStmt$ebnf$2", (lexer_1.default.has("END") ? { type: "END" } : END), (lexer_1.default.has("IF") ? { type: "IF" } : IF)], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1], $3 = _a[2], $4 = _a[3], $5 = _a[4], $6 = _a[5], $7 = _a[6], $8 = _a[7], $9 = _a[8];
                return (__assign({ type: ast_1.StmtType.IF, ifBranches: __spreadArray([
                        __assign({ condExpr: $2, stmts: $5 }, useLoc($1))
                    ], $6.map(function (_a) {
                        var $6_1 = _a[0], $6_2 = _a[1], $6_3 = _a[2], $6_4 = _a[3], $6_5 = _a[4];
                        return (__assign({ condExpr: $6_2, stmts: $6_5 }, useLoc($6_1)));
                    }), true), elseBranch: $7 ? __assign({ stmts: $7[1] }, useLoc($7[0])) : null }, useLoc($1)));
            }
        },
        { "name": "selectStmt$ebnf$1", "symbols": ["stmtSep"], "postprocess": id },
        { "name": "selectStmt$ebnf$1", "symbols": [], "postprocess": function () { return null; } },
        { "name": "selectStmt$ebnf$2$subexpression$1", "symbols": [(lexer_1.default.has("CASE") ? { type: "CASE" } : CASE), "caseExprs", "stmts"] },
        { "name": "selectStmt$ebnf$2", "symbols": ["selectStmt$ebnf$2$subexpression$1"] },
        { "name": "selectStmt$ebnf$2$subexpression$2", "symbols": [(lexer_1.default.has("CASE") ? { type: "CASE" } : CASE), "caseExprs", "stmts"] },
        { "name": "selectStmt$ebnf$2", "symbols": ["selectStmt$ebnf$2", "selectStmt$ebnf$2$subexpression$2"], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "selectStmt$ebnf$3$subexpression$1", "symbols": [(lexer_1.default.has("CASE") ? { type: "CASE" } : CASE), (lexer_1.default.has("ELSE") ? { type: "ELSE" } : ELSE), "stmts"] },
        { "name": "selectStmt$ebnf$3", "symbols": ["selectStmt$ebnf$3$subexpression$1"], "postprocess": id },
        { "name": "selectStmt$ebnf$3", "symbols": [], "postprocess": function () { return null; } },
        { "name": "selectStmt", "symbols": [(lexer_1.default.has("SELECT") ? { type: "SELECT" } : SELECT), (lexer_1.default.has("CASE") ? { type: "CASE" } : CASE), "expr", "selectStmt$ebnf$1", "selectStmt$ebnf$2", "selectStmt$ebnf$3", (lexer_1.default.has("END") ? { type: "END" } : END), (lexer_1.default.has("SELECT") ? { type: "SELECT" } : SELECT)], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1], $3 = _a[2], $4 = _a[3], $5 = _a[4], $6 = _a[5], $7 = _a[6], $8 = _a[7];
                return (__assign({ type: ast_1.StmtType.SELECT, testExpr: $3, ifBranches: $5.map(function (_a) {
                        var $5_1 = _a[0], $5_2 = _a[1], $5_3 = _a[2];
                        return (__assign({ condExprs: $5_2, stmts: $5_3 }, useLoc($5_1)));
                    }), elseBranch: $6 ? __assign({ stmts: $6[2] }, useLoc($6[0])) : null }, useLoc($1)));
            }
        },
        { "name": "caseExprs$ebnf$1", "symbols": [] },
        { "name": "caseExprs$ebnf$1$subexpression$1", "symbols": ["caseExpr", (lexer_1.default.has("COMMA") ? { type: "COMMA" } : COMMA)] },
        { "name": "caseExprs$ebnf$1", "symbols": ["caseExprs$ebnf$1", "caseExprs$ebnf$1$subexpression$1"], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "caseExprs", "symbols": ["caseExprs$ebnf$1", "caseExpr"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1];
                return __spreadArray(__spreadArray([], ($1 ? $1.map(function (_a) {
                    var $1_1 = _a[0], $1_2 = _a[1];
                    return $1_1;
                }) : []), true), [$2], false);
            }
        },
        { "name": "caseExpr", "symbols": ["expr"], "postprocess": function (_a) {
                var $1 = _a[0];
                return ({
                    type: ast_1.CaseExprType.VALUE,
                    valueExpr: $1,
                });
            }
        },
        { "name": "caseExpr", "symbols": ["expr", (lexer_1.default.has("TO") ? { type: "TO" } : TO), "expr"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1], $3 = _a[2];
                return ({
                    type: ast_1.CaseExprType.RANGE,
                    lowerBoundExpr: $1,
                    upperBoundExpr: $3,
                });
            }
        },
        { "name": "caseExpr$subexpression$1", "symbols": [(lexer_1.default.has("EQ") ? { type: "EQ" } : EQ)] },
        { "name": "caseExpr$subexpression$1", "symbols": [(lexer_1.default.has("NE") ? { type: "NE" } : NE)] },
        { "name": "caseExpr$subexpression$1", "symbols": [(lexer_1.default.has("GT") ? { type: "GT" } : GT)] },
        { "name": "caseExpr$subexpression$1", "symbols": [(lexer_1.default.has("GTE") ? { type: "GTE" } : GTE)] },
        { "name": "caseExpr$subexpression$1", "symbols": [(lexer_1.default.has("LT") ? { type: "LT" } : LT)] },
        { "name": "caseExpr$subexpression$1", "symbols": [(lexer_1.default.has("LTE") ? { type: "LTE" } : LTE)] },
        { "name": "caseExpr", "symbols": [(lexer_1.default.has("IS") ? { type: "IS" } : IS), "caseExpr$subexpression$1", "expr"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1], $3 = _a[2];
                return ({
                    type: ast_1.CaseExprType.COMP,
                    op: id($2).type.toLowerCase(),
                    rightExpr: $3,
                });
            }
        },
        { "name": "whileStmt", "symbols": [(lexer_1.default.has("WHILE") ? { type: "WHILE" } : WHILE), "expr", "stmts", (lexer_1.default.has("WEND") ? { type: "WEND" } : WEND)], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1], $3 = _a[2], $4 = _a[3];
                return (__assign({ type: ast_1.StmtType.COND_LOOP, structure: ast_1.CondLoopStructure.COND_EXPR_BEFORE_STMTS, condExpr: $2, isCondNegated: false, stmts: $3 }, useLoc($1)));
            }
        },
        { "name": "doWhileStmt", "symbols": [(lexer_1.default.has("DO") ? { type: "DO" } : DO), (lexer_1.default.has("WHILE") ? { type: "WHILE" } : WHILE), "expr", "stmts", (lexer_1.default.has("LOOP") ? { type: "LOOP" } : LOOP)], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1], $3 = _a[2], $4 = _a[3], $5 = _a[4];
                return (__assign({ type: ast_1.StmtType.COND_LOOP, structure: ast_1.CondLoopStructure.COND_EXPR_BEFORE_STMTS, condExpr: $3, isCondNegated: false, stmts: $4 }, useLoc($1)));
            }
        },
        { "name": "doUntilStmt", "symbols": [(lexer_1.default.has("DO") ? { type: "DO" } : DO), (lexer_1.default.has("UNTIL") ? { type: "UNTIL" } : UNTIL), "expr", "stmts", (lexer_1.default.has("LOOP") ? { type: "LOOP" } : LOOP)], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1], $3 = _a[2], $4 = _a[3], $5 = _a[4];
                return (__assign({ type: ast_1.StmtType.COND_LOOP, structure: ast_1.CondLoopStructure.COND_EXPR_BEFORE_STMTS, condExpr: $3, isCondNegated: true, stmts: $4 }, useLoc($1)));
            }
        },
        { "name": "loopWhileStmt", "symbols": [(lexer_1.default.has("DO") ? { type: "DO" } : DO), "stmts", (lexer_1.default.has("LOOP") ? { type: "LOOP" } : LOOP), (lexer_1.default.has("WHILE") ? { type: "WHILE" } : WHILE), "expr"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1], $3 = _a[2], $4 = _a[3], $5 = _a[4];
                return (__assign({ type: ast_1.StmtType.COND_LOOP, structure: ast_1.CondLoopStructure.COND_EXPR_AFTER_STMTS, condExpr: $5, isCondNegated: false, stmts: $2 }, useLoc($1)));
            }
        },
        { "name": "loopUntilStmt", "symbols": [(lexer_1.default.has("DO") ? { type: "DO" } : DO), "stmts", (lexer_1.default.has("LOOP") ? { type: "LOOP" } : LOOP), (lexer_1.default.has("UNTIL") ? { type: "UNTIL" } : UNTIL), "expr"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1], $3 = _a[2], $4 = _a[3], $5 = _a[4];
                return (__assign({ type: ast_1.StmtType.COND_LOOP, structure: ast_1.CondLoopStructure.COND_EXPR_AFTER_STMTS, condExpr: $5, isCondNegated: true, stmts: $2 }, useLoc($1)));
            }
        },
        { "name": "doLoopStmt", "symbols": [(lexer_1.default.has("DO") ? { type: "DO" } : DO), "stmts", (lexer_1.default.has("LOOP") ? { type: "LOOP" } : LOOP)], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1], $3 = _a[2];
                return (__assign({ type: ast_1.StmtType.UNCOND_LOOP, stmts: $2 }, useLoc($1)));
            }
        },
        { "name": "exitLoopStmt", "symbols": [(lexer_1.default.has("EXIT") ? { type: "EXIT" } : EXIT), (lexer_1.default.has("DO") ? { type: "DO" } : DO)], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1];
                return (__assign({ type: ast_1.StmtType.EXIT_LOOP }, useLoc($1)));
            } },
        { "name": "forStmt$ebnf$1$subexpression$1", "symbols": [(lexer_1.default.has("STEP") ? { type: "STEP" } : STEP), "expr"] },
        { "name": "forStmt$ebnf$1", "symbols": ["forStmt$ebnf$1$subexpression$1"], "postprocess": id },
        { "name": "forStmt$ebnf$1", "symbols": [], "postprocess": function () { return null; } },
        { "name": "forStmt", "symbols": [(lexer_1.default.has("FOR") ? { type: "FOR" } : FOR), "lhsExpr", (lexer_1.default.has("EQ") ? { type: "EQ" } : EQ), "expr", (lexer_1.default.has("TO") ? { type: "TO" } : TO), "expr", "forStmt$ebnf$1"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1], $3 = _a[2], $4 = _a[3], $5 = _a[4], $6 = _a[5], $7 = _a[6];
                return (__assign({ type: ast_1.StmtType.FOR, counterExpr: $2, startExpr: $4, endExpr: $6, stepExpr: $7 ? $7[1] : null }, useLoc($1)));
            }
        },
        { "name": "nextStmt$ebnf$1", "symbols": ["lhsExprs"], "postprocess": id },
        { "name": "nextStmt$ebnf$1", "symbols": [], "postprocess": function () { return null; } },
        { "name": "nextStmt", "symbols": [(lexer_1.default.has("NEXT") ? { type: "NEXT" } : NEXT), "nextStmt$ebnf$1"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1];
                return (__assign({ type: ast_1.StmtType.NEXT, counterExprs: $2 !== null && $2 !== void 0 ? $2 : [] }, useLoc($1)));
            }
        },
        { "name": "exitForStmt", "symbols": [(lexer_1.default.has("EXIT") ? { type: "EXIT" } : EXIT), (lexer_1.default.has("FOR") ? { type: "FOR" } : FOR)], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1];
                return (__assign({ type: ast_1.StmtType.EXIT_FOR }, useLoc($1)));
            } },
        { "name": "gosubStmt", "symbols": [(lexer_1.default.has("GOSUB") ? { type: "GOSUB" } : GOSUB), "labelRef"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1];
                return (__assign({ type: ast_1.StmtType.GOSUB, destLabel: $2 }, useLoc($1)));
            }
        },
        { "name": "returnStmt$ebnf$1", "symbols": ["labelRef"], "postprocess": id },
        { "name": "returnStmt$ebnf$1", "symbols": [], "postprocess": function () { return null; } },
        { "name": "returnStmt", "symbols": [(lexer_1.default.has("RETURN") ? { type: "RETURN" } : RETURN), "returnStmt$ebnf$1"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1];
                return (__assign({ type: ast_1.StmtType.RETURN, destLabel: $2 }, useLoc($1)));
            }
        },
        { "name": "callStmt$ebnf$1$subexpression$1", "symbols": [(lexer_1.default.has("LPAREN") ? { type: "LPAREN" } : LPAREN), "exprs", (lexer_1.default.has("RPAREN") ? { type: "RPAREN" } : RPAREN)] },
        { "name": "callStmt$ebnf$1", "symbols": ["callStmt$ebnf$1$subexpression$1"], "postprocess": id },
        { "name": "callStmt$ebnf$1", "symbols": [], "postprocess": function () { return null; } },
        { "name": "callStmt", "symbols": [(lexer_1.default.has("CALL") ? { type: "CALL" } : CALL), (lexer_1.default.has("IDENTIFIER") ? { type: "IDENTIFIER" } : IDENTIFIER), "callStmt$ebnf$1"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1], $3 = _a[2];
                return (__assign({ type: ast_1.StmtType.CALL, name: $2.value, argExprs: $3 ? $3[1] : [] }, useLoc($1)));
            }
        },
        { "name": "callStmt", "symbols": [(lexer_1.default.has("IDENTIFIER") ? { type: "IDENTIFIER" } : IDENTIFIER), "exprs"], "postprocess": function (_a, _, reject) {
                var $1 = _a[0], $2 = _a[1];
                // A line like "f: f:" should parse as a label "f" followed by an invocation of the
                // sub "f", so need to explicitly disambiguate here.
                if ($1.isFirstTokenOnLine && $2.length === 0) {
                    var nextToken = lexer_1.default.peek();
                    if (nextToken && nextToken.type === 'COLON') {
                        return reject;
                    }
                }
                // A line like "A(0) = 42" should parse as an assignment rather than a CALL statement.
                if ($2.length === 1 && $2[0].type === ast_1.ExprType.BINARY_OP && $2[0].op === ast_1.BinaryOp.EQ) {
                    return reject;
                }
                return __assign({ type: ast_1.StmtType.CALL, name: $1.value, argExprs: $2 }, useLoc($1));
            }
        },
        { "name": "exitProcStmt", "symbols": [(lexer_1.default.has("EXIT") ? { type: "EXIT" } : EXIT), (lexer_1.default.has("FUNCTION") ? { type: "FUNCTION" } : FUNCTION)], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1];
                return (__assign({ type: ast_1.StmtType.EXIT_PROC, procType: types_1.ProcType.FN }, useLoc($1)));
            }
        },
        { "name": "exitProcStmt", "symbols": [(lexer_1.default.has("EXIT") ? { type: "EXIT" } : EXIT), (lexer_1.default.has("SUB") ? { type: "SUB" } : SUB)], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1];
                return (__assign({ type: ast_1.StmtType.EXIT_PROC, procType: types_1.ProcType.SUB }, useLoc($1)));
            }
        },
        { "name": "endStmt$subexpression$1", "symbols": [(lexer_1.default.has("END") ? { type: "END" } : END)] },
        { "name": "endStmt$subexpression$1", "symbols": [(lexer_1.default.has("SYSTEM") ? { type: "SYSTEM" } : SYSTEM)] },
        { "name": "endStmt$subexpression$1", "symbols": [(lexer_1.default.has("STOP") ? { type: "STOP" } : STOP)] },
        { "name": "endStmt", "symbols": ["endStmt$subexpression$1"], "postprocess": function (_a) {
                var $1 = _a[0];
                return (__assign({ type: ast_1.StmtType.END }, useLoc(id($1))));
            } },
        { "name": "swapStmt", "symbols": [(lexer_1.default.has("SWAP") ? { type: "SWAP" } : SWAP), "lhsExpr", (lexer_1.default.has("COMMA") ? { type: "COMMA" } : COMMA), "lhsExpr"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1], $3 = _a[2], $4 = _a[3];
                return (__assign({ type: ast_1.StmtType.SWAP, leftExpr: $2, rightExpr: $4 }, useLoc($1)));
            }
        },
        { "name": "printStmt$ebnf$1$subexpression$1", "symbols": [(lexer_1.default.has("USING") ? { type: "USING" } : USING), "expr", (lexer_1.default.has("SEMICOLON") ? { type: "SEMICOLON" } : SEMICOLON)] },
        { "name": "printStmt$ebnf$1", "symbols": ["printStmt$ebnf$1$subexpression$1"], "postprocess": id },
        { "name": "printStmt$ebnf$1", "symbols": [], "postprocess": function () { return null; } },
        { "name": "printStmt", "symbols": [(lexer_1.default.has("PRINT") ? { type: "PRINT" } : PRINT), "printStmt$ebnf$1", "printArgs"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1], $3 = _a[2];
                return (__assign({ type: ast_1.StmtType.PRINT, args: $3, formatExpr: $2 ? $2[1] : null }, useLoc($1)));
            }
        },
        { "name": "printArgs$ebnf$1", "symbols": [] },
        { "name": "printArgs$ebnf$1$subexpression$1", "symbols": ["expr"] },
        { "name": "printArgs$ebnf$1$subexpression$1", "symbols": ["printSep"] },
        { "name": "printArgs$ebnf$1", "symbols": ["printArgs$ebnf$1", "printArgs$ebnf$1$subexpression$1"], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "printArgs", "symbols": ["printArgs$ebnf$1"], "postprocess": function (_a, location, reject) {
                var $1 = _a[0];
                var args = lodash_1.default.flatten($1);
                // Disambiguate "fn (x)" - prefer to parse as function call.
                for (var i = 0; i < args.length - 1; ++i) {
                    var arg1 = args[i], arg2 = args[i + 1];
                    if (typeof arg1 !== 'string' && arg1.type === ast_1.ExprType.VAR_REF &&
                        typeof arg2 !== 'string' && arg2.type === ast_1.ExprType.UNARY_OP && arg2.op === ast_1.UnaryOp.PARENS) {
                        return reject;
                    }
                }
                return args;
            }
        },
        { "name": "printSep", "symbols": [(lexer_1.default.has("COMMA") ? { type: "COMMA" } : COMMA)], "postprocess": function () { return ast_1.PrintSep.COMMA; } },
        { "name": "printSep", "symbols": [(lexer_1.default.has("SEMICOLON") ? { type: "SEMICOLON" } : SEMICOLON)], "postprocess": function () { return ast_1.PrintSep.SEMICOLON; } },
        { "name": "inputStmt$ebnf$1$subexpression$1", "symbols": [(lexer_1.default.has("STRING_LITERAL") ? { type: "STRING_LITERAL" } : STRING_LITERAL), "inputStmtPromptSep"] },
        { "name": "inputStmt$ebnf$1", "symbols": ["inputStmt$ebnf$1$subexpression$1"], "postprocess": id },
        { "name": "inputStmt$ebnf$1", "symbols": [], "postprocess": function () { return null; } },
        { "name": "inputStmt", "symbols": [(lexer_1.default.has("INPUT") ? { type: "INPUT" } : INPUT), "inputStmt$ebnf$1", "lhsExprs"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1], $3 = _a[2];
                return (__assign({ type: ast_1.StmtType.INPUT, prompt: $2 ? "".concat($2[0].value).concat($2[1] ? '? ' : '') : '? ', inputType: ast_1.InputType.TOKENIZED, targetExprs: $3 }, useLoc($1)));
            }
        },
        { "name": "inputStmt$ebnf$2$subexpression$1", "symbols": [(lexer_1.default.has("STRING_LITERAL") ? { type: "STRING_LITERAL" } : STRING_LITERAL), "inputStmtPromptSep"] },
        { "name": "inputStmt$ebnf$2", "symbols": ["inputStmt$ebnf$2$subexpression$1"], "postprocess": id },
        { "name": "inputStmt$ebnf$2", "symbols": [], "postprocess": function () { return null; } },
        { "name": "inputStmt", "symbols": [(lexer_1.default.has("LINE") ? { type: "LINE" } : LINE), (lexer_1.default.has("INPUT") ? { type: "INPUT" } : INPUT), "inputStmt$ebnf$2", "lhsExpr"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1], $3 = _a[2], $4 = _a[3];
                return (__assign({ type: ast_1.StmtType.INPUT, prompt: $3 ? $3[0].value : '', inputType: ast_1.InputType.LINE, targetExprs: [$4] }, useLoc($1)));
            }
        },
        { "name": "inputStmtPromptSep", "symbols": [(lexer_1.default.has("COMMA") ? { type: "COMMA" } : COMMA)], "postprocess": function () { return false; } },
        { "name": "inputStmtPromptSep", "symbols": [(lexer_1.default.has("SEMICOLON") ? { type: "SEMICOLON" } : SEMICOLON)], "postprocess": function () { return true; } },
        { "name": "defTypeStmt", "symbols": [(lexer_1.default.has("DEFINT") ? { type: "DEFINT" } : DEFINT), "defTypeRanges"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1];
                return (__assign({ type: ast_1.StmtType.DEF_TYPE, typeSpec: (0, types_1.integerSpec)(), ranges: $2 }, useLoc($1)));
            }
        },
        { "name": "defTypeStmt", "symbols": [(lexer_1.default.has("DEFSNG") ? { type: "DEFSNG" } : DEFSNG), "defTypeRanges"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1];
                return (__assign({ type: ast_1.StmtType.DEF_TYPE, typeSpec: (0, types_1.singleSpec)(), ranges: $2 }, useLoc($1)));
            }
        },
        { "name": "defTypeStmt", "symbols": [(lexer_1.default.has("DEFDBL") ? { type: "DEFDBL" } : DEFDBL), "defTypeRanges"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1];
                return (__assign({ type: ast_1.StmtType.DEF_TYPE, typeSpec: (0, types_1.doubleSpec)(), ranges: $2 }, useLoc($1)));
            }
        },
        { "name": "defTypeStmt", "symbols": [(lexer_1.default.has("DEFLNG") ? { type: "DEFLNG" } : DEFLNG), "defTypeRanges"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1];
                return (__assign({ type: ast_1.StmtType.DEF_TYPE, typeSpec: (0, types_1.longSpec)(), ranges: $2 }, useLoc($1)));
            }
        },
        { "name": "defTypeStmt", "symbols": [(lexer_1.default.has("DEFSTR") ? { type: "DEFSTR" } : DEFSTR), "defTypeRanges"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1];
                return (__assign({ type: ast_1.StmtType.DEF_TYPE, typeSpec: (0, types_1.stringSpec)(), ranges: $2 }, useLoc($1)));
            }
        },
        { "name": "defTypeRanges$ebnf$1", "symbols": [] },
        { "name": "defTypeRanges$ebnf$1$subexpression$1", "symbols": ["defTypeRange", (lexer_1.default.has("COMMA") ? { type: "COMMA" } : COMMA)] },
        { "name": "defTypeRanges$ebnf$1", "symbols": ["defTypeRanges$ebnf$1", "defTypeRanges$ebnf$1$subexpression$1"], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "defTypeRanges", "symbols": ["defTypeRanges$ebnf$1", "defTypeRange"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1];
                return __spreadArray(__spreadArray([], ($1 ? $1.map(function (_a) {
                    var $1_1 = _a[0], $1_2 = _a[1];
                    return $1_1;
                }) : []), true), [$2], false);
            }
        },
        { "name": "defTypeRange", "symbols": [(lexer_1.default.has("IDENTIFIER") ? { type: "IDENTIFIER" } : IDENTIFIER)], "postprocess": function (_a) {
                var $1 = _a[0];
                return (__assign({ minPrefix: $1.value, maxPrefix: $1.value }, useLoc($1)));
            }
        },
        { "name": "defTypeRange", "symbols": [(lexer_1.default.has("IDENTIFIER") ? { type: "IDENTIFIER" } : IDENTIFIER), (lexer_1.default.has("SUB") ? { type: "SUB" } : SUB), (lexer_1.default.has("IDENTIFIER") ? { type: "IDENTIFIER" } : IDENTIFIER)], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1], $3 = _a[2];
                return (__assign({ minPrefix: $1.value, maxPrefix: $3.value }, useLoc($1)));
            }
        },
        { "name": "dataStmt$ebnf$1", "symbols": [] },
        { "name": "dataStmt$ebnf$1$subexpression$1", "symbols": ["dataItem", (lexer_1.default.has("COMMA") ? { type: "COMMA" } : COMMA)] },
        { "name": "dataStmt$ebnf$1", "symbols": ["dataStmt$ebnf$1", "dataStmt$ebnf$1$subexpression$1"], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "dataStmt", "symbols": [(lexer_1.default.has("DATA") ? { type: "DATA" } : DATA), "dataStmt$ebnf$1", "dataItem"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1], $3 = _a[2];
                return (__assign({ type: ast_1.StmtType.DATA, data: __spreadArray(__spreadArray([], $2 ? $2.map(function (_a) {
                        var $2_1 = _a[0], $2_2 = _a[1];
                        return $2_1;
                    }) : [], true), [
                        $3,
                    ], false) }, useLoc($1)));
            }
        },
        { "name": "dataItem", "symbols": [], "postprocess": function () { return buildDataItem(lexer_1.default.lastToken, null); } },
        { "name": "dataItem", "symbols": ["literalExpr"], "postprocess": function (_a) {
                var $1 = _a[0];
                return buildDataItem($1, $1.value);
            } },
        { "name": "dataItem", "symbols": [(lexer_1.default.has("IDENTIFIER") ? { type: "IDENTIFIER" } : IDENTIFIER)], "postprocess": function (_a) {
                var $1 = _a[0];
                return buildDataItem($1, $1.value);
            } },
        { "name": "readStmt", "symbols": [(lexer_1.default.has("READ") ? { type: "READ" } : READ), "lhsExprs"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1];
                return (__assign({ type: ast_1.StmtType.READ, targetExprs: $2 }, useLoc($1)));
            }
        },
        { "name": "restoreStmt$ebnf$1", "symbols": ["labelRef"], "postprocess": id },
        { "name": "restoreStmt$ebnf$1", "symbols": [], "postprocess": function () { return null; } },
        { "name": "restoreStmt", "symbols": [(lexer_1.default.has("RESTORE") ? { type: "RESTORE" } : RESTORE), "restoreStmt$ebnf$1"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1];
                return (__assign({ type: ast_1.StmtType.RESTORE, destLabel: $2 }, useLoc($1)));
            }
        },
        { "name": "callStmtWithOptParams$subexpression$1", "symbols": [(lexer_1.default.has("LOCATE") ? { type: "LOCATE" } : LOCATE)] },
        { "name": "callStmtWithOptParams$subexpression$1", "symbols": [(lexer_1.default.has("COLOR") ? { type: "COLOR" } : COLOR)] },
        { "name": "callStmtWithOptParams$ebnf$1", "symbols": [] },
        { "name": "callStmtWithOptParams$ebnf$1$subexpression$1$ebnf$1", "symbols": ["expr"], "postprocess": id },
        { "name": "callStmtWithOptParams$ebnf$1$subexpression$1$ebnf$1", "symbols": [], "postprocess": function () { return null; } },
        { "name": "callStmtWithOptParams$ebnf$1$subexpression$1", "symbols": ["callStmtWithOptParams$ebnf$1$subexpression$1$ebnf$1", (lexer_1.default.has("COMMA") ? { type: "COMMA" } : COMMA)] },
        { "name": "callStmtWithOptParams$ebnf$1", "symbols": ["callStmtWithOptParams$ebnf$1", "callStmtWithOptParams$ebnf$1$subexpression$1"], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "callStmtWithOptParams", "symbols": ["callStmtWithOptParams$subexpression$1", "callStmtWithOptParams$ebnf$1", "expr"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1], $3 = _a[2];
                return (__assign({ type: ast_1.StmtType.CALL, name: $1[0].value, argExprs: __spreadArray(__spreadArray([], ($2 ? $2.map(function (_a) {
                        var $2_1 = _a[0], $2_2 = _a[1];
                        return $2_1 !== null && $2_1 !== void 0 ? $2_1 : __assign({ type: ast_1.ExprType.LITERAL, value: NaN }, useLoc($2_2));
                    }) : []), true), [
                        $3,
                    ], false) }, useLoc($1[0])));
            }
        },
        { "name": "defSegStmt$ebnf$1$subexpression$1", "symbols": [(lexer_1.default.has("EQ") ? { type: "EQ" } : EQ), "expr"] },
        { "name": "defSegStmt$ebnf$1", "symbols": ["defSegStmt$ebnf$1$subexpression$1"], "postprocess": id },
        { "name": "defSegStmt$ebnf$1", "symbols": [], "postprocess": function () { return null; } },
        { "name": "defSegStmt", "symbols": [(lexer_1.default.has("DEF") ? { type: "DEF" } : DEF), (lexer_1.default.has("SEG") ? { type: "SEG" } : SEG), "defSegStmt$ebnf$1"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1], $3 = _a[2];
                return (__assign({ type: ast_1.StmtType.CALL, name: '__def_seg', argExprs: $3 ? [$3[1]] : [] }, useLoc($1)));
            }
        },
        { "name": "viewPrintStmt$ebnf$1$subexpression$1", "symbols": ["expr", (lexer_1.default.has("TO") ? { type: "TO" } : TO), "expr"] },
        { "name": "viewPrintStmt$ebnf$1", "symbols": ["viewPrintStmt$ebnf$1$subexpression$1"], "postprocess": id },
        { "name": "viewPrintStmt$ebnf$1", "symbols": [], "postprocess": function () { return null; } },
        { "name": "viewPrintStmt", "symbols": [(lexer_1.default.has("VIEW") ? { type: "VIEW" } : VIEW), (lexer_1.default.has("PRINT") ? { type: "PRINT" } : PRINT), "viewPrintStmt$ebnf$1"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1], $3 = _a[2];
                return (__assign({ type: ast_1.StmtType.CALL, name: '__view_print', argExprs: $3 ? [$3[0], $3[2]] : [] }, useLoc($1)));
            }
        },
        { "name": "singleLineStmts$ebnf$1", "symbols": [] },
        { "name": "singleLineStmts$ebnf$1", "symbols": ["singleLineStmts$ebnf$1", (lexer_1.default.has("COLON") ? { type: "COLON" } : COLON)], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "singleLineStmts$ebnf$2", "symbols": [] },
        { "name": "singleLineStmts$ebnf$2$subexpression$1$ebnf$1", "symbols": [(lexer_1.default.has("COLON") ? { type: "COLON" } : COLON)] },
        { "name": "singleLineStmts$ebnf$2$subexpression$1$ebnf$1", "symbols": ["singleLineStmts$ebnf$2$subexpression$1$ebnf$1", (lexer_1.default.has("COLON") ? { type: "COLON" } : COLON)], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "singleLineStmts$ebnf$2$subexpression$1", "symbols": ["singleLineStmts$ebnf$2$subexpression$1$ebnf$1", "nonLabelStmt"] },
        { "name": "singleLineStmts$ebnf$2", "symbols": ["singleLineStmts$ebnf$2", "singleLineStmts$ebnf$2$subexpression$1"], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "singleLineStmts", "symbols": ["singleLineStmts$ebnf$1", "nonLabelStmt", "singleLineStmts$ebnf$2"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1], $3 = _a[2];
                return __spreadArray([$2], $3.map(function (_a) {
                    var $3_1 = _a[0], $3_2 = _a[1];
                    return $3_2;
                }), true);
            }
        },
        { "name": "lhsExprs$ebnf$1", "symbols": [] },
        { "name": "lhsExprs$ebnf$1$subexpression$1", "symbols": ["lhsExpr", (lexer_1.default.has("COMMA") ? { type: "COMMA" } : COMMA)] },
        { "name": "lhsExprs$ebnf$1", "symbols": ["lhsExprs$ebnf$1", "lhsExprs$ebnf$1$subexpression$1"], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "lhsExprs", "symbols": ["lhsExprs$ebnf$1", "lhsExpr"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1];
                return __spreadArray(__spreadArray([], ($1 ? $1.map(function (_a) {
                    var $1_1 = _a[0], $1_2 = _a[1];
                    return $1_1;
                }) : []), true), [$2], false);
            }
        },
        { "name": "labelRef$subexpression$1", "symbols": [(lexer_1.default.has("IDENTIFIER") ? { type: "IDENTIFIER" } : IDENTIFIER)] },
        { "name": "labelRef$subexpression$1", "symbols": [(lexer_1.default.has("NUMERIC_LITERAL") ? { type: "NUMERIC_LITERAL" } : NUMERIC_LITERAL)] },
        { "name": "labelRef", "symbols": ["labelRef$subexpression$1"], "postprocess": function (_a) {
                var $1 = _a[0];
                return id($1).value;
            } },
        { "name": "elementaryTypeSpec", "symbols": [(lexer_1.default.has("INTEGER") ? { type: "INTEGER" } : INTEGER)], "postprocess": function () { return (0, types_1.integerSpec)(); } },
        { "name": "elementaryTypeSpec", "symbols": [(lexer_1.default.has("LONG") ? { type: "LONG" } : LONG)], "postprocess": function () { return (0, types_1.longSpec)(); } },
        { "name": "elementaryTypeSpec", "symbols": [(lexer_1.default.has("SINGLE") ? { type: "SINGLE" } : SINGLE)], "postprocess": function () { return (0, types_1.singleSpec)(); } },
        { "name": "elementaryTypeSpec", "symbols": [(lexer_1.default.has("DOUBLE") ? { type: "DOUBLE" } : DOUBLE)], "postprocess": function () { return (0, types_1.doubleSpec)(); } },
        { "name": "elementaryTypeSpec$ebnf$1$subexpression$1", "symbols": [(lexer_1.default.has("MUL") ? { type: "MUL" } : MUL), "expr2"] },
        { "name": "elementaryTypeSpec$ebnf$1", "symbols": ["elementaryTypeSpec$ebnf$1$subexpression$1"], "postprocess": id },
        { "name": "elementaryTypeSpec$ebnf$1", "symbols": [], "postprocess": function () { return null; } },
        { "name": "elementaryTypeSpec", "symbols": [(lexer_1.default.has("STRING") ? { type: "STRING" } : STRING), "elementaryTypeSpec$ebnf$1"], "postprocess": function () { return (0, types_1.stringSpec)(); } },
        { "name": "singularTypeExpr", "symbols": [(lexer_1.default.has("AS") ? { type: "AS" } : AS), "elementaryTypeSpec"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1];
                return (__assign({ type: ast_1.DataTypeExprType.ELEMENTARY, typeSpec: $2 }, useLoc($1)));
            }
        },
        { "name": "singularTypeExpr", "symbols": [(lexer_1.default.has("AS") ? { type: "AS" } : AS), (lexer_1.default.has("IDENTIFIER") ? { type: "IDENTIFIER" } : IDENTIFIER)], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1];
                return (__assign({ type: ast_1.DataTypeExprType.UDT, name: $2.value }, useLoc($1)));
            }
        },
        { "name": "singularTypeExprOrDefault", "symbols": [], "postprocess": function (_a) {
                var $1 = _a[0];
                return ({
                    type: ast_1.DataTypeExprType.ELEMENTARY,
                    loc: { line: lexer_1.default.lastToken.line, col: lexer_1.default.lastToken.col },
                });
            }
        },
        { "name": "singularTypeExprOrDefault", "symbols": ["singularTypeExpr"], "postprocess": id },
        { "name": "expr", "symbols": ["expr10"], "postprocess": id },
        { "name": "lhsExpr", "symbols": ["varRefExpr"], "postprocess": id },
        { "name": "lhsExpr", "symbols": ["fnCallExpr"], "postprocess": id },
        { "name": "lhsExpr", "symbols": ["memberExpr"], "postprocess": id },
        { "name": "expr10", "symbols": ["expr9"], "postprocess": id },
        { "name": "expr10$subexpression$1", "symbols": [(lexer_1.default.has("OR") ? { type: "OR" } : OR)] },
        { "name": "expr10", "symbols": ["expr10", "expr10$subexpression$1", "expr9"], "postprocess": buildBinaryOpExpr },
        { "name": "expr9", "symbols": ["expr8"], "postprocess": id },
        { "name": "expr9$subexpression$1", "symbols": [(lexer_1.default.has("AND") ? { type: "AND" } : AND)] },
        { "name": "expr9", "symbols": ["expr9", "expr9$subexpression$1", "expr8"], "postprocess": buildBinaryOpExpr },
        { "name": "expr8", "symbols": ["expr7"], "postprocess": id },
        { "name": "expr8$subexpression$1", "symbols": [(lexer_1.default.has("NOT") ? { type: "NOT" } : NOT)] },
        { "name": "expr8", "symbols": ["expr8$subexpression$1", "expr7"], "postprocess": buildUnaryOpExpr },
        { "name": "expr7", "symbols": ["expr6"], "postprocess": id },
        { "name": "expr7$subexpression$1", "symbols": [(lexer_1.default.has("EQ") ? { type: "EQ" } : EQ)] },
        { "name": "expr7$subexpression$1", "symbols": [(lexer_1.default.has("NE") ? { type: "NE" } : NE)] },
        { "name": "expr7$subexpression$1", "symbols": [(lexer_1.default.has("GT") ? { type: "GT" } : GT)] },
        { "name": "expr7$subexpression$1", "symbols": [(lexer_1.default.has("GTE") ? { type: "GTE" } : GTE)] },
        { "name": "expr7$subexpression$1", "symbols": [(lexer_1.default.has("LT") ? { type: "LT" } : LT)] },
        { "name": "expr7$subexpression$1", "symbols": [(lexer_1.default.has("LTE") ? { type: "LTE" } : LTE)] },
        { "name": "expr7", "symbols": ["expr6", "expr7$subexpression$1", "expr6"], "postprocess": buildBinaryOpExpr },
        { "name": "expr6", "symbols": ["expr5"], "postprocess": id },
        { "name": "expr6$subexpression$1", "symbols": [(lexer_1.default.has("ADD") ? { type: "ADD" } : ADD)] },
        { "name": "expr6$subexpression$1", "symbols": [(lexer_1.default.has("SUB") ? { type: "SUB" } : SUB)] },
        { "name": "expr6", "symbols": ["expr6", "expr6$subexpression$1", "expr5"], "postprocess": buildBinaryOpExpr },
        { "name": "expr5", "symbols": ["expr4"], "postprocess": id },
        { "name": "expr5$subexpression$1", "symbols": [(lexer_1.default.has("MOD") ? { type: "MOD" } : MOD)] },
        { "name": "expr5", "symbols": ["expr5", "expr5$subexpression$1", "expr4"], "postprocess": buildBinaryOpExpr },
        { "name": "expr4", "symbols": ["expr3"], "postprocess": id },
        { "name": "expr4$subexpression$1", "symbols": [(lexer_1.default.has("INTDIV") ? { type: "INTDIV" } : INTDIV)] },
        { "name": "expr4", "symbols": ["expr4", "expr4$subexpression$1", "expr3"], "postprocess": buildBinaryOpExpr },
        { "name": "expr3", "symbols": ["expr2"], "postprocess": id },
        { "name": "expr3$subexpression$1", "symbols": [(lexer_1.default.has("MUL") ? { type: "MUL" } : MUL)] },
        { "name": "expr3$subexpression$1", "symbols": [(lexer_1.default.has("DIV") ? { type: "DIV" } : DIV)] },
        { "name": "expr3", "symbols": ["expr3", "expr3$subexpression$1", "expr2"], "postprocess": buildBinaryOpExpr },
        { "name": "expr2", "symbols": ["expr1"], "postprocess": id },
        { "name": "expr2$subexpression$1", "symbols": [(lexer_1.default.has("SUB") ? { type: "SUB" } : SUB)] },
        { "name": "expr2", "symbols": ["expr2$subexpression$1", "expr1"], "postprocess": buildUnaryOpExpr },
        { "name": "expr1", "symbols": ["expr0"], "postprocess": id },
        { "name": "expr1$subexpression$1", "symbols": [(lexer_1.default.has("EXP") ? { type: "EXP" } : EXP)] },
        { "name": "expr1", "symbols": ["expr1", "expr1$subexpression$1", "expr0"], "postprocess": buildBinaryOpExpr },
        { "name": "expr0", "symbols": ["varRefExpr"], "postprocess": id },
        { "name": "expr0", "symbols": ["fnCallExpr"], "postprocess": id },
        { "name": "expr0", "symbols": ["literalExpr"], "postprocess": id },
        { "name": "expr0", "symbols": ["memberExpr"], "postprocess": id },
        { "name": "expr0", "symbols": [(lexer_1.default.has("LPAREN") ? { type: "LPAREN" } : LPAREN), "expr", (lexer_1.default.has("RPAREN") ? { type: "RPAREN" } : RPAREN)], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1], $3 = _a[2];
                return (__assign({ type: ast_1.ExprType.UNARY_OP, op: ast_1.UnaryOp.PARENS, rightExpr: $2 }, useLoc($1)));
            }
        },
        { "name": "varRefExpr", "symbols": [(lexer_1.default.has("IDENTIFIER") ? { type: "IDENTIFIER" } : IDENTIFIER)], "postprocess": function (_a) {
                var $1 = _a[0];
                return (__assign({ type: ast_1.ExprType.VAR_REF, name: $1.value }, useLoc($1)));
            }
        },
        { "name": "fnCallExpr", "symbols": [(lexer_1.default.has("IDENTIFIER") ? { type: "IDENTIFIER" } : IDENTIFIER), (lexer_1.default.has("LPAREN") ? { type: "LPAREN" } : LPAREN), "exprs", (lexer_1.default.has("RPAREN") ? { type: "RPAREN" } : RPAREN)], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1], $3 = _a[2], $4 = _a[3];
                return (__assign({ type: ast_1.ExprType.FN_CALL, name: $1.value, argExprs: $3 }, useLoc($1)));
            }
        },
        { "name": "literalExpr", "symbols": ["stringLiteralExpr"], "postprocess": id },
        { "name": "literalExpr", "symbols": ["numericLiteralExpr"], "postprocess": id },
        { "name": "stringLiteralExpr", "symbols": [(lexer_1.default.has("STRING_LITERAL") ? { type: "STRING_LITERAL" } : STRING_LITERAL)], "postprocess": function (_a) {
                var $1 = _a[0];
                return (__assign({ type: ast_1.ExprType.LITERAL, value: $1.value }, useLoc($1)));
            }
        },
        { "name": "numericLiteralExpr", "symbols": [(lexer_1.default.has("NUMERIC_LITERAL") ? { type: "NUMERIC_LITERAL" } : NUMERIC_LITERAL)], "postprocess": function (_a) {
                var $1 = _a[0];
                return (__assign({ type: ast_1.ExprType.LITERAL, value: parseFloat($1.value) }, useLoc($1)));
            }
        },
        { "name": "memberExpr", "symbols": ["lhsExpr", (lexer_1.default.has("DOT") ? { type: "DOT" } : DOT), (lexer_1.default.has("IDENTIFIER") ? { type: "IDENTIFIER" } : IDENTIFIER)], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1], $3 = _a[2];
                return (__assign({ type: ast_1.ExprType.MEMBER, udtExpr: $1, fieldName: $3.value }, useLoc($1)));
            }
        },
        { "name": "exprs", "symbols": [], "postprocess": function () { return []; } },
        { "name": "exprs$ebnf$1", "symbols": [] },
        { "name": "exprs$ebnf$1$subexpression$1", "symbols": ["expr", (lexer_1.default.has("COMMA") ? { type: "COMMA" } : COMMA)] },
        { "name": "exprs$ebnf$1", "symbols": ["exprs$ebnf$1", "exprs$ebnf$1$subexpression$1"], "postprocess": function (d) { return d[0].concat([d[1]]); } },
        { "name": "exprs", "symbols": ["exprs$ebnf$1", "expr"], "postprocess": function (_a) {
                var $1 = _a[0], $2 = _a[1];
                return __spreadArray(__spreadArray([], ($1 ? $1.map(function (_a) {
                    var $1_1 = _a[0], $1_2 = _a[1];
                    return $1_1;
                }) : []), true), [$2], false);
            }
        }
    ],
    ParserStart: "module",
};
exports.default = grammar;
