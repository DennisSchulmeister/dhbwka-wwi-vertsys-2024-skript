"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SemanticAnalyzer = void 0;
var lodash_1 = __importDefault(require("lodash"));
var ast_1 = require("../lib/ast");
var symbol_table_1 = require("../lib/symbol-table");
var types_1 = require("../lib/types");
var builtins_1 = require("../runtime/builtins");
/** Map from variable type declaration suffix to the corresponding type spec. */
var TYPE_SUFFIX_MAP = Object.freeze({
    '%': (0, types_1.integerSpec)(),
    '&': (0, types_1.longSpec)(),
    '!': (0, types_1.singleSpec)(),
    '#': (0, types_1.doubleSpec)(),
    $: (0, types_1.stringSpec)(),
});
/** Default array dimension spec. */
var DEFAULT_DIMENSION_SPEC = [0, 10];
/** Semantic analysis pass.
 *
 * Main tasks:
 *
 * - Type analysis for symbols, expressions and statements
 * - Build symbol table and resolve references
 */
var SemanticAnalyzer = /** @class */ (function (_super) {
    __extends(SemanticAnalyzer, _super);
    function SemanticAnalyzer(module, _a) {
        var _b = _a === void 0 ? {} : _a, sourceFileName = _b.sourceFileName;
        var _this = _super.call(this) || this;
        _this.module = module;
        /** Stack of UDTs being resolved. Used to detect cycles. */
        _this.udtStack = [];
        /** The current proc being visited, or null if currently visiting module-level nodes. */
        _this.currentProc = null;
        /** Default type based on first letter of identifier. */
        _this.defTypeMap = {};
        _this.sourceFileName = sourceFileName;
        return _this;
    }
    SemanticAnalyzer.prototype.run = function () {
        this.visitModule(this.module);
    };
    SemanticAnalyzer.prototype.visitModule = function (module) {
        this.setUpDefTypeMap();
        // Resolve UDT types.
        this.udtStack = [];
        module.udts.forEach(this.visitUdt.bind(this));
        // Resolve type signatures of procs.
        module.procs.forEach(this.preprocessProc.bind(this));
        this.currentProc = null;
        module.localSymbols = [];
        module.globalSymbols = [];
        module.labels = this.getLabels(module.stmts);
        this.acceptAll(module.stmts);
        this.acceptAll(module.procs);
    };
    SemanticAnalyzer.prototype.preprocessProc = function (node) {
        var _this = this;
        node.paramSymbols = node.params.map(function (param) { return ({
            name: param.name,
            varType: symbol_table_1.VarType.ARG,
            typeSpec: _this.getTypeSpecForVarDeclOrParam(param),
            varScope: symbol_table_1.VarScope.LOCAL,
        }); });
        node.localSymbols = [];
        if ((0, ast_1.isFnProcOrDefFnProc)(node)) {
            if (!node.returnTypeSpec) {
                node.returnTypeSpec = this.getDefaultTypeSpecFromName(node.name);
            }
            node.localSymbols.push({
                name: node.name,
                varType: symbol_table_1.VarType.VAR,
                typeSpec: node.returnTypeSpec,
                varScope: symbol_table_1.VarScope.LOCAL,
            });
        }
        node.labels = this.getLabels(node.stmts);
    };
    SemanticAnalyzer.prototype.getLabels = function (stmts) {
        var labelLocMap = {};
        for (var _i = 0, stmts_1 = stmts; _i < stmts_1.length; _i++) {
            var stmt = stmts_1[_i];
            if (stmt.type !== ast_1.StmtType.LABEL) {
                continue;
            }
            if (labelLocMap[stmt.label]) {
                this.throwError("Label \"".concat(stmt.label, "\" already defined on line ").concat(labelLocMap[stmt.label].line), stmt);
            }
            labelLocMap[stmt.label] = stmt.loc;
        }
        return Object.keys(labelLocMap);
    };
    /** Resolve UDT type spec using depth first search. */
    SemanticAnalyzer.prototype.visitUdt = function (udt) {
        var _a;
        if (udt.typeSpec) {
            return;
        }
        // Check if we have a cycle.
        var udtStackIdx = this.udtStack.indexOf(udt);
        if (udtStackIdx >= 0) {
            var udtsInCycle = __spreadArray(__spreadArray([], this.udtStack.slice(udtStackIdx), true), [udt], false);
            this.throwError('Dependency cycle in user-defined types: ' +
                udtsInCycle.map(function (_a) {
                    var name = _a.name;
                    return name;
                }).join(' -> '), udt);
        }
        // Resolve typeSpec of each field.
        this.udtStack.push(udt);
        var typeSpec = {
            type: types_1.DataType.UDT,
            name: udt.name,
            fieldSpecs: [],
        };
        for (var _i = 0, _b = udt.fieldSpecExprs; _i < _b.length; _i++) {
            var _c = _b[_i], fieldName = _c.name, typeExpr = _c.typeExpr;
            var fieldTypeSpec = void 0;
            switch (typeExpr.type) {
                case ast_1.DataTypeExprType.ELEMENTARY:
                    fieldTypeSpec =
                        (_a = typeExpr.typeSpec) !== null && _a !== void 0 ? _a : this.getDefaultTypeSpecFromName(fieldName);
                    break;
                case ast_1.DataTypeExprType.UDT:
                    var fieldUdt = this.lookupUdtOrThrow(typeExpr, typeExpr.name);
                    this.visitUdt(fieldUdt);
                    fieldTypeSpec = fieldUdt.typeSpec;
                    break;
                default:
                    this.throwError("Unexpected field type: ".concat(JSON.stringify(typeExpr)), typeExpr);
            }
            typeSpec.fieldSpecs.push({ name: fieldName, typeSpec: fieldTypeSpec });
        }
        udt.typeSpec = typeSpec;
    };
    SemanticAnalyzer.prototype.visitProc = function (node) {
        this.currentProc = node;
        this.acceptAll(node.stmts);
        this.currentProc = null;
    };
    SemanticAnalyzer.prototype.visitLabelStmt = function (node) { };
    SemanticAnalyzer.prototype.visitDimStmt = function (node) {
        if (node.dimType === ast_1.DimType.STATIC && !this.currentProc) {
            this.throwError('STATIC statement can only be used inside a procedure.', node);
        }
        for (var _i = 0, _a = node.varDecls; _i < _a.length; _i++) {
            var varDecl = _a[_i];
            var typeSpec = this.getTypeSpecForVarDeclOrParam(varDecl);
            var resolvedSymbol = this.lookupSymbol(varDecl.name);
            if (resolvedSymbol) {
                if (resolvedSymbol.varScope === symbol_table_1.VarScope.LOCAL) {
                    this.throwError("Variable already defined in local scope: \"".concat(varDecl.name, "\""), node);
                }
                else if (resolvedSymbol.varScope === symbol_table_1.VarScope.GLOBAL &&
                    node.dimType === ast_1.DimType.SHARED &&
                    !((0, types_1.areMatchingSingularTypes)(typeSpec, resolvedSymbol.typeSpec) ||
                        ((0, types_1.isArray)(typeSpec) &&
                            (0, types_1.isArray)(resolvedSymbol.typeSpec) &&
                            (0, types_1.areMatchingSingularTypes)(typeSpec.elementTypeSpec, resolvedSymbol.typeSpec.elementTypeSpec)))) {
                    this.throwError("Variable already defined in global scope: \"".concat(varDecl.name, "\""), node);
                }
                varDecl.symbol = resolvedSymbol;
            }
            else {
                var symbol = void 0;
                switch (node.dimType) {
                    case ast_1.DimType.SHARED:
                        // If this symbol is already defined as a local var at the module level, promote it to
                        // global.
                        var moduleLocalSymbol = (0, symbol_table_1.lookupSymbol)(this.module.localSymbols, varDecl.name);
                        if (moduleLocalSymbol) {
                            symbol = moduleLocalSymbol;
                            this.module.localSymbols.splice(this.module.localSymbols.indexOf(moduleLocalSymbol), 1);
                            symbol.varScope = symbol_table_1.VarScope.GLOBAL;
                        }
                        else {
                            symbol = {
                                name: varDecl.name,
                                varType: symbol_table_1.VarType.VAR,
                                typeSpec: typeSpec,
                                varScope: symbol_table_1.VarScope.GLOBAL,
                            };
                        }
                        this.module.globalSymbols.push(symbol);
                        break;
                    case ast_1.DimType.LOCAL:
                        symbol = this.createLocalVarSymbol({
                            name: varDecl.name,
                            typeSpec: typeSpec,
                        });
                        this.addLocalSymbol(symbol);
                        break;
                    case ast_1.DimType.STATIC:
                        symbol = {
                            name: varDecl.name,
                            varType: symbol_table_1.VarType.STATIC_VAR,
                            typeSpec: typeSpec,
                            varScope: symbol_table_1.VarScope.LOCAL,
                        };
                        this.addLocalSymbol(symbol);
                        break;
                    default:
                        this.throwError("Unknown DimType: ".concat(JSON.stringify(node.dimType)), node);
                }
                varDecl.symbol = symbol;
            }
        }
    };
    SemanticAnalyzer.prototype.visitAssignStmt = function (node) {
        this.accept(node.targetExpr);
        this.accept(node.valueExpr);
        var targetTypeSpec = node.targetExpr.typeSpec;
        var valueTypeSpec = node.valueExpr.typeSpec;
        if (!(0, types_1.areMatchingSingularTypes)(targetTypeSpec, valueTypeSpec)) {
            this.throwError("Cannot assign ".concat((0, types_1.typeSpecName)(valueTypeSpec), " value ") +
                "to ".concat((0, types_1.typeSpecName)(targetTypeSpec), " variable"), node);
        }
    };
    SemanticAnalyzer.prototype.visitConstStmt = function (node) {
        for (var _i = 0, _a = node.constDefs; _i < _a.length; _i++) {
            var constDef = _a[_i];
            this.accept(constDef.valueExpr);
            var resolvedSymbol = this.lookupSymbol(constDef.name);
            if (resolvedSymbol) {
                if (resolvedSymbol.varScope === symbol_table_1.VarScope.LOCAL) {
                    this.throwError("Constant already defined in local scope: \"".concat(constDef.name, "\""), node);
                }
                else if (resolvedSymbol.varScope === symbol_table_1.VarScope.GLOBAL &&
                    !this.currentProc) {
                    this.throwError("Constant already defined in global scope: \"".concat(constDef.name, "\""), node);
                }
            }
            var symbolProps = {
                name: constDef.name,
                varType: symbol_table_1.VarType.CONST,
                typeSpec: constDef.valueExpr.typeSpec,
            };
            if (this.currentProc) {
                var symbol = __assign(__assign({}, symbolProps), { varScope: symbol_table_1.VarScope.LOCAL });
                this.addLocalSymbol(symbol);
                constDef.symbol = symbol;
            }
            else {
                var symbol = __assign(__assign({}, symbolProps), { varScope: symbol_table_1.VarScope.GLOBAL });
                this.module.globalSymbols.push(symbol);
                constDef.symbol = symbol;
            }
        }
    };
    SemanticAnalyzer.prototype.visitGotoStmt = function (node) {
        var _a;
        node.destLabel = this.lookupLabelOrThrow(node, (_a = this.currentProc) !== null && _a !== void 0 ? _a : this.module, node.destLabel);
    };
    SemanticAnalyzer.prototype.requireNumericExpr = function () {
        var exprs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            exprs[_i] = arguments[_i];
        }
        for (var _a = 0, exprs_1 = exprs; _a < exprs_1.length; _a++) {
            var expr = exprs_1[_a];
            this.accept(expr);
            if (!(0, types_1.isNumeric)(expr.typeSpec)) {
                this.throwError("Expected numeric expression (got ".concat((0, types_1.typeSpecName)(expr.typeSpec), ")"), expr);
            }
        }
    };
    SemanticAnalyzer.prototype.requireElementaryTypeExpr = function () {
        var exprs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            exprs[_i] = arguments[_i];
        }
        for (var _a = 0, exprs_2 = exprs; _a < exprs_2.length; _a++) {
            var expr = exprs_2[_a];
            this.accept(expr);
            if (!(0, types_1.isElementaryType)(expr.typeSpec)) {
                this.throwError("Expected elementary type expression instead of ".concat(expr.typeSpec.type), expr);
            }
        }
    };
    SemanticAnalyzer.prototype.visitIfStmt = function (node) {
        for (var _i = 0, _a = node.ifBranches; _i < _a.length; _i++) {
            var _b = _a[_i], condExpr = _b.condExpr, stmts = _b.stmts;
            this.requireNumericExpr(condExpr);
            this.acceptAll(stmts);
        }
        if (node.elseBranch) {
            this.acceptAll(node.elseBranch.stmts);
        }
    };
    SemanticAnalyzer.prototype.visitSelectStmt = function (node) {
        this.accept(node.testExpr);
        for (var _i = 0, _a = node.ifBranches; _i < _a.length; _i++) {
            var _b = _a[_i], condExprs = _b.condExprs, stmts = _b.stmts;
            for (var _c = 0, condExprs_1 = condExprs; _c < condExprs_1.length; _c++) {
                var condExpr = condExprs_1[_c];
                var exprs = [];
                switch (condExpr.type) {
                    case ast_1.CaseExprType.VALUE:
                        exprs.push(condExpr.valueExpr);
                        break;
                    case ast_1.CaseExprType.RANGE:
                        exprs.push(condExpr.lowerBoundExpr, condExpr.upperBoundExpr);
                        break;
                    case ast_1.CaseExprType.COMP:
                        exprs.push(condExpr.rightExpr);
                        break;
                    default:
                        this.throwError("Unknown case expression type: ".concat(JSON.stringify(condExpr)), node);
                }
                this.acceptAll(exprs);
                for (var _d = 0, exprs_3 = exprs; _d < exprs_3.length; _d++) {
                    var expr = exprs_3[_d];
                    if (!(0, types_1.areMatchingElementaryTypes)(node.testExpr.typeSpec, expr.typeSpec)) {
                        this.throwError('Case expression type does not match test expression: ' +
                            "expected ".concat((0, types_1.typeSpecName)(node.testExpr.typeSpec), ", ") +
                            "got ".concat((0, types_1.typeSpecName)(expr.typeSpec)), expr);
                    }
                }
            }
            this.acceptAll(stmts);
        }
        if (node.elseBranch) {
            this.acceptAll(node.elseBranch.stmts);
        }
    };
    SemanticAnalyzer.prototype.visitCondLoopStmt = function (node) {
        this.requireNumericExpr(node.condExpr);
        this.acceptAll(node.stmts);
    };
    SemanticAnalyzer.prototype.visitUncondLoopStmt = function (node) {
        this.acceptAll(node.stmts);
    };
    SemanticAnalyzer.prototype.visitExitLoopStmt = function (node) { };
    SemanticAnalyzer.prototype.visitForStmt = function (node) {
        this.requireNumericExpr.apply(this, __spreadArray([node.counterExpr,
            node.startExpr,
            node.endExpr], (node.stepExpr ? [node.stepExpr] : []), false));
    };
    SemanticAnalyzer.prototype.visitNextStmt = function (node) {
        this.requireNumericExpr.apply(this, node.counterExprs);
    };
    SemanticAnalyzer.prototype.visitExitForStmt = function (node) { };
    SemanticAnalyzer.prototype.visitGosubStmt = function (node) {
        var _a;
        node.destLabel = this.lookupLabelOrThrow(node, (_a = this.currentProc) !== null && _a !== void 0 ? _a : this.module, node.destLabel);
    };
    SemanticAnalyzer.prototype.visitReturnStmt = function (node) {
        var _a;
        if (node.destLabel) {
            node.destLabel = this.lookupLabelOrThrow(node, (_a = this.currentProc) !== null && _a !== void 0 ? _a : this.module, node.destLabel);
        }
    };
    SemanticAnalyzer.prototype.visitCallStmt = function (node) {
        this.acceptAll(node.argExprs);
        var resolvedSub = this.lookupSub(node.name, node.argExprs.map(function (_a) {
            var typeSpec = _a.typeSpec;
            return typeSpec;
        }));
        if (!resolvedSub ||
            (resolvedSub.defType === types_1.ProcDefType.MODULE &&
                resolvedSub.proc.type !== types_1.ProcType.SUB)) {
            this.throwError("".concat((0, types_1.procTypeName)(types_1.ProcType.SUB), " not found: \"").concat(node.name, "\""), node);
        }
        this.visitProcCall(resolvedSub, node);
    };
    SemanticAnalyzer.prototype.visitExitProcStmt = function (node) {
        if (!this.currentProc || this.currentProc.type !== node.procType) {
            this.throwError("EXIT statement must be placed inside a ".concat((0, types_1.procTypeName)(node.procType)), node);
        }
    };
    SemanticAnalyzer.prototype.visitEndStmt = function (node) { };
    SemanticAnalyzer.prototype.visitSwapStmt = function (node) {
        this.accept(node.leftExpr);
        this.accept(node.rightExpr);
        if (!(0, types_1.areMatchingSingularTypes)(node.leftExpr.typeSpec, node.rightExpr.typeSpec)) {
            this.throwError("Cannot swap a ".concat((0, types_1.typeSpecName)(node.leftExpr.typeSpec), " ") +
                "variable with a ".concat((0, types_1.typeSpecName)(node.rightExpr.typeSpec), " variable"), node);
        }
    };
    SemanticAnalyzer.prototype.visitPrintStmt = function (node) {
        if (node.formatExpr) {
            this.accept(node.formatExpr);
            if (!(0, types_1.isString)(node.formatExpr.typeSpec)) {
                this.throwError('Expected format expression to be a string, ' +
                    "got ".concat((0, types_1.typeSpecName)(node.formatExpr.typeSpec)), node.formatExpr);
            }
        }
        for (var _i = 0, _a = node.args; _i < _a.length; _i++) {
            var arg = _a[_i];
            if (typeof arg === 'string') {
                continue;
            }
            this.requireElementaryTypeExpr(arg);
        }
    };
    SemanticAnalyzer.prototype.visitInputStmt = function (node) {
        switch (node.inputType) {
            case ast_1.InputType.TOKENIZED:
                this.requireElementaryTypeExpr.apply(this, node.targetExprs);
                break;
            case ast_1.InputType.LINE:
                if (node.targetExprs.length !== 1) {
                    this.throwError('Expected single destination in LINE INPUT statement, ' +
                        "got ".concat(node.targetExprs.length), node);
                }
                this.accept(node.targetExprs[0]);
                if (!(0, types_1.isString)(node.targetExprs[0].typeSpec)) {
                    this.throwError("Expected string destination in LINE INPUT staement, got ".concat(node.targetExprs[0].typeSpec.type), node.targetExprs[0]);
                }
                break;
            default:
                this.throwError("Unknown input type: ".concat(JSON.stringify(node.inputType)), node);
        }
    };
    SemanticAnalyzer.prototype.visitDefTypeStmt = function (node) {
        if (this.currentProc) {
            this.throwError("DEFtype statements are only allowed at module level", node);
        }
        var _loop_1 = function (range) {
            var _b = [
                range.minPrefix.toLowerCase(),
                range.maxPrefix.toLowerCase(),
            ], minPrefix = _b[0], maxPrefix = _b[1];
            if (![minPrefix, maxPrefix].every(function (p) { return p.match(/^[a-z]$/) || minPrefix > maxPrefix; })) {
                this_1.throwError("Invalid DEFtype range", range);
            }
            for (var c = minPrefix.charCodeAt(0); c <= maxPrefix.charCodeAt(0); ++c) {
                this_1.defTypeMap[String.fromCharCode(c)] = node.typeSpec;
            }
        };
        var this_1 = this;
        for (var _i = 0, _a = node.ranges; _i < _a.length; _i++) {
            var range = _a[_i];
            _loop_1(range);
        }
    };
    SemanticAnalyzer.prototype.visitDataStmt = function (node) {
        if (this.currentProc) {
            this.throwError("DATA statement must be at module level", node);
        }
    };
    SemanticAnalyzer.prototype.visitReadStmt = function (node) {
        if (node.targetExprs.length === 0) {
            this.throwError('Empty READ statement', node);
        }
        for (var _i = 0, _a = node.targetExprs; _i < _a.length; _i++) {
            var targetExpr = _a[_i];
            this.accept(targetExpr);
            if (!(0, types_1.isElementaryType)(targetExpr.typeSpec)) {
                this.throwError('Expected elementary type variable in READ statement ' +
                    "(got ".concat((0, types_1.typeSpecName)(targetExpr.typeSpec), ")"), targetExpr);
            }
        }
    };
    SemanticAnalyzer.prototype.visitRestoreStmt = function (node) {
        if (node.destLabel) {
            node.destLabel = this.lookupLabelOrThrow(node, this.module, node.destLabel);
        }
    };
    SemanticAnalyzer.prototype.visitLiteralExpr = function (node) {
        if (typeof node.value === 'string') {
            node.typeSpec = (0, types_1.stringSpec)();
        }
        else if (typeof node.value === 'number') {
            // TODO
            node.typeSpec = (0, types_1.singleSpec)();
        }
        else {
            this.throwError("Unknown literal expression value type: ".concat(typeof node.value), node);
        }
    };
    SemanticAnalyzer.prototype.visitVarRefExpr = function (node) {
        var _a;
        var _b;
        var symbol = this.lookupSymbol(node.name);
        if (!symbol) {
            // VarRef may actually be a function invocation without args.
            var proc = this.lookupFn(node.name, []);
            if (proc) {
                var fnCallExpr = {
                    type: ast_1.ExprType.FN_CALL,
                    name: node.name,
                    argExprs: [],
                    loc: node.loc,
                };
                this.accept(fnCallExpr);
                Object.assign(node, fnCallExpr);
                return;
            }
            symbol = this.createLocalVarSymbol({
                name: node.name,
                // If this VarRefExpr is nested inside a SubscriptExpr, visitSubScriptExpr() will set the
                // typeSpec for this VarRefExpr based on the index expressions. So we should respect that
                // here.
                typeSpec: (_b = node.typeSpec) !== null && _b !== void 0 ? _b : this.getDefaultTypeSpecFromName(node.name),
            });
            this.addLocalSymbol(symbol);
        }
        _a = [symbol.typeSpec, symbol], node.typeSpec = _a[0], node.symbol = _a[1];
    };
    SemanticAnalyzer.prototype.visitFnCallExpr = function (node) {
        this.acceptAll(node.argExprs);
        // Try resolving the name as a function.
        var resolvedFn = this.lookupFn(node.name, node.argExprs.map(function (_a) {
            var typeSpec = _a.typeSpec;
            return typeSpec;
        }));
        if (resolvedFn) {
            if (resolvedFn.defType === types_1.ProcDefType.MODULE &&
                !(0, ast_1.isFnProcOrDefFnProc)(resolvedFn.proc)) {
                this.throwError("A ".concat((0, types_1.procTypeName)(resolvedFn.proc.type), " cannot be used in an expression: \"").concat(node.name, "\""), node);
            }
            this.visitProcCall(resolvedFn, node);
            node.typeSpec = resolvedFn.returnTypeSpec;
            return;
        }
        // Try resolving as a subscript expression.
        var subscriptExpr = {
            type: ast_1.ExprType.SUBSCRIPT,
            arrayExpr: {
                type: ast_1.ExprType.VAR_REF,
                name: node.name,
                loc: node.loc,
            },
            indexExprs: node.argExprs,
            loc: node.loc,
        };
        this.accept(subscriptExpr);
        Object.assign(node, subscriptExpr);
    };
    SemanticAnalyzer.prototype.visitBinaryOpExpr = function (node) {
        var _this = this;
        this.accept(node.leftExpr);
        this.accept(node.rightExpr);
        var leftTypeSpec = node.leftExpr.typeSpec;
        var rightTypeSpec = node.rightExpr.typeSpec;
        var errorMessage = "Incompatible types for ".concat(node.op, " operator: ") +
            "".concat((0, types_1.typeSpecName)(leftTypeSpec), " and ").concat((0, types_1.typeSpecName)(rightTypeSpec));
        var requireNumericOperands = function () {
            if (!((0, types_1.isNumeric)(leftTypeSpec) && (0, types_1.isNumeric)(rightTypeSpec))) {
                _this.throwError(errorMessage, node);
            }
        };
        var useCoercedNumericType = function () {
            node.typeSpec = _this.coerceNumericTypes(leftTypeSpec, rightTypeSpec);
        };
        switch (node.op) {
            case ast_1.BinaryOp.ADD:
                if ((0, types_1.isString)(leftTypeSpec) && (0, types_1.isString)(rightTypeSpec)) {
                    node.typeSpec = (0, types_1.stringSpec)();
                }
                else {
                    requireNumericOperands();
                    useCoercedNumericType();
                }
                break;
            case ast_1.BinaryOp.SUB:
            case ast_1.BinaryOp.MUL:
            case ast_1.BinaryOp.EXP:
            case ast_1.BinaryOp.INTDIV:
            case ast_1.BinaryOp.MOD:
                requireNumericOperands();
                useCoercedNumericType();
                break;
            case ast_1.BinaryOp.DIV:
                requireNumericOperands();
                node.typeSpec = this.coerceNumericTypes(leftTypeSpec, rightTypeSpec, (0, types_1.singleSpec)());
                break;
            case ast_1.BinaryOp.AND:
            case ast_1.BinaryOp.OR:
                requireNumericOperands();
                node.typeSpec = (0, types_1.integerSpec)();
                break;
            case ast_1.BinaryOp.EQ:
            case ast_1.BinaryOp.NE:
            case ast_1.BinaryOp.GT:
            case ast_1.BinaryOp.GTE:
            case ast_1.BinaryOp.LT:
            case ast_1.BinaryOp.LTE:
                if (!(0, types_1.areMatchingElementaryTypes)(leftTypeSpec, rightTypeSpec)) {
                    this.throwError(errorMessage, node);
                }
                node.typeSpec = (0, types_1.integerSpec)();
                break;
            default:
                this.throwError("Unknown operator ".concat(node.op), node);
        }
    };
    SemanticAnalyzer.prototype.visitUnaryOpExpr = function (node) {
        this.accept(node.rightExpr);
        var rightTypeSpec = node.rightExpr.typeSpec;
        switch (node.op) {
            case ast_1.UnaryOp.NEG:
                this.requireNumericExpr(node.rightExpr);
                node.typeSpec = rightTypeSpec;
                break;
            case ast_1.UnaryOp.NOT:
                this.requireNumericExpr(node.rightExpr);
                node.typeSpec = (0, types_1.integerSpec)();
                break;
            case ast_1.UnaryOp.PARENS:
                node.typeSpec = rightTypeSpec;
                break;
            default:
                this.throwError("Unknown operator ".concat(node.op), node);
        }
    };
    SemanticAnalyzer.prototype.visitSubscriptExpr = function (node) {
        // Hack: treat empty parens (used to pass array to procedures) as reference to the array
        // variable itself.
        if (node.indexExprs.length === 0) {
            this.accept(node.arrayExpr);
            Object.assign(node, node.arrayExpr);
            return;
        }
        this.acceptAll(node.indexExprs);
        for (var i = 0; i < node.indexExprs.length; ++i) {
            var indexExpr = node.indexExprs[i];
            if (!(0, types_1.isNumeric)(indexExpr.typeSpec)) {
                this.throwError("Array index #".concat(i + 1, " should be numeric instead of ").concat(indexExpr.typeSpec.type), indexExpr);
            }
        }
        // Add typeSpec hint for arrayExpr. This will be used to create the underlying variable symbol
        // if not already found.
        node.arrayExpr.typeSpec = (0, types_1.arraySpec)(this.getDefaultTypeSpecFromName(node.arrayExpr.name), node.indexExprs.map(function () { return DEFAULT_DIMENSION_SPEC; }));
        this.accept(node.arrayExpr);
        var arrayTypeSpec = node.arrayExpr.typeSpec;
        if (!(0, types_1.isArray)(arrayTypeSpec)) {
            this.throwError('Expected array variable in subscript expression, ' +
                "got ".concat((0, types_1.typeSpecName)(node.arrayExpr.typeSpec)), node.arrayExpr);
        }
        if (arrayTypeSpec.dimensionSpecs.length && // Dimension is unknown for array arguments.
            arrayTypeSpec.dimensionSpecs.length !== node.indexExprs.length) {
            this.throwError('Wrong number of index expressions: ' +
                "expected ".concat(arrayTypeSpec.dimensionSpecs.length, ", ") +
                "got ".concat(node.indexExprs.length), node);
        }
        node.typeSpec = node.arrayExpr.typeSpec.elementTypeSpec;
    };
    SemanticAnalyzer.prototype.visitMemberExpr = function (node) {
        this.accept(node.udtExpr);
        var udtTypeSpec = node.udtExpr.typeSpec;
        if (!(0, types_1.isUdt)(udtTypeSpec)) {
            this.throwError("Expected user-defined type in member expression, got ".concat((0, types_1.typeSpecName)(udtTypeSpec)), node);
        }
        var fieldSpec = (0, symbol_table_1.lookupSymbol)(udtTypeSpec.fieldSpecs, node.fieldName);
        if (!fieldSpec) {
            this.throwError("Field \"".concat(node.fieldName, "\" does not exist ") +
                "on type \"".concat((0, types_1.typeSpecName)(udtTypeSpec), "\""), node);
        }
        node.fieldName = fieldSpec.name; // Normalize case
        node.typeSpec = fieldSpec.typeSpec;
    };
    SemanticAnalyzer.prototype.visitProcCall = function (resolvedProc, node) {
        node.argTypeProps = [];
        var paramTypeSpecs;
        switch (resolvedProc.defType) {
            case types_1.ProcDefType.BUILTIN:
                paramTypeSpecs = resolvedProc.builtinProc.paramTypeSpecs;
                break;
            case types_1.ProcDefType.MODULE:
                paramTypeSpecs = resolvedProc.proc.paramSymbols.map(function (_a) {
                    var typeSpec = _a.typeSpec;
                    return typeSpec;
                });
                break;
            default:
                this.throwError("Unknown FnDefType: ".concat(JSON.stringify(resolvedProc)), node);
        }
        node.procDefType = resolvedProc.defType;
        if (paramTypeSpecs.length !== node.argExprs.length) {
            this.throwError("Incorrect number of arguments to \"".concat(node.name, "\": ") +
                "expected ".concat(paramTypeSpecs.length, ", got ").concat(node.argExprs.length), node);
        }
        for (var i = 0; i < node.argExprs.length; ++i) {
            var paramTypeSpec = paramTypeSpecs[i];
            var argExpr = node.argExprs[i];
            var argTypeSpec = argExpr.typeSpec;
            var shouldPassByRef = (0, ast_1.isLhsExpr)(argExpr) &&
                // Constants cannot be allowed to be modified by the proc, so must use pass-by-value.
                !(argExpr.type === ast_1.ExprType.VAR_REF &&
                    argExpr.symbol.varType === symbol_table_1.VarType.CONST) &&
                // For built-in procs, we always pass by value in order to take advantage of automatic type
                // casting (e.g. single -> integer).
                resolvedProc.defType !== types_1.ProcDefType.BUILTIN;
            var isCompatible = void 0;
            if (shouldPassByRef) {
                // If argument is an LHS expression, the types must match exactly as it may be assigned to
                // from inside the proc.
                isCompatible =
                    lodash_1.default.isEqual(paramTypeSpec, argTypeSpec) ||
                        ((0, types_1.isArray)(paramTypeSpec) &&
                            (0, types_1.isArray)(argTypeSpec) &&
                            lodash_1.default.isEqual(paramTypeSpec.elementTypeSpec, argTypeSpec.elementTypeSpec));
            }
            else {
                // If argument is not an LHS expression, the types just need to be generally compatible.
                isCompatible =
                    (0, types_1.areMatchingSingularTypes)(paramTypeSpec, argTypeSpec) ||
                        ((0, types_1.isArray)(paramTypeSpec) &&
                            (0, types_1.isArray)(argTypeSpec) &&
                            ((0, types_1.areMatchingSingularTypes)(paramTypeSpec.elementTypeSpec, argTypeSpec.elementTypeSpec) ||
                                // Allow builtins to accept arrays of any element type.
                                resolvedProc.defType === types_1.ProcDefType.BUILTIN));
            }
            if (!isCompatible) {
                this.throwError("Incompatible argument ".concat(i + 1, " to function \"").concat(node.name, "\": ") +
                    "expected ".concat((0, types_1.typeSpecName)(paramTypeSpec), ", ") +
                    "got ".concat((0, types_1.typeSpecName)(argTypeSpec)), node);
            }
            node.argTypeProps.push({ paramTypeSpec: paramTypeSpec, shouldPassByRef: shouldPassByRef });
        }
    };
    /** Computes the output numeric type after an arithmetic operation. */
    SemanticAnalyzer.prototype.coerceNumericTypes = function () {
        var typeSpecs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            typeSpecs[_i] = arguments[_i];
        }
        var RULES = [
            { operands: [(0, types_1.integerSpec)(), (0, types_1.integerSpec)()], result: (0, types_1.integerSpec)() },
            { operands: [(0, types_1.integerSpec)(), (0, types_1.longSpec)()], result: (0, types_1.longSpec)() },
            { operands: [(0, types_1.integerSpec)(), (0, types_1.singleSpec)()], result: (0, types_1.singleSpec)() },
            { operands: [(0, types_1.integerSpec)(), (0, types_1.doubleSpec)()], result: (0, types_1.doubleSpec)() },
            { operands: [(0, types_1.longSpec)(), (0, types_1.integerSpec)()], result: (0, types_1.longSpec)() },
            { operands: [(0, types_1.longSpec)(), (0, types_1.longSpec)()], result: (0, types_1.longSpec)() },
            { operands: [(0, types_1.longSpec)(), (0, types_1.singleSpec)()], result: (0, types_1.singleSpec)() },
            { operands: [(0, types_1.longSpec)(), (0, types_1.doubleSpec)()], result: (0, types_1.doubleSpec)() },
            { operands: [(0, types_1.singleSpec)(), (0, types_1.integerSpec)()], result: (0, types_1.singleSpec)() },
            { operands: [(0, types_1.singleSpec)(), (0, types_1.longSpec)()], result: (0, types_1.singleSpec)() },
            { operands: [(0, types_1.singleSpec)(), (0, types_1.singleSpec)()], result: (0, types_1.singleSpec)() },
            { operands: [(0, types_1.singleSpec)(), (0, types_1.doubleSpec)()], result: (0, types_1.doubleSpec)() },
            { operands: [(0, types_1.doubleSpec)(), (0, types_1.integerSpec)()], result: (0, types_1.doubleSpec)() },
            { operands: [(0, types_1.doubleSpec)(), (0, types_1.longSpec)()], result: (0, types_1.doubleSpec)() },
            { operands: [(0, types_1.doubleSpec)(), (0, types_1.singleSpec)()], result: (0, types_1.doubleSpec)() },
            { operands: [(0, types_1.doubleSpec)(), (0, types_1.doubleSpec)()], result: (0, types_1.doubleSpec)() },
        ];
        if (typeSpecs.length === 0) {
            throw new Error('Missing arguments');
        }
        if (!typeSpecs.every(types_1.isNumeric)) {
            throw new Error("Expected numeric types: ".concat(JSON.stringify(typeSpecs)));
        }
        var resultTypeSpec = typeSpecs[0];
        var _loop_2 = function (i) {
            var matchingRule = RULES.find(function (_a) {
                var _b = _a.operands, typeSpec1 = _b[0], typeSpec2 = _b[1];
                return lodash_1.default.isEqual(typeSpec1, resultTypeSpec) &&
                    lodash_1.default.isEqual(typeSpec2, typeSpecs[i]);
            });
            if (matchingRule) {
                resultTypeSpec = matchingRule.result;
            }
            else {
                throw new Error('Unknown numeric type combination: ' +
                    "".concat((0, types_1.typeSpecName)(resultTypeSpec), " and ").concat((0, types_1.typeSpecName)(typeSpecs[i])));
            }
        };
        for (var i = 1; i < typeSpecs.length; ++i) {
            _loop_2(i);
        }
        return resultTypeSpec;
    };
    SemanticAnalyzer.prototype.getLocalSymbols = function () {
        // TODO: Handle multiline DEF FN procs.
        return this.currentProc
            ? this.currentProc.localSymbols
            : this.module.localSymbols;
    };
    SemanticAnalyzer.prototype.lookupSymbol = function (name) {
        var _a, _b;
        var symbol = null;
        if (this.currentProc) {
            symbol = (0, symbol_table_1.lookupSymbol)(this.currentProc.paramSymbols, name);
        }
        return ((_b = (_a = symbol !== null && symbol !== void 0 ? symbol : (0, symbol_table_1.lookupSymbol)(this.getLocalSymbols(), name)) !== null && _a !== void 0 ? _a : (0, symbol_table_1.lookupSymbol)(this.module.globalSymbols, name)) !== null && _b !== void 0 ? _b : null);
    };
    SemanticAnalyzer.prototype.createLocalVarSymbol = function (args) {
        return __assign(__assign({}, args), { varType: this.currentProc && this.currentProc.isDefaultStatic
                ? symbol_table_1.VarType.STATIC_VAR
                : symbol_table_1.VarType.VAR, varScope: symbol_table_1.VarScope.LOCAL });
    };
    SemanticAnalyzer.prototype.addLocalSymbol = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return (_a = this.getLocalSymbols()).push.apply(_a, args);
    };
    SemanticAnalyzer.prototype.getTypeSpecForVarDeclOrParam = function (node) {
        var name = node.name, typeExpr = node.typeExpr;
        switch (typeExpr.type) {
            case ast_1.DataTypeExprType.ELEMENTARY:
                if (!typeExpr.typeSpec) {
                    typeExpr.typeSpec = this.getDefaultTypeSpecFromName(name);
                }
                return typeExpr.typeSpec;
            case ast_1.DataTypeExprType.ARRAY:
                for (var _i = 0, _a = typeExpr.dimensionSpecExprs; _i < _a.length; _i++) {
                    var _b = _a[_i], minIdxExpr = _b.minIdxExpr, maxIdxExpr = _b.maxIdxExpr;
                    var idxExprs = __spreadArray(__spreadArray([], (minIdxExpr ? [minIdxExpr] : []), true), [maxIdxExpr], false);
                    this.acceptAll(idxExprs);
                    for (var _c = 0, idxExprs_1 = idxExprs; _c < idxExprs_1.length; _c++) {
                        var idxExpr = idxExprs_1[_c];
                        if (!(0, types_1.isNumeric)(idxExpr.typeSpec)) {
                            this.throwError("Array dimension size must be numeric, not ".concat(idxExpr.typeSpec.type), idxExpr);
                        }
                    }
                }
                if (typeExpr.elementTypeExpr) {
                    if (!(0, ast_1.isSingularTypeExpr)(typeExpr.elementTypeExpr)) {
                        this.throwError("Invalid array element type: ".concat(JSON.stringify(typeExpr.elementTypeExpr)), typeExpr.elementTypeExpr);
                    }
                }
                else {
                    typeExpr.elementTypeExpr = {
                        type: ast_1.DataTypeExprType.ELEMENTARY,
                        typeSpec: this.getDefaultTypeSpecFromName(name),
                        loc: typeExpr.loc,
                    };
                }
                return {
                    type: types_1.DataType.ARRAY,
                    elementTypeSpec: this.getTypeSpecForVarDeclOrParam(__assign(__assign({}, node), { typeExpr: typeExpr.elementTypeExpr })),
                    dimensionSpecs: typeExpr.dimensionSpecExprs.map(function () { return [0, 0]; }),
                };
            case ast_1.DataTypeExprType.UDT:
                var udt = this.lookupUdtOrThrow(typeExpr, typeExpr.name);
                return udt.typeSpec;
            default:
                this.throwError("Unknown DataTypeExpr type: ".concat(JSON.stringify(typeExpr)), node);
        }
    };
    SemanticAnalyzer.prototype.getDefaultTypeSpecFromName = function (name) {
        var _a;
        return ((_a = TYPE_SUFFIX_MAP[name[name.length - 1]]) !== null && _a !== void 0 ? _a : this.defTypeMap[name[0].toLowerCase()]);
    };
    SemanticAnalyzer.prototype.lookupFn = function (name, argTypeSpecs) {
        var proc = (0, symbol_table_1.lookupSymbol)(this.module.procs, name);
        if (proc) {
            return {
                defType: types_1.ProcDefType.MODULE,
                proc: proc,
                returnTypeSpec: (0, ast_1.isFnProcOrDefFnProc)(proc) ? proc.returnTypeSpec : null,
            };
        }
        var builtinProc = (0, builtins_1.lookupBuiltin)(builtins_1.BUILTIN_FNS, name, argTypeSpecs, {
            // This allows us to throw a more useful error message in visitProcCall().
            shouldReturnIfArgTypeMismatch: true,
        });
        if (builtinProc) {
            return {
                defType: types_1.ProcDefType.BUILTIN,
                builtinProc: builtinProc,
                returnTypeSpec: builtinProc.returnTypeSpec,
            };
        }
        return null;
    };
    SemanticAnalyzer.prototype.lookupSub = function (name, argTypeSpecs) {
        var proc = (0, symbol_table_1.lookupSymbol)(this.module.procs, name);
        if (proc) {
            return {
                defType: types_1.ProcDefType.MODULE,
                proc: proc,
            };
        }
        var builtinProc = (0, builtins_1.lookupBuiltin)(builtins_1.BUILTIN_SUBS, name, argTypeSpecs, {
            // This allows us to throw a more useful error message in visitProcCall().
            shouldReturnIfArgTypeMismatch: true,
        });
        if (builtinProc) {
            return {
                defType: types_1.ProcDefType.BUILTIN,
                builtinProc: builtinProc,
            };
        }
        return null;
    };
    SemanticAnalyzer.prototype.lookupUdtOrThrow = function (node, name) {
        var udt = (0, symbol_table_1.lookupSymbol)(this.module.udts, name);
        if (!udt) {
            this.throwError("Type not found: \"".concat(name, "\""), node);
        }
        return udt;
    };
    SemanticAnalyzer.prototype.setUpDefTypeMap = function () {
        for (var c = 'a'.charCodeAt(0); c <= 'z'.charCodeAt(0); ++c) {
            this.defTypeMap[String.fromCharCode(c)] = (0, types_1.singleSpec)();
        }
        this.acceptAll(lodash_1.default.filter(this.module.stmts, ['type', ast_1.StmtType.DEF_TYPE]));
    };
    SemanticAnalyzer.prototype.lookupLabelOrThrow = function (node, context, label) {
        var foundLabel = context.labels.find(function (existingLabel) { return existingLabel.toLowerCase() === label.toLowerCase(); });
        if (!foundLabel) {
            this.throwError("Label not found: \"".concat(label, "\""), node);
        }
        return foundLabel;
    };
    return SemanticAnalyzer;
}(ast_1.AstVisitor));
exports.SemanticAnalyzer = SemanticAnalyzer;
function runSemanticAnalysis(module, opts) {
    if (opts === void 0) { opts = {}; }
    return new SemanticAnalyzer(module, opts).run();
}
exports.default = runSemanticAnalysis;
