import { AssignStmt, AstVisitor, BinaryOpExpr, CallStmt, CondLoopStmt, ConstStmt, DataStmt, DefTypeStmt, DimStmt, EndStmt, ExitForStmt, ExitLoopStmt, ExitProcStmt, FnCallExpr, ForStmt, GosubStmt, GotoStmt, IfStmt, InputStmt, LabelStmt, LiteralExpr, MemberExpr, Module, NextStmt, PrintStmt, Proc, ReadStmt, RestoreStmt, ReturnStmt, SelectStmt, SubscriptExpr, SwapStmt, Udt, UnaryOpExpr, UncondLoopStmt, VarRefExpr } from '../lib/ast';
export interface SemanticAnalyzerOpts {
    sourceFileName?: string;
}
/** Semantic analysis pass.
 *
 * Main tasks:
 *
 * - Type analysis for symbols, expressions and statements
 * - Build symbol table and resolve references
 */
export declare class SemanticAnalyzer extends AstVisitor<void> {
    private readonly module;
    constructor(module: Module, { sourceFileName }?: SemanticAnalyzerOpts);
    run(): void;
    visitModule(module: Module): void;
    private preprocessProc;
    private getLabels;
    /** Stack of UDTs being resolved. Used to detect cycles. */
    private udtStack;
    /** Resolve UDT type spec using depth first search. */
    visitUdt(udt: Udt): void;
    visitProc(node: Proc): void;
    visitLabelStmt(node: LabelStmt): void;
    visitDimStmt(node: DimStmt): void;
    visitAssignStmt(node: AssignStmt): void;
    visitConstStmt(node: ConstStmt): void;
    visitGotoStmt(node: GotoStmt): void;
    private requireNumericExpr;
    private requireElementaryTypeExpr;
    visitIfStmt(node: IfStmt): void;
    visitSelectStmt(node: SelectStmt): void;
    visitCondLoopStmt(node: CondLoopStmt): void;
    visitUncondLoopStmt(node: UncondLoopStmt): void;
    visitExitLoopStmt(node: ExitLoopStmt): void;
    visitForStmt(node: ForStmt): void;
    visitNextStmt(node: NextStmt): void;
    visitExitForStmt(node: ExitForStmt): void;
    visitGosubStmt(node: GosubStmt): void;
    visitReturnStmt(node: ReturnStmt): void;
    visitCallStmt(node: CallStmt): void;
    visitExitProcStmt(node: ExitProcStmt): void;
    visitEndStmt(node: EndStmt): void;
    visitSwapStmt(node: SwapStmt): void;
    visitPrintStmt(node: PrintStmt): void;
    visitInputStmt(node: InputStmt): void;
    visitDefTypeStmt(node: DefTypeStmt): void;
    visitDataStmt(node: DataStmt): void;
    visitReadStmt(node: ReadStmt): void;
    visitRestoreStmt(node: RestoreStmt): void;
    visitLiteralExpr(node: LiteralExpr): void;
    visitVarRefExpr(node: VarRefExpr): void;
    visitFnCallExpr(node: FnCallExpr): void;
    visitBinaryOpExpr(node: BinaryOpExpr): void;
    visitUnaryOpExpr(node: UnaryOpExpr): void;
    visitSubscriptExpr(node: SubscriptExpr): void;
    visitMemberExpr(node: MemberExpr): void;
    private visitProcCall;
    /** Computes the output numeric type after an arithmetic operation. */
    private coerceNumericTypes;
    private getLocalSymbols;
    private lookupSymbol;
    private createLocalVarSymbol;
    private addLocalSymbol;
    private getTypeSpecForVarDeclOrParam;
    private getDefaultTypeSpecFromName;
    private lookupFn;
    private lookupSub;
    private lookupUdtOrThrow;
    private setUpDefTypeMap;
    private lookupLabelOrThrow;
    /** The current proc being visited, or null if currently visiting module-level nodes. */
    private currentProc;
    /** Default type based on first letter of identifier. */
    private defTypeMap;
}
export default function runSemanticAnalysis(module: Module, opts?: SemanticAnalyzerOpts): void;
