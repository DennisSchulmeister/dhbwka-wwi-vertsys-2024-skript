"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.CodeGenerator = void 0;
var lodash_1 = __importDefault(require("lodash"));
var source_map_1 = require("source-map");
var ast_1 = require("../lib/ast");
var symbol_table_1 = require("../lib/symbol-table");
var types_1 = require("../lib/types");
var compiled_code_1 = require("../runtime/compiled-code");
// Generated by src/tools/build-runtime-bundle.ts at build time.
var nodeRuntimeBundleCode = require('../runtime/node-runtime-bundle')
    .default;
/** Default indentation per level. */
var DEFAULT_INDENT_WIDTH = 4;
var BINARY_OP_MAP = (_a = {},
    _a[ast_1.BinaryOp.ADD] = '+',
    _a[ast_1.BinaryOp.SUB] = '-',
    _a[ast_1.BinaryOp.MUL] = '*',
    _a[ast_1.BinaryOp.DIV] = '/',
    _a[ast_1.BinaryOp.MOD] = '%',
    _a[ast_1.BinaryOp.AND] = '&&',
    _a[ast_1.BinaryOp.OR] = '||',
    _a[ast_1.BinaryOp.EQ] = '===',
    _a[ast_1.BinaryOp.NE] = '!=',
    _a[ast_1.BinaryOp.GT] = '>',
    _a[ast_1.BinaryOp.GTE] = '>=',
    _a[ast_1.BinaryOp.LT] = '<',
    _a[ast_1.BinaryOp.LTE] = '<=',
    _a);
/** Code generation pass.
 *
 * Depends on semantic analysis info in the AST.
 */
var CodeGenerator = /** @class */ (function (_super) {
    __extends(CodeGenerator, _super);
    function CodeGenerator(module, opts) {
        if (opts === void 0) { opts = {}; }
        var _this = _super.call(this) || this;
        _this.module = module;
        /** Stack of open for loops in current context. */
        _this.openForStmtStates = [];
        /** Stack of open do loops in current context. */
        _this.openLoopStmtStates = [];
        /** Current indentation level. */
        _this.indent = 0;
        /** Current generated label index. */
        _this.nextGeneratedLabelIdx = 1;
        _this.opts = __assign({ sourceFileName: '', indentWidth: DEFAULT_INDENT_WIDTH, enableBundling: false }, opts);
        _this.sourceFileName = _this.opts.sourceFileName;
        return _this;
    }
    CodeGenerator.prototype.run = function () {
        var compiledModuleSourceNode = this.visitModule(this.module);
        return this.bundle(compiledModuleSourceNode).toStringWithSourceMap();
    };
    CodeGenerator.prototype.bundle = function (compiledModuleSourceNode) {
        var sourceNode = new source_map_1.SourceNode();
        if (this.opts.enableBundling) {
            sourceNode.add('#!/usr/bin/env node\n\n');
            sourceNode.add(compiledModuleSourceNode);
            sourceNode.add(nodeRuntimeBundleCode);
        }
        else {
            sourceNode.add(compiledModuleSourceNode);
            sourceNode.add('module.exports = compiledModule;\n');
        }
        return sourceNode;
    };
    CodeGenerator.prototype.visitModule = function (module) {
        this.indent = 0;
        var chunks = [];
        chunks.push(this.lines('const compiledModule = {', +1, "sourceFileName: ".concat(JSON.stringify(this.opts.sourceFileName), ","), "localSymbols: ".concat(JSON.stringify(module.localSymbols), ","), "globalSymbols: ".concat(JSON.stringify(module.globalSymbols), ","), ''));
        chunks.push(this.lines('stmts: [', '', +1), this.visitStmts(module.stmts), this.lines(-1, '],', ''));
        chunks.push(this.lines('procs: [', '', +1), this.acceptAll(module.procs), this.lines(-1, '],', ''));
        chunks.push(this.lines(-1, '};', ''));
        return new source_map_1.SourceNode(null, null, this.opts.sourceFileName, lodash_1.default.flattenDeep(chunks));
    };
    CodeGenerator.prototype.visitProc = function (node) {
        var chunks = [];
        chunks.push(this.lines('{', +1, this.generateLoc(node), "type: '".concat(node.type, "',"), "name: '".concat(node.name, "',"), "localSymbols: ".concat(JSON.stringify(node.localSymbols), ","), "paramSymbols: ".concat(JSON.stringify(node.paramSymbols), ","), 'stmts: [', '', +1), this.visitStmts(node.stmts), this.lines(-1, '],', -1, '},', ''));
        return this.createSourceNode.apply(this, __spreadArray([node], chunks, false));
    };
    CodeGenerator.prototype.visitStmts = function (stmts) {
        var origOpenForStmtStatesLength = this.openForStmtStates.length;
        var sourceNodes = this.acceptAll(stmts);
        if (this.openForStmtStates.length > origOpenForStmtStatesLength) {
            this.throwError('FOR statement without corresponding NEXT statement', this.openForStmtStates[this.openForStmtStates.length - 1].forStmt);
        }
        return sourceNodes;
    };
    CodeGenerator.prototype.visitLabelStmt = function (node) {
        return this.createSourceNode(node, this.generateLabelStmt(node, node.label));
    };
    CodeGenerator.prototype.visitDimStmt = function (node) {
        var _this = this;
        var chunks = [];
        for (var _i = 0, _a = node.varDecls; _i < _a.length; _i++) {
            var varDecl = _a[_i];
            var typeExpr = varDecl.typeExpr;
            var typeSpec = varDecl.symbol.typeSpec;
            switch (typeExpr.type) {
                case ast_1.DataTypeExprType.ARRAY:
                    if (!(0, types_1.isArray)(typeSpec)) {
                        this.throwError("Mismatch types: expected array, got ".concat(typeSpec.type), varDecl);
                    }
                    if (node.dimType === ast_1.DimType.SHARED &&
                        typeExpr.dimensionSpecExprs.length === 0) {
                        // SHARED statement only indicating scoping.
                        continue;
                    }
                    chunks.push.apply(chunks, __spreadArray(__spreadArray([this.generateVarRefCode(varDecl, varDecl.symbol),
                        '.init(',
                        JSON.stringify(typeSpec.elementTypeSpec),
                        ', ['], typeExpr.dimensionSpecExprs.map(function (_a) {
                        var minIdxExpr = _a.minIdxExpr, maxIdxExpr = _a.maxIdxExpr;
                        return [
                            '[',
                            minIdxExpr ? _this.accept(minIdxExpr) : '0',
                            ', ',
                            _this.accept(maxIdxExpr),
                            '],',
                        ];
                    }), false), [']); '], false));
                    break;
                default:
                    break;
            }
        }
        if (chunks.length > 0) {
            return this.createStmtSourceNode(node, function () { return chunks; });
        }
        else {
            return new source_map_1.SourceNode();
        }
    };
    CodeGenerator.prototype.visitAssignStmt = function (node) {
        var _this = this;
        return this.createStmtSourceNode(node, function () {
            return [
                _this.accept(node.targetExpr),
                ' = ',
                _this.generateAssignableValueCode(node.valueExpr, node.targetExpr.typeSpec),
                ';',
            ];
        });
    };
    CodeGenerator.prototype.visitConstStmt = function (node) {
        var _this = this;
        return this.createStmtSourceNode(node, function () { return __spreadArray([], lodash_1.default.flatMap(node.constDefs, function (constDef) { return [
            "".concat(_this.generateVarRefCode(constDef, constDef.symbol), " = "),
            _this.accept(constDef.valueExpr),
            '; ',
        ]; }), true); });
    };
    CodeGenerator.prototype.visitGotoStmt = function (node) {
        var _this = this;
        return this.createStmtSourceNode(node, function () {
            return _this.generateGotoCode(node.destLabel);
        });
    };
    CodeGenerator.prototype.visitIfStmt = function (node) {
        var _this = this;
        return this.visitCondStmt(node, this.generateLabel(), function (ifBranch) { return _this.accept(ifBranch.condExpr); });
    };
    CodeGenerator.prototype.visitSelectStmt = function (node) {
        var _this = this;
        var labelPrefix = this.generateLabel();
        var testValue = this.generateTempVarRef("".concat(labelPrefix, "_test"));
        return this.createSourceNode(node, this.createStmtSourceNode(node, function () { return [
            "".concat(testValue, " = "),
            _this.accept(node.testExpr),
            ';',
        ]; }), this.visitCondStmt(node, labelPrefix, function (caseBranch) {
            var chunks = [];
            for (var i = 0; i < caseBranch.condExprs.length; ++i) {
                var condExpr = caseBranch.condExprs[i];
                if (i > 0) {
                    chunks.push(' || ');
                }
                switch (condExpr.type) {
                    case ast_1.CaseExprType.VALUE:
                        chunks.push("".concat(testValue, " === "), _this.accept(condExpr.valueExpr));
                        break;
                    case ast_1.CaseExprType.RANGE:
                        chunks.push("(".concat(testValue, " >= "), _this.accept(condExpr.lowerBoundExpr), " && ".concat(testValue, " <= "), _this.accept(condExpr.upperBoundExpr), ')');
                        break;
                    case ast_1.CaseExprType.COMP:
                        chunks.push("".concat(testValue, " ").concat(BINARY_OP_MAP[condExpr.op], " "), _this.accept(condExpr.rightExpr));
                        break;
                    default:
                        _this.throwError("Unknown case expression type: ".concat(JSON.stringify(condExpr)), node);
                }
            }
            return chunks;
        }), this.createStmtSourceNode(node, function () { return "delete ".concat(testValue, ";"); }));
    };
    CodeGenerator.prototype.visitCondStmt = function (node, labelPrefix, generateCondExprCode) {
        var _this = this;
        // Generate labels for each "elseif" branch, the else branch, and the "end if".
        var branchLabels = [];
        for (var i = 1; i < node.ifBranches.length; ++i) {
            branchLabels.push({
                node: node.ifBranches[i],
                label: "".concat(labelPrefix, "_elif").concat(i),
            });
        }
        if (node.elseBranch && node.elseBranch.stmts.length > 0) {
            branchLabels.push({
                node: node.elseBranch,
                label: "".concat(labelPrefix, "_else"),
            });
        }
        var endIfLabel = "".concat(labelPrefix, "_endif");
        branchLabels.push({ node: null, label: endIfLabel });
        var chunks = [];
        var nextBranchLabelIdx = 0;
        var _loop_1 = function (ifBranch) {
            var _b = branchLabels[nextBranchLabelIdx], nextBranchNode = _b.node, nextBranchLabel = _b.label;
            chunks.push(this_1.createStmtSourceNode(ifBranch, function () {
                return lodash_1.default.flattenDeep([
                    'if (!(',
                    generateCondExprCode(ifBranch),
                    ")) { ".concat(_this.generateGotoCode(nextBranchLabel), " }"),
                ]);
            }));
            ++this_1.indent;
            chunks.push(this_1.visitStmts(ifBranch.stmts));
            if (nextBranchLabelIdx < branchLabels.length - 1) {
                chunks.push(this_1.createStmtSourceNode(ifBranch, function () {
                    return _this.generateGotoCode(endIfLabel);
                }));
            }
            --this_1.indent;
            chunks.push(this_1.generateLabelStmt(nextBranchNode, nextBranchLabel));
            ++nextBranchLabelIdx;
        };
        var this_1 = this;
        // Generate code for "if" and "elseif" branches.
        for (var _i = 0, _a = node.ifBranches; _i < _a.length; _i++) {
            var ifBranch = _a[_i];
            _loop_1(ifBranch);
        }
        // Generate code for "else" branch.
        if (node.elseBranch && node.elseBranch.stmts.length > 0) {
            ++this.indent;
            chunks.push(this.visitStmts(node.elseBranch.stmts));
            --this.indent;
            chunks.push(this.generateLabelStmt(null, endIfLabel));
        }
        return this.createSourceNode.apply(this, __spreadArray([node], chunks, false));
    };
    CodeGenerator.prototype.visitCondLoopStmt = function (node) {
        var _this = this;
        var labelPrefix = this.generateLabel();
        var loopStartLabel = "".concat(labelPrefix, "_loopStart");
        var loopEndLabel = "".concat(labelPrefix, "_loopEnd");
        var cond = node.isCondNegated
            ? [this.accept(node.condExpr)]
            : ['!(', this.accept(node.condExpr), ')'];
        var condStmt = this.createStmtSourceNode(node, function () { return __spreadArray(__spreadArray([
            'if ('
        ], cond, true), [
            ") { ".concat(_this.generateGotoCode(loopEndLabel), " }"),
        ], false); });
        ++this.indent;
        this.openLoopStmtStates.push({
            loopStmt: node,
            endLabel: loopEndLabel,
        });
        var stmts = this.visitStmts(node.stmts);
        this.openLoopStmtStates.pop();
        --this.indent;
        var chunks = [];
        chunks.push(this.generateLabelStmt(node, loopStartLabel));
        switch (node.structure) {
            case ast_1.CondLoopStructure.COND_EXPR_BEFORE_STMTS:
                chunks.push(condStmt, stmts);
                break;
            case ast_1.CondLoopStructure.COND_EXPR_AFTER_STMTS:
                chunks.push(stmts, condStmt);
                break;
            default:
                this.throwError("Unexpected loop structure: ".concat(JSON.stringify(node)), node);
        }
        chunks.push(this.createStmtSourceNode(node, function () {
            return _this.generateGotoCode(loopStartLabel);
        }), this.generateLabelStmt(node, loopEndLabel));
        return this.createSourceNode.apply(this, __spreadArray([node], chunks, false));
    };
    CodeGenerator.prototype.visitUncondLoopStmt = function (node) {
        var _this = this;
        var labelPrefix = this.generateLabel();
        var loopStartLabel = "".concat(labelPrefix, "_loopStart");
        var loopEndLabel = "".concat(labelPrefix, "_loopEnd");
        var chunks = [];
        chunks.push(this.generateLabelStmt(node, loopStartLabel));
        ++this.indent;
        this.openLoopStmtStates.push({
            loopStmt: node,
            endLabel: loopEndLabel,
        });
        chunks.push(this.visitStmts(node.stmts));
        this.openLoopStmtStates.pop();
        --this.indent;
        chunks.push(this.createStmtSourceNode(node, function () {
            return _this.generateGotoCode(loopStartLabel);
        }), this.generateLabelStmt(node, loopEndLabel));
        return this.createSourceNode.apply(this, __spreadArray([node], chunks, false));
    };
    CodeGenerator.prototype.visitExitLoopStmt = function (node) {
        var _this = this;
        if (this.openLoopStmtStates.length === 0) {
            this.throwError("EXIT DO statement outside DO loop", node);
        }
        return this.createStmtSourceNode(node, function () {
            return _this.generateGotoCode(_this.openLoopStmtStates[_this.openLoopStmtStates.length - 1].endLabel);
        });
    };
    CodeGenerator.prototype.visitForStmt = function (node) {
        var _this = this;
        var labelPrefix = this.generateLabel();
        var startLabel = "".concat(labelPrefix, "_loopStart");
        var endLabel = "".concat(labelPrefix, "_loopEnd");
        var stepValue = this.generateTempVarRef("".concat(labelPrefix, "_step"));
        var endValue = this.generateTempVarRef("".concat(labelPrefix, "_end"));
        this.openForStmtStates.push({
            forStmt: node,
            startLabel: startLabel,
            endLabel: endLabel,
            stepValue: stepValue,
            endValue: endValue,
        });
        var chunks = [];
        chunks.push(this.createStmtSourceNode(node, function () { return __spreadArray(__spreadArray(__spreadArray([], [
            _this.accept(node.counterExpr),
            ' = ',
            _this.accept(node.startExpr),
            '; ',
        ], false), [
            "".concat(stepValue, " = "),
            node.stepExpr ? _this.accept(node.stepExpr) : '1',
            '; ',
        ], false), ["".concat(endValue, " = "), _this.accept(node.endExpr), ';'], false); }), this.generateLabelStmt(node, startLabel));
        ++this.indent;
        chunks.push(this.createStmtSourceNode(node, function () { return __spreadArray(__spreadArray([], ["const counterValue = ", _this.accept(node.counterExpr), '; '], false), [
            'if (',
            "(".concat(stepValue, " >= 0 && counterValue > ").concat(endValue, ") || "),
            "(".concat(stepValue, " < 0 && counterValue < ").concat(endValue, ")"),
            ") { ".concat(_this.generateGotoCode(endLabel), " }"),
        ], false); }));
        return this.createSourceNode.apply(this, __spreadArray([node], chunks, false));
    };
    CodeGenerator.prototype.visitNextStmt = function (node) {
        var _this = this;
        // Determine how many open FOR statements this NEXT statement will close.
        var numForStmtStatesToClose = node.counterExprs.length || 1;
        if (numForStmtStatesToClose > this.openForStmtStates.length) {
            this.throwError("NEXT statement without corresponding FOR statement", node);
        }
        // Verify that the counter expressions match the corresponding FOR statements.
        for (var i = 0; i < node.counterExprs.length; ++i) {
            var nextCounterExprString = this.accept(node.counterExprs[i]).toString();
            var forStmt = this.openForStmtStates[this.openForStmtStates.length - 1 - i].forStmt;
            var forStmtCounterExprString = this.accept(forStmt.counterExpr).toString();
            if (nextCounterExprString !== forStmtCounterExprString) {
                this.throwError("Counter #".concat(i + 1, " does not match corresponding FOR statement"), node);
            }
        }
        // Generate code.
        var chunks = [];
        var _loop_2 = function (i) {
            var _a = this_2.openForStmtStates.pop(), forStmt = _a.forStmt, startLabel = _a.startLabel, endLabel = _a.endLabel, stepValue = _a.stepValue, endValue = _a.endValue;
            chunks.push(this_2.createStmtSourceNode(node, function () { return [
                _this.accept(forStmt.counterExpr),
                " += ".concat(stepValue, "; "),
                _this.generateGotoCode(startLabel),
            ]; }));
            --this_2.indent;
            chunks.push(this_2.generateLabelStmt(forStmt, endLabel));
            chunks.push(this_2.createStmtSourceNode(forStmt, function () { return "delete ".concat(stepValue, "; delete ").concat(endValue, ";"); }));
        };
        var this_2 = this;
        for (var i = 0; i < numForStmtStatesToClose; ++i) {
            _loop_2(i);
        }
        return this.createSourceNode.apply(this, __spreadArray([node], chunks, false));
    };
    CodeGenerator.prototype.visitExitForStmt = function (node) {
        var _this = this;
        if (this.openForStmtStates.length === 0) {
            this.throwError("EXIT FOR statement outside FOR loop", node);
        }
        return this.createStmtSourceNode(node, function () {
            return _this.generateGotoCode(_this.openForStmtStates[_this.openForStmtStates.length - 1].endLabel);
        });
    };
    CodeGenerator.prototype.visitGosubStmt = function (node) {
        return this.createStmtSourceNode(node, function () {
            return "return { type: '".concat(compiled_code_1.ExecutionDirectiveType.GOSUB, "', destLabel: '").concat(node.destLabel, "' };");
        });
    };
    CodeGenerator.prototype.visitReturnStmt = function (node) {
        return this.createStmtSourceNode(node, function () {
            return "return { type: '".concat(compiled_code_1.ExecutionDirectiveType.RETURN, "'").concat(node.destLabel ? ", destLabel: '".concat(node.destLabel, "'") : '', " };");
        });
    };
    CodeGenerator.prototype.visitCallStmt = function (node) {
        var _this = this;
        return this.createStmtSourceNode(node, function () { return [
            _this.visitProcCall(node),
            ';',
        ]; });
    };
    CodeGenerator.prototype.visitExitProcStmt = function (node) {
        return this.createStmtSourceNode(node, function () { return "return { type: '".concat(compiled_code_1.ExecutionDirectiveType.EXIT_PROC, "' };"); });
    };
    CodeGenerator.prototype.visitEndStmt = function (node) {
        return this.createStmtSourceNode(node, function () { return "return { type: '".concat(compiled_code_1.ExecutionDirectiveType.END, "' };"); });
    };
    CodeGenerator.prototype.visitSwapStmt = function (node) {
        var _this = this;
        var tempVarName = "".concat(this.generateLabel(), "_temp");
        return this.createStmtSourceNode(node, function () { return [
            _this.generateTempVarRef(tempVarName),
            ' = ',
            _this.accept(node.leftExpr),
            '; ',
            _this.accept(node.leftExpr),
            ' = ',
            _this.accept(node.rightExpr),
            '; ',
            _this.accept(node.rightExpr),
            ' = ',
            _this.generateTempVarRef(tempVarName),
            '; ',
            'delete ',
            _this.generateTempVarRef(tempVarName),
            ';',
        ]; });
    };
    CodeGenerator.prototype.visitPrintStmt = function (node) {
        var _this = this;
        return this.createStmtSourceNode(node, function () { return __spreadArray(__spreadArray([
            'await ctx.runtime.print(',
            node.formatExpr ? _this.accept(node.formatExpr) : 'null',
            ', '
        ], node.args.map(function (arg) {
            return typeof arg === 'string'
                ? "{ type: '".concat(arg, "' }, ")
                : _this.createSourceNode(arg, "{ type: '".concat(compiled_code_1.PrintArgType.VALUE, "', value: "), _this.accept(arg), ' }, ');
        }), true), [
            ');',
        ], false); });
    };
    CodeGenerator.prototype.visitInputStmt = function (node) {
        var _this = this;
        return this.createStmtSourceNode(node, function () {
            switch (node.inputType) {
                case ast_1.InputType.TOKENIZED:
                    return __spreadArray([
                        'const results = await ctx.runtime.input(',
                        "".concat(JSON.stringify(node.prompt), ", "),
                        node.targetExprs
                            .map(function (expr) { return JSON.stringify(expr.typeSpec); })
                            .join(', '),
                        '); '
                    ], node.targetExprs.map(function (expr, i) {
                        return _this.createSourceNode(expr, _this.accept(expr), " = results[".concat(i, "]; "));
                    }), true);
                case ast_1.InputType.LINE:
                    return _this.createSourceNode(node.targetExprs[0], _this.accept(node.targetExprs[0]), " = await ctx.runtime.inputLine(".concat(JSON.stringify(node.prompt), ");"));
                default:
                    _this.throwError("Unknown input type: ".concat(JSON.stringify(node.inputType)), node);
            }
        });
    };
    CodeGenerator.prototype.visitDefTypeStmt = function (node) {
        return new source_map_1.SourceNode();
    };
    CodeGenerator.prototype.visitDataStmt = function (node) {
        return this.createSourceNode(node, this.lines('{', +1, this.generateLoc(node), "data: ".concat(JSON.stringify(node.data), ","), -1, "},", ''));
    };
    CodeGenerator.prototype.visitReadStmt = function (node) {
        var _this = this;
        return this.createStmtSourceNode(node, function () { return __spreadArray([
            'const results = await ctx.read(',
            node.targetExprs.map(function (expr) { return JSON.stringify(expr.typeSpec); }).join(', '),
            '); '
        ], node.targetExprs.map(function (expr, i) {
            return _this.createSourceNode(expr, _this.accept(expr), " = results[".concat(i, "]; "));
        }), true); });
    };
    CodeGenerator.prototype.visitRestoreStmt = function (node) {
        return this.createStmtSourceNode(node, function () { return "ctx.restore(".concat(node.destLabel ? "'".concat(node.destLabel, "'") : '', ");"); });
    };
    CodeGenerator.prototype.createStmtSourceNode = function (node, generateRunCode) {
        return this.createSourceNode(node, this.lines('{', +1, ''), this.lines(this.generateLoc(node), ''), this.lines('async run(ctx) { '), generateRunCode(), ' },\n', this.lines(-1, '},', ''));
    };
    CodeGenerator.prototype.visitLiteralExpr = function (node) {
        var valueString;
        if (typeof node.value === 'string') {
            valueString = JSON.stringify(node.value);
        }
        else if (typeof node.value === 'number') {
            valueString = "".concat(node.value);
        }
        else {
            this.throwError("Unrecognized literal value: ".concat(JSON.stringify(node.value)), node);
        }
        return this.createSourceNode(node, valueString);
    };
    CodeGenerator.prototype.visitVarRefExpr = function (node) {
        return this.createSourceNode(node, this.generateVarRefCode(node, node.symbol));
    };
    CodeGenerator.prototype.visitFnCallExpr = function (node) {
        return this.visitProcCall(node);
    };
    CodeGenerator.prototype.visitBinaryOpExpr = function (node) {
        var chunks = [];
        switch (node.op) {
            case ast_1.BinaryOp.EXP:
                chunks.push('Math.pow(', this.accept(node.leftExpr), ', ', this.accept(node.rightExpr), ')');
                break;
            case ast_1.BinaryOp.INTDIV:
                chunks.push('Math.floor(', this.accept(node.leftExpr), ' / ', this.accept(node.rightExpr), ')');
                break;
            default:
                chunks.push('(', this.accept(node.leftExpr), " ".concat(BINARY_OP_MAP[node.op], " "), this.accept(node.rightExpr), ')');
                break;
        }
        return this.createSourceNode.apply(this, __spreadArray([node], chunks, false));
    };
    CodeGenerator.prototype.visitUnaryOpExpr = function (node) {
        var _a;
        var OP_MAP = (_a = {},
            _a[ast_1.UnaryOp.NEG] = '-',
            _a[ast_1.UnaryOp.NOT] = '!',
            _a[ast_1.UnaryOp.PARENS] = '',
            _a);
        return this.createSourceNode(node, '(', OP_MAP[node.op], this.accept(node.rightExpr), ')');
    };
    CodeGenerator.prototype.visitSubscriptExpr = function (node) {
        var _this = this;
        return this.createSourceNode.apply(this, __spreadArray([node,
            this.accept(node.arrayExpr),
            '.values'], node.indexExprs.map(function (indexExpr, i) { return [
            '[',
            _this.generateSubscriptCode(node.arrayExpr, i, indexExpr),
            ']',
        ]; }), false));
    };
    CodeGenerator.prototype.generateSubscriptCode = function (arrayExpr, dimension, indexExpr) {
        return [
            this.accept(arrayExpr),
            ".getIdx(".concat(dimension, ", "),
            this.accept(indexExpr),
            ')',
        ];
    };
    CodeGenerator.prototype.visitMemberExpr = function (node) {
        return this.createSourceNode(node, this.accept(node.udtExpr), ".values['".concat(node.fieldName, "']"));
    };
    CodeGenerator.prototype.visitProcCall = function (node) {
        var _a;
        var _this = this;
        var argPtrs = [];
        var tempVars = [];
        var tempVarPrefix = null;
        var tempVarIdx = 0;
        for (var i = 0; i < node.argExprs.length; ++i) {
            var argExpr = node.argExprs[i];
            var _b = node.argTypeProps[i], paramTypeSpec = _b.paramTypeSpec, shouldPassByRef = _b.shouldPassByRef;
            if (shouldPassByRef) {
                switch (argExpr.type) {
                    case ast_1.ExprType.VAR_REF:
                        argPtrs.push(this.createSourceNode(argExpr, argExpr.symbol.varType === symbol_table_1.VarType.ARG
                            ? "ctx.args['".concat(argExpr.symbol.name, "']")
                            : "[".concat(this.generateVarContainerCode(argExpr, argExpr.symbol), ", '").concat(argExpr.symbol.name, "']")));
                        break;
                    case ast_1.ExprType.SUBSCRIPT:
                        var containerCode = this.accept(__assign(__assign({}, argExpr), { indexExprs: argExpr.indexExprs.slice(0, argExpr.indexExprs.length - 1) }));
                        var lastIndexExprCode = this.generateSubscriptCode(argExpr.arrayExpr, argExpr.indexExprs.length - 1, argExpr.indexExprs[argExpr.indexExprs.length - 1]);
                        argPtrs.push(this.createSourceNode(argExpr, '[', containerCode, ', ', lastIndexExprCode, ']'));
                        break;
                    case ast_1.ExprType.MEMBER:
                        argPtrs.push(this.createSourceNode(argExpr, '[', this.accept(argExpr.udtExpr), '.values, ', "'".concat(argExpr.fieldName, "']")));
                        break;
                    default:
                        this.throwError("Unknown pass-by-reference expression type: ".concat(JSON.stringify(argExpr)), argExpr);
                }
            }
            else {
                if (!tempVarPrefix) {
                    tempVarPrefix = this.generateLabel();
                }
                var tempVarName = "".concat(tempVarPrefix, "_").concat(tempVarIdx++);
                tempVars.push({
                    name: tempVarName,
                    argExpr: argExpr,
                    paramTypeSpec: paramTypeSpec,
                });
                argPtrs.push("[ctx.tempVars, '".concat(tempVarName, "']"));
            }
        }
        var executeProcCodePrefixMap = (_a = {},
            _a[types_1.ProcDefType.BUILTIN] = 'ctx.runtime.executeBuiltinProc(' +
                "'".concat(node.name, "', ").concat(JSON.stringify(node.argExprs.map(function (_a) {
                    var typeSpec = _a.typeSpec;
                    return typeSpec;
                }))),
            _a[types_1.ProcDefType.MODULE] = "ctx.executeProc(ctx, '".concat(node.name, "'"),
            _a);
        return this.createSourceNode.apply(this, __spreadArray(__spreadArray([node,
            '(await (async () => {\n',
            this.lines(+1)], tempVars.map(function (_a) {
            var name = _a.name, argExpr = _a.argExpr, paramTypeSpec = _a.paramTypeSpec;
            return [
                _this.lines("".concat(_this.generateTempVarRef(name), " = ")),
                _this.generateAssignableValueCode(argExpr, paramTypeSpec),
                ';\n',
            ];
        }), false), [this.lines.apply(this, __spreadArray(__spreadArray(["const result = await ".concat(executeProcCodePrefixMap[node.procDefType], ", ").concat(argPtrs.join(', '), ");")], tempVars.map(function (_a) {
                var name = _a.name;
                return "delete ".concat(_this.generateTempVarRef(name), ";");
            }), false), ['return result;',
                -1,
                '})())'], false))], false));
    };
    CodeGenerator.prototype.createSourceNode = function (node) {
        var chunks = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            chunks[_i - 1] = arguments[_i];
        }
        return new source_map_1.SourceNode(node.loc.line, node.loc.col, this.opts.sourceFileName, lodash_1.default.flattenDeep(chunks));
    };
    CodeGenerator.prototype.lines = function () {
        var values = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            values[_i] = arguments[_i];
        }
        var outputLines = [];
        for (var _a = 0, values_1 = values; _a < values_1.length; _a++) {
            var value = values_1[_a];
            if (typeof value === 'string') {
                var indentStr = value
                    ? ' '.repeat(this.opts.indentWidth * this.indent)
                    : '';
                outputLines.push(indentStr + value);
            }
            else if (typeof value === 'number') {
                this.indent += value;
            }
            else {
                throw new Error("Unexpected line value: ".concat(JSON.stringify(value)));
            }
        }
        return outputLines.join('\n');
    };
    CodeGenerator.prototype.generateLabel = function () {
        return "$".concat(this.nextGeneratedLabelIdx++);
    };
    CodeGenerator.prototype.generateLoc = function (node) {
        return node.loc ? "loc: [".concat(node.loc.line, ", ").concat(node.loc.col, "],") : '';
    };
    CodeGenerator.prototype.generateLabelStmt = function (node, label) {
        return this.lines.apply(this, __spreadArray(__spreadArray(['{',
            +1], (node ? [this.generateLoc(node)] : []), false), ["label: '".concat(label, "',"), -1, "},", ''], false));
    };
    CodeGenerator.prototype.generateVarRefCode = function (node, symbol) {
        var varContainer = this.generateVarContainerCode(node, symbol);
        if (symbol.varType === symbol_table_1.VarType.ARG) {
            return "".concat(varContainer, "['").concat(symbol.name, "'][0][").concat(varContainer, "['").concat(symbol.name, "'][1]]");
        }
        else {
            return "".concat(varContainer, "['").concat(symbol.name, "']");
        }
    };
    CodeGenerator.prototype.generateVarContainerCode = function (node, symbol) {
        if (symbol.varType === symbol_table_1.VarType.ARG) {
            return 'ctx.args';
        }
        else if (symbol.varScope === symbol_table_1.VarScope.LOCAL) {
            switch (symbol.varType) {
                case symbol_table_1.VarType.STATIC_VAR:
                    return 'ctx.localStaticVars';
                case symbol_table_1.VarType.VAR:
                case symbol_table_1.VarType.CONST:
                    return 'ctx.localVars';
                default:
                    this.throwError("Unexpected local var type: ".concat(JSON.stringify(symbol.varType)), node);
            }
        }
        else if (symbol.varScope === symbol_table_1.VarScope.GLOBAL) {
            return 'ctx.globalVars';
        }
        else {
            this.throwError("Unknown variable type or scope: ".concat(JSON.stringify(symbol)), node);
        }
    };
    CodeGenerator.prototype.generateAssignableValueCode = function (valueExpr, targetTypeSpec) {
        var valueTypeSpec = valueExpr.typeSpec;
        var valueCode = this.accept(valueExpr);
        if ((0, types_1.isIntegral)(targetTypeSpec) && !(0, types_1.isIntegral)(valueTypeSpec)) {
            return ['ctx.runtime.roundHalfToEven(', valueCode, ')'];
        }
        else if ((0, types_1.isUdt)(targetTypeSpec)) {
            return [valueCode, '.clone()'];
        }
        else {
            return valueCode;
        }
    };
    CodeGenerator.prototype.generateGotoCode = function (destLabel) {
        return "return { type: '".concat(compiled_code_1.ExecutionDirectiveType.GOTO, "', destLabel: '").concat(destLabel, "' };");
    };
    CodeGenerator.prototype.generateTempVarRef = function (label) {
        return "ctx.tempVars['".concat(label, "']");
    };
    return CodeGenerator;
}(ast_1.AstVisitor));
exports.CodeGenerator = CodeGenerator;
function codegen(module, opts) {
    if (opts === void 0) { opts = {}; }
    return new CodeGenerator(module, opts).run();
}
exports.default = codegen;
