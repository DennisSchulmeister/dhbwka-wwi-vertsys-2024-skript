"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var types_1 = require("../lib/types");
var init_value_1 = __importDefault(require("./init-value"));
/** Runtime representation for QBasic arrays. */
var QbArray = /** @class */ (function () {
    function QbArray(arrayTypeSpec) {
        /** The underlying array storing the actual elements. */
        this._values = [];
        this.init(arrayTypeSpec.elementTypeSpec, arrayTypeSpec.dimensionSpecs);
    }
    /** Initializes the array with the provided spec, discarding any previous contents. */
    QbArray.prototype.init = function (elementTypeSpec, dimensionSpecs) {
        if (dimensionSpecs.length === 0) {
            throw new Error('No dimension specs provided');
        }
        this._typeSpec = (0, types_1.arraySpec)(elementTypeSpec, dimensionSpecs);
        this._values.length = 0;
        var currentDimensionArrays = [this._values];
        for (var i = 0; i < dimensionSpecs.length; ++i) {
            var _a = dimensionSpecs[i], minIdx = _a[0], maxIdx = _a[1];
            var numElements = maxIdx - minIdx + 1;
            var nextDimensionArrays = [];
            for (var _i = 0, currentDimensionArrays_1 = currentDimensionArrays; _i < currentDimensionArrays_1.length; _i++) {
                var dimensionArray = currentDimensionArrays_1[_i];
                if (i === dimensionSpecs.length - 1) {
                    for (var j = 0; j < numElements; ++j) {
                        dimensionArray.push((0, init_value_1.default)(elementTypeSpec));
                    }
                }
                else {
                    for (var j = 0; j < numElements; ++j) {
                        var nextDimensionArray = new Array();
                        nextDimensionArrays.push(nextDimensionArray);
                        dimensionArray.push(nextDimensionArray);
                    }
                }
            }
            currentDimensionArrays = nextDimensionArrays;
        }
    };
    /** Translates a QBasic index into the index in the underlying array. */
    QbArray.prototype.getIdx = function (dimensionIdx, qbIdx) {
        var dimensionSpecs = this._typeSpec.dimensionSpecs;
        if (!Number.isFinite(dimensionIdx) ||
            dimensionIdx < 0 ||
            dimensionIdx >= dimensionSpecs.length) {
            throw new Error('Invalid dimension in getIndex: ' +
                "expected number between 0 and ".concat(dimensionSpecs.length - 1, ", ") +
                "got ".concat(dimensionIdx));
        }
        var _a = dimensionSpecs[dimensionIdx], minIdx = _a[0], maxIdx = _a[1];
        if (!Number.isFinite(qbIdx) || qbIdx < minIdx || qbIdx > maxIdx) {
            throw new Error("Index out of range for dimension ".concat(dimensionIdx + 1, ": ") +
                "expected number between ".concat(minIdx, " and ").concat(maxIdx, ", ") +
                "got ".concat(qbIdx));
        }
        return qbIdx - minIdx;
    };
    Object.defineProperty(QbArray.prototype, "values", {
        get: function () {
            return this._values;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(QbArray.prototype, "typeSpec", {
        get: function () {
            return this._typeSpec;
        },
        enumerable: false,
        configurable: true
    });
    return QbArray;
}());
exports.default = QbArray;
