<section data-chapter="h1" data-background-color="rgb(210,190,210)">
    <h1>Hinweise zur Vorlesung</h1>
    <article class="markdown">
        ### Dieses Kapitel beschreibt …
        
        * Welche Inhalte wir in der Vorlesung behandeln werden.
        * Welche Kompetenzziele die Modulbeschreibung der DHBW hierfür vorgibt.
        * Wie sich die Prüfungsleistung der Vorlesung zusammensetzt.
        * Welche Software Sie für die Bearbeitung der Übungen benötigen.
    </article>
    <aside class="markdown">
        Willkommen zur Vorlesung „Verteilte Systeme” im vierten Semester Wirtschaftsinformatik.
        An dieser Stelle im Studium angelangt, haben Sie bereits viel Programmiererfahrung
        gesammelt und können durchaus schon eigene Programme bis hin zu kleineren Webanwendungen
        komplett eigenständig entwickeln. Diese Kenntnisse wollen wir nun vertiefen und dabei die
        Architektur kennenlernen, die heute fast alle Anwendungen des Alltags definiert: Die
        Architektur verteilter Systeme. Denn egal ob wir im Internet surfen, Musik oder Videos
        streamen, E-Mails schreiben, Kurznachrichten versenden, soziale Medien checken, online
        an Vorlesungen teilnehmen oder einfach nur dieses Vorlesungsskript bearbeiten: Immer
        kommen dabei verteilte Systeme zum Einsatz, die meiste Zeit ohne, dass wir dies bemerken.

        Smartphones, Tables, Arbeitscomputer, IoT-Devices, ja selbst Fahrzeuge sind heute wie
        selbstverständlich unterneinder vernetzt und mit dem Internet verbunden. Und beinahe
        täglich tun sich weitere Anwendungsgebiete auf. Hinter diesen Vorhang wollen wir daher
        nun schauen und verstehen, wie solche Anwendungen funktionieren. Und natürlich wollen
        wir sie auch selbst bauen können. Diese Vorlesung hilft Ihnen dabei. Und dieses Kapitel
        zeigt, was Sie dabei erwartet.
</section>

<section data-title="Vorlesungsinhalte">
    <article>
        <lsx-accordion>
            <lsx-accordion-page title="<b>3. Semester:</b>&nbsp;Webprogrammierung" active>
                <p>
                    <small>
                        Von der ersten Webseite bis zur eigenen Webanwendung
                    </small>
                </p>

                <lsx-ul emoji="✅" class="mb-4">
                    <li>Grundlagen des Web</li>
                    <li>Webdesign mit HTML und CSS</li>
                    <li>Responsive Webdesign</li>
                    <li>JavaScript im Browser</li>
                </lsx-ul>

                <img src="01-intro/vorlesungsinhalte-webprog.png" class="d-block w-100">
            </lsx-accordion-page>

            <lsx-accordion-page title="<b>4. Semester:</b>&nbsp;Verteilte Systeme">
                <p>
                    <small>
                        Von Microservices bis zum Internet of Things
                    </small>
                </p>

                <lsx-ul emoji="✅" class="mb-4">
                    <li>Architekturmuster verteilter Systeme</li>
                    <li>Backendprogrammierung mit JavaScript</li>
                    <li>Synchrone Webservice-Kommunikation</li>
                    <li>Asynchroner Nachrichtenaustausch</li>
                </lsx-ul>

                <img src="01-intro/vorlesungsinhalte-vertsys.png" class="d-block w-100">
            </lsx-accordion-page>
        </lsx-accordion>
    </article>
    <aside class="markdown">
        Die Vorlesung „Verteilte Systeme“ des vierten Semesters baut auf der Vorgängervorlesung
        „Webprogrammierung“ im dritten Semester auf und vervollständigt das Bild zur Entwicklung
        gesamter Anwendungen. Haben wir uns im dritten Semester überwiegend um die Clientseite
        und hier vor allem um das Web als Anwendungsplattform gekümmert, greifen wir im vierten
        Semester nochmal den Grundgedanken auf, verteilte Anwendungen zu entwickeln, die aus
        mehr Komponenten als dem auf dem eigenen Computer ausgeführten Quellcode bestehen und
        komplettieren das Bild um unterschiedliche Backendstrukturen und Kommunikationsarten.
        
        Doch nicht nur Webanwendungen wollen wir entwickeln. Benutzeroberflächen mit HTML und CSS
        laufen heute zwar auch außerhalb des Browsers. Die vorgestellten Architekturmuster und
        Techniken sind jedoch an keine UI-Technologie gebunden. Mobile Anwendungen, Desktop Apps,
        IoT-Devices uvm. kommen genauso in Frage wie clientseitige Webanwendungen. Hin und wieder
        werden wir daher einen kurzen Blick auch auf diese Anwendungsfälle werfen. Konkret werden
        wir daher folgende Inhalte behandeln:

        1. Architekturmuster verteilter Anwendungen
        1. Backendprogrammierung mit JavaScript
        1. Synchrone Webservice-Kommunikation
        1. Asynchroner Nachrichtenaustausch

        Das erste legt dabei den Grundstein für alle weiteren Inhalte und liefert neben wichtigen
        Begriffsdefinitionen (Was ist überhaupt ein „Verteiltes System“?) auch einen Überblick über
        die wichtigsten Architekturbausteine, Struktur- und Kommunikationsmuster. Im zweiten Kapitel
        führen wir dann die Programmierschiene fort und legen die Grundstein dafür, die vorgestellten
        Muster am Beispiel von Node.js und JavaScript in konkreten Anwendungen umsetzen zu können.
        Kapitel drei und vier liefern hierzu dann das notwendige Hintergrund- und Detailwissen anhand
        vieler Fallbeispiele und Beispielquellcodes.
    </aside>
</section>

<section data-title="Kompetenzziele">
    <article class="markdown">
        ## Fachkompetenz

        <small>Welches neue Wissen eigne ich mir an?</small>

        * Definition und Einsatzgebiete von verteilten Anwendungen
        * Typische Kommunikations- und Architekturmuster verteilter Systeme
        * Synchrone Webservice-Kommunikation mit REST-Webservices
        * Asynchroner Nachrichtenaustausch mit Apache Kafka und anderen

        ## Methodenkompetenz

        <small>Welche neuen Werkzeuge und Methoden kann ich anwenden?</small>

        * Verteilte Anwendungen ganzheitlich konzipieren und umsetzen
        * Alternative Architekturmuster abwägen und anhand der Anforderungen auswählen
        * Entwicklungswerkzeuge wie Kommandozeilentools, IDEs und Debugger bedienen
        * Frontend- und Backendprogrammierung mit JavaScript, Browser und Node.js

        ## Personale und soziale Kompetenz

        <small>Wie entwickele ich mich nicht nur fachlich sondern auch persönlich weiter?</small>

        * Aktuelle Konzepte in der Entwicklung verteilter Anwendungen kennen und diskutieren
        * Eigene Entwürfe verständlich kommunizieren und argumentieren
        * Eventuelle Programmfehler erkennen und deren Behebung erklären können

        ## Übergreifende Handlungskompetenz

        <small>Welche allgemeinen Fähigkeiten erwerbe ich durch diese Vorlesung?</small>
                
        * Trends und Entwicklungen im größeren Bereich der Anwendungsentwicklung bewerten
        * Sich in Diskussionen einbringen und Lösungsvorschläge unterbreiten
        * Sich eigenständig in neue Themengebiete der Anwendungsentwicklung einarbeiten
    </article>
    <aside>
        <p>
            Zur Erinnerung hier noch einmal die Beschreibung aus dem Modulhandbuch
            der DHBW. Es handelt sich um denselben Auszug, den wir auch am Anfang
            von Webprogrammierung gezeigt haben, da beide Vorlesung zusammen das
            Modul “Entwicklung verteilter Systeme“ bilden:
        </p>
        <div style="font-size:85%" class="markdown">
            ##### Fachkompetenz

            Die Studierenden kennen die grundlegenden Kernkonzepte der Nebenläufigkeit
            und Internet-Kommunikation und die darauf aufbauenden aktuellen Technologien
            und Werkzeuge für den Entwurf und für die Implementierung von Web-Anwendungen.
            Die Studierenden kennen die technischen Grundlagen, Konzepte, Architekturen
            und Technologien verteilter Systeme und Anwendungen sowie die gängigen Methoden,
            Werkzeuge, Frameworks und Entwurfsmuster für die Entwicklung verteilter Anwendungen.

            ##### Methodenkompetenz

            Die Studierenden können die Konzepte, Werkzeuge und Methoden der Web-Programmierung
            anwenden und autonom Web-Anwendungen entwerfen, implementieren und testen. Die Studierenden
            können die Konzepte, Werkzeuge und Methoden der verteilten Systementwicklung anwenden und
            unter Einsatz von Frameworks und Entwurfsmustern einfache verteilte Anwendungen entwerfen,
            implementieren und testen.

            ##### Personale und soziale Kompetenz

            Die Studierenden können eigenständig verteilte Anwendungsarchitekturen erarbeiten.
            Sie können stichhaltig und sachangemessen über Konzepte, eigene Entwürfe und deren
            Implementierungen sowie die damit verbundenen Probleme argumentieren, eigene Umsetzungen
            plausibel darstellen und eventuelle Fehler nachvollziehbar gegenüber anderen begründen.


            ##### Übergreifende Handlungskompetenz

            Die Studierenden können eigenständig aktuelle Methoden der Analyse, des Entwurfs und
            der Implementierung verteilter Systeme und Anwendungen für betriebliche Problemstellungen
            diskutieren, bewerten und anwenden.
        </div>
        <p>
            Da diese Beschreibung zwar den inhaltlichen Rahmen vorgibt, bei seiner Ausgestaltung
            aber viele Freiheiten bieten, findet sich auf der Seite rechts unsere Auslegung am
            Standort Karlsruhe. Diese lehnt sich an die Lernzeile von „Webprogrammierung” an und
            deckt sich an vielen Stellen mit dieser. Inhaltlich wird das Bild jedoch nun hin zur
            ganzheitlichen Konzeptionierung und Entwicklung moderner Anwendungen (nicht nur
            clientseitige Webanwendungen) erweitert.
        </p>
    </aside>
</section>

<section data-title="Didaktisches Modell">
    <article>
        <lsx-tab-pages>
            <lsx-tab-page title="Ablauf der Vorlesung">
                <p>
                    Abweichend zum dritten Semester folgt die Vorlesung einem  reduzierten „Inverted Classroom Model“:
                </p>
                <lsx-ul class="mb-3">
                    <li>
                        Wie in Webprogrammierung begleitet das Onlineskript die Präsenztermine.
                    </li>
                    <li>
                        Es muss jedoch nicht jeder Termin durch ein Selbststudium vorbereitet werden.
                    </li>
                    <li>
                        Dementsprechen fehlen auch die Vorwissensabfrage und Lernkontrollen in Moodle.
                    </li>
                    <li>
                        Es gibt teilweise jedoch verbindliche Hausaufgaben, die auch der Vorbereitung dienen.
                    </li>
                    <li>
                        Insbesondere die Programmieraufgaben fließen als Leistungsnachweis in die Prüfung ein.
                    </li>
                </lsx-ul>

                <lsx-grid-fluid class="p-0">
                    <lsx-row>
                        <lsx-col size="md">
                            <img src="01-intro/didaktisches-modell1.png" class="img-thumbnail d-block w-100" />
                        </lsx-col>
                        <lsx-col size="md">
                            <img src="01-intro/didaktisches-modell2.png" class="img-thumbnail d-block w-100" />
                        </lsx-col>
                    </lsx-row>
                </lsx-grid-fluid>
            </lsx-tab-page>
            <lsx-tab-page title="Vorlesungsübersicht in Moodle">
                <img src="01-intro/moodle1.png" class="img-fluid img-thumbnail mx-auto d-block" />
            </lsx-tab-page>
        </lsx-tab-pages>
    </article>
    <aside class="markdown">
        ##### Ablauf der Vorlesung

        Die Vorlesung im vierten Semester folgt demselben Inverted-Classroom-Modell wie die Vorgängerveranstaltung
        des dritten Semesters. Aufgrund das allgemein höheren Workloads im vierten Semester wird das Model jedoch
        angepasst, so dass nur ein Teil der Präsenzveranstaltungen im Selbststudium vorbereitet werden muss. Dies
        spiegelt sich auch in den fehlenden Vorwissensabfragen und Lernkontrollen in Moodle wieder.
        
        Was bleibt ist jedoch das semesterbegleitende Onlineskript, anhand dessen die Inhalte über die Vorlesungen
        hinaus eigenständig verinnerlicht werden müssen. Neben inhaltlichen Erklärungen finden sich hier insbesondere
        auch verbindliche Programmierübungen, die Leistungsnachweis in die Prüfungsnote einfließen. Denn die Übungen
        sind ausschlaggebend dafür, die vermittelten Konzepte anhand praktischer Fallbeispiele nachvollziehen und
        praktisch anwenden zu können.

        ##### Materialien in Moodle

        Der Screenshot auf der zweiten Seite zeigt den Moodleraum dieser Vorlesung. Jeder Kurs besitzt einen eigene
        Moodleraum, der von der jeweiligen Lehrperson mit Inhalten bestückt wird. Neben allgemeinen Punkten wie der
        Anwesenheitsliste (siehe unten) sind hier vor allem das Onlineskript und die Quellcodes zur Vorlesung verlinkt.
        Hinzu kommen ggf. zusätzliche Materialien für die Präsenzveranstaltungen unterhalb der jeweiligen Überschriften.
        Neben den fehlenden Vorwissensabfragen und Lernkontrollen gibt es allerdings noch eine Abweichung zum Vorsemester:
        Die Übungen, Fallbeispiele und Quizze sind nun in das Onlineskript integriert und werden daher nicht mehr separat
        in Moodle hochgeladen. Dadurch werden die Inhalte noch besser verzahnt und können nicht mehr so leicht übersehen
        oder vergessen werden.

        ##### Elektronische Anwesenheitsliste

        Im vierten Semester führen wie wieder eine elektronische Anwesenheitsliste in Moodle. Wie gewohnt wird hierfür
        am Anfang der Stunde ein QR-Code gezeigt, über den sich die Teilnehmer*innnen während der Stunde selbst eintragen
        können.
    </aside>
</section>

<section data-title="Prüfungsaufgabe">
    <article>
        <lsx-tab-pages>
            <lsx-tab-page title="Allgemeines">
                <lsx-ul>
                    <li>Ähnliches Prinzip wie in Webprogrammierung im dritten Semester</li>
                    <li>Anstelle der Lernkontrollen gibt es jedoch Leistungsnachweise zu den Übungen</li>
                    <li>Und das Aufgabenblatt enthält abgeschlossene Aufgaben zu den jeweiligen Kapiteln</li>
                </lsx-ul>

                <table class="w-100 dhbw-fontsize-small dhbw-table-border" style="margin: 1.2rem 0 1.75rem 0;">
                    <thead>
                        <tr>
                            <th>Semester</th>
                            <th>Portfolioanteil</th>
                            <th>Abgabefrist</th>
                            <th>Gewichtung</th>
                        </tr>
                    </thead>

                    <!-- Drittes Semester -->
                    <tr style="background-color: #eaeaea; color: #888888;">
                        <td>3</td>
                        <td><b>Lernkontrollen in Moodle</b> ✔️</td>
                        <td>Nach der ersten Vorlesung eines Kapitels</td>
                        <td>2</td>
                    </tr>
                    <tr style="background-color: #eaeaea; color: #888888;">
                        <td>3</td>
                        <td><b>Aufgabenblatt mit Programmierprojekt</b> ✔️</td>
                        <td>Vor Beginn der Klausurphase</td>
                        <td>4</td>
                    </tr>

                    <!-- Viertes Semester -->
                    <tr style="background-color: white;">
                        <td>4</td>
                        <td><b>Leistungsnachweise der Übungsaufgaben</b></td>
                        <td>Nach Abschluss des jeweiligen Kapitels</td>
                        <td>1</td>
                    </tr>
                    <tr style="background-color: white;">
                        <td>4</td>
                        <td><b>Aufgabenblatt mit Einzelaufgaben</b></td>
                        <td>Vor Beginn der Klausurphase</td>
                        <td>3</td>
                    </tr>
                </table>

                <lsx-info-box>
                    Jeder in der Tabelle genannte Prüfungsanteil wird mit einer Punktzahl bewertet,
                    die in Prozent umgerechnet wird. Anhand der Teilprozente wird dann ein gewichteter
                    Mittelwert gebildet, um die Note zu ermitteln.
                </lsx-info-box>
            </lsx-tab-page>

            <lsx-tab-page title="Unterlagen in Moodle">
                <img src="01-intro/pf-moodle.png" class="img-fluid img-thumbnail mx-auto d-block" />
            </lsx-tab-page>

            <lsx-tab-page title="Aufgabenblatt">
                <div class="d-flex w-100" style="gap: 0.5em;">
                    <div class="flex-grow-1 flex-shrink-1">
                        <img src="01-intro/pf-blatt1.png" class="img-thumbnail d-block w-100" />
                    </div>
                    <div class="flex-grow-1 flex-shrink-1">
                        <img src="01-intro/pf-blatt2.png" class="img-thumbnail d-block w-100" />
                    </div>
                </div>
            </lsx-tab-page>
        </lsx-tab-pages>
    </article>
    <aside class="markdown">
        ##### Portfolioaufgaben im vierten Semester

        Auch im vierten Semester werden wir wieder ein Aufgabenblatt mit Portfolioaufgaben haben, das zusammen mit
        den Aufgaben des dritten Semesters ein Prüfungsportfolio bildet. Die Vorgehensweise ist im Grunde dieselbe.
        An folgenden Stellen gibt es jedoch Abweichungen:

        * Anstelle der Lernkontrollen müssen Leistungsnachweise für die Übungsaufgaben in Moodle hochgeladen werden.
        Diese bestehen für jede der prüfungsrelevanten Übungen aus einem ca. ein bis zwei minütigen Video (ungeschnitten),
        indem die Lösung vorgeführt und erklärt werden muss.

        * Anstelle einer großen Programmieraufgabe besteht das Aufgabenblatt aus kleineren, in sich geschlossenen
        Aufgaben zu jedem Kapitel. Zwar muss auch hier programmiert werden. Im Fokus liegt dabei aber jeweils nur
        ein Konzept wie z.B. REST-Webservices, das anhand eines überschaubaren Fallbeispiels praktisch angewendet
        werden soll.

        Grundsätzlich sind auch diese Aufgaben in Eigenleistung zu bearbeiten. Die Aufgaben sind daher so gestellt,
        dass Fallbeispiele und Lösungswege frei gewählt werden können.

        ##### Berechnung der Note

        Ähnlich wie in den meisten anderen Modulen gibt es für das Modul „Entwicklung verteilter Systeme“ eine
        Modulnote im vierten Semester. Der Portfolioanteil des dritten Semesters erhält keine eigene Note, sondern
        wird mit dem vierten Semester verrechnet. Die Studienordnung schreibt dabei vor, dass die beiden Vorlesungen
        entsprechend ihrer Anzahl Vorlesungsstunden in die Note einfließen müssen. Konkret bedeutet das, dass das
        dritte Semester zu 60% und das vierte Semester zu 40% die Note bilden.

        Zur Berechnung der Note werden werden Portfolioartefakte einzeln mit Punkten bewertet. Aus diesen ergibt sich
        eine Prozentzahl, wie viele Punkte tatsächlich erreicht wurden. Die Prozentzahlen werden dann einfach in einem
        gewichteten Durschnitt miteinander verrechnet. Anhand der Notenskala der DHBW ergibt sich daraus die eigentliche Note.
    </aside>
</section>

<section data-title="Benötigte Software">
    <article>
        <lsx-tab-pages>
            <lsx-tab-page title="Visual Studio Code">
                <lsx-grid-fluid>
                    <lsx-row class="mb-0">
                        <lsx-col size="md">
                            <p>
                                Als Entwicklungsumgebung werden wir Visual Studio Code, da der Atom-Editor leider nicht mehr
                                weiterentwickelt wird. 🙁 Es handelt sich um eine weit verbreitete IDE mit Unterstützung für
                                alle gängigen Programmiersprachen und Betriebssysteme.
                            </p>
                        </lsx-col>
                    </lsx-row>

                    <lsx-row>
                        <lsx-col size="md">
                            <img src="01-intro/vscode-screenshot.png" class="img-thumbnail d-block" style="width: 100%; height: 100%;" />
                        </lsx-col>
                        <lsx-col size="md">
                            <!-- <lsx-youtube class="img-thumbnail embed-responsive" video="KMxo3T_MTvY"></lsx-youtube> -->
                            <div class="img-thumbnail embed-responsive" style="width: 100%; height: 100%;">
                                <iframe class="d-block" style="width: 100%; height: 100%;" src="https://www.youtube-nocookie.com/embed/KMxo3T_MTvY?rel=0&amp;showinfo=0" allowfullscreen></iframe>
                            </div>
                        </lsx-col>
                    </lsx-row>

                    <lsx-row>
                        <lsx-col size="md">
                            <lsx-ul>
                                <li>
                                    Weit verbreitete IDE für alle gängigen Betriebssysteme
                                </li>
                                <li>
                                    Geschrieben in HTML und JavaScript (basierend auf der Chrome Webengine)
                                </li>
                                <li>
                                    Open-Source von Microsoft (Made in Switzerland) 🇨🇭
                                </li>
                            </lsx-ul>
                        </lsx-col>
                    </lsx-row>
                </lsx-grid-fluid>
            </lsx-tab-page>

            <lsx-tab-page title="Node.js">
                <lsx-grid-fluid>
                    <lsx-row class="mb-0">
                        <lsx-col size="md">
                            <p>
                                Für die Backendprogrammierung werden wir Node.js als JavaScript-Laufzeitumgebung nutzen.
                                Es handelt sich um eine weit verbreitete Runtime für nebenläufige verteilte Anwendungen
                                auf Basis der V8-Enginge des Google Chrome Browsers.
                            </p>
                        </lsx-col>
                    </lsx-row>

                    <lsx-row>
                        <lsx-col size="md">
                            <img src="01-intro/node.js-logo.svg" class="img-thumbnail d-block" style="width: 100%; height: 100%;" />
                        </lsx-col>
                        <lsx-col size="md">
                            <img src="01-intro/node.js-screenshot.png" class="img-thumbnail d-block" style="width: 100%; height: 100%;" />
                        </lsx-col>
                    </lsx-row>

                    <lsx-row>
                        <lsx-col size="md">
                            <lsx-ul>
                                <li>
                                    Beinhaltet den Node Package Manager zur einfachen Installation aller für ein Projekt benötigten Bibliotheken
                                </li>
                                <li>
                                    Liefert uns alle Build- und Testwerkzeuge, die wir während der Entwicklung benötigen
                                </li>
                                <li>
                                    Beinhaltet eine komplette JavaScript-Laufzeitumgebung für die serverseitige Programmierung
                                </li>
                            </lsx-ul>
                        </lsx-col>
                    </lsx-row>
                </lsx-grid-fluid>
            </lsx-tab-page>

            <lsx-tab-page title="API-Testwerkzeug">
                <lsx-grid-fluid>
                    <lsx-row class="mb-0">
                        <lsx-col size="md">
                            <p>
                                Während der Entwicklung kommt es immer wieder vor, dass wir sowohl unser eigenen als auch
                                fremden entfernte Services testen möchten. Hierfür benötigen wir einen beliebigen „API Client”,
                                der uns hierbei unterstützt.
                            </p>
                        </lsx-col>
                    </lsx-row>

                    <lsx-row>
                        <lsx-col size="md">
                            <div class="img-thumbnail">
                                <lsx-youtube video="Fbzmi1Q5hQU"></lsx-youtube>
                            </div>
                        </lsx-col>
                        <lsx-col size="md">
                            <div class="img-thumbnail">
                                <lsx-youtube video="kPO8Km_EYd4"></lsx-youtube>
                            </div>
                        </lsx-col>
                    </lsx-row>

                    <lsx-row>
                        <lsx-col size="md">
                            <lsx-ul>
                                <li>
                                    <a href="https://httpie.io/" target="_blank">httpie</a>:
                                    Besonders leicht zu nutzen. Web-, Desktop- und Kommandozeilenversion verfügbar.
                                </li>
                                <li>
                                    <a href="https://www.usebruno.com/" target="_blank">bruno</a>:
                                    Newcommer unter den API-Clients. Collections können leicht mit Git versioniert werden.
                                </li>
                                <li>
                                    <a href="https://hoppscotch.io/" target="_blank">hoppscotch</a>:
                                    Besonders leistungsfähig vergleichbar mit den großen kommerziellen Anbietern.
                                </li>
                            </lsx-ul>
                            <p>
                                httpie und hoppscotch können direkt im Browser ausgeführt werden.
                                Sie haben die freie Wahl. Alle drei Clients sind für die Vorlesung geeignet.
                            </p>
                        </lsx-col>
                    </lsx-row>
                </lsx-grid-fluid>
            </lsx-tab-page>

            <lsx-tab-page title="Gitpod">
                <lsx-grid-fluid>
                    <lsx-row class="mb-0">
                        <lsx-col size="md">
                            <p>
                                Falls Sie auf Ihrem Computer keine zusätzliche Software installieren können oder sich bestimmte
                                Dienste über das DHBW-Netzwerk nicht erreichen lassen, können Sie auf die Gitpod Online-IDE ausweichen.
                                Diese bietet eine IDE und Linux-Umgebung direkt in Ihrem Browser.
                            </p>
                        </lsx-col>
                    </lsx-row>

                    <lsx-row>
                        <lsx-col size="md">
                            <img src="01-intro/github-screenshot.png" class="img-thumbnail d-block" style="width: 100%; height: 100%;" />
                        </lsx-col>
                        <lsx-col size="md">
                            <img src="01-intro/gitpod-screenshot.png" class="img-thumbnail d-block" style="width: 100%; height: 100%;" />
                        </lsx-col>
                    </lsx-row>

                    <lsx-row>
                        <lsx-col size="md">
                            <lsx-ul>
                                <li>
                                    IDE und Linux-Umgebung mit vorinstallierten Werkzeugen komplett in der Cloud.
                                </li>
                                <li>
                                    Keine Registrierung erforderlich, sofern Sie bereits einen GitHub Account besitzen.
                                </li>
                                <li>
                                    Quellcodes müssen in einem öffentlich sichtbare Git-Repository auf GitHub liegen.
                                </li>
                            </lsx-ul>
                        </lsx-col>
                    </lsx-row>
                </lsx-grid-fluid>
            </lsx-tab-page>
        </lsx-tab-pages>
    </article>
    <aside class="markdown">
        Ein Handwerker braucht zum Arbeiten sein Werkzeug. Das ist beim Programmieren natürlich nicht anders.
        Und genau wie beim Handwerkszeug gibt es eine geradezu unendliche Auswahl an Editoren, Frameworks,
        Datenbanken und Servern, die man zur Entwicklung seiner Anwendungen nutzen kann. In der Vorlesung
        haben wir uns daher auf folgende Werkzeuge festgelegt.

        ##### Visual Studio Code

        Visual Studio Code hat sich in den letzten Jahren zu einer der beliebtesten und flexibelsten IDEs
        überhaupt entwickelt. Im Gegensatz zu klassischen IDEs wit Eclipse, NetBeans oder dem großen Bruder
        Visual Studio, ist Visual Studio Code im Kern jedoch äußert kompakt und dank der durchgängigen Verwendung
        von Web-Technologien leicht anpass- und erweiterbar. Ein Blick in den Extension Marketplace wird dies
        bestätigen. 

        <lsx-info-box type="warning">
            <b>Vorsichtig:</b> <i>A fool with a tool is still a fool.</i> Zu viele Extensions stören eher,
            als dass Sie bei der Problemlösung helfen.
        </lsx-info-box>

        [https://code.visualstudio.com/](https://code.visualstudio.com/){target=blank}

        ##### Node.js und npm

        Die in der Vorlesung besprochenen Konzepte sind an keine konkrete Programmiersprache gebunden.
        Eine in jüngerer Zeit vor allem bei Webentwicklern zunehmend beliebte Sprache ist jedoch JavaScript,
        das dank Laufzeitumgebungen wie Node.js oder Bun inzwischen auch außeralb des Browsers läuft.
        In der Vorlesung werden wir daher unsere jüngst erworbenen JavaScript-Kenntnisse vertiefen und
        JavaScript auch für die Backendprogrammierung nutzen.

        [https://nodejs.org/](https://nodejs.org/){target=blank}

        ##### API-Testwerkzeug

        Während der Entwicklung ist es oft erforderlich, auf einem entfernten Host laufende Dienste zu
        testen, noch bevor eine vollständige Clientanwendung dafür entwickelt wurde. Doch selbst wenn
        ein dedizierter Client (der Begriff wird im nächsten Kapitel noch definiert) zur Verfügung steht,
        kann es sinnvoll sein, einen entfernten Service direkt zu testen, um die ausgetauschten Daten
        direkt sehen zu können. Hierfür gibt es eine Vielzahl von Werkzeugen, von denen Postman und Insomnia
        die zwei beliebtesten, kommerziellen Varianten sind. Beide sind jedoch an ein Cloud-Abo des jeweiligen
        Anbieters gebunden und werden inzwischen nicht mehr (Postman) oder nur sehr versteckt (Insomnia)
        als Offline-Werkzeug angeboten.

        In der Vorlesung wollen wir uns nicht von derartigen Geschäftsgebahren abhängig machen und setzen
        eher auf vollständig quelloffene und datenschutzkonforme Lösungen. Die folgenden Werkzeuge können
        unter diesen Gesichtspunkten bedenkenlos empfohlen werden:

        * [httpie](https://httpie.io/){target=_blank}
        * [bruno](https://www.usebruno.com/){target_blank}
        * [hoppscotch](https://hoppscotch.io/){target_blank}

        Welches Werkzeug Sie verwenden spielt für die Vorlesung keine Rolle und hängt überwiegend von
        persönlichen Anforderungen und Vorlieben ab. httpie und HOPPSCOTCH bieten den Vorteil, ohne
        Installation auf der jeweiligen Seite direkt im Browser ausgeführt werden zu können. Wenn Sie
        keine zusätzliche Software installieren wollen oder können, ist dies eine gute Wahl. Alle haben
        jedoch gemeinsam, dass es eine vollwertige Desktopversion für alle gängigen Betriebssysteme gibt,
        in der beliebig viele Projekte lokal verwaltet und dauerhaft gespeichert werden können. Postman
        und Insomnia bieten diesen Vorteil leider nicht mehr.

        ##### Gitpod

        Rein optional aber durchaus eine Alternative, um die Installation lokaler Softwarepakete auf
        Ihrem Computer zu vermeiden. Bei Gitpod handelt es sich um einen in der Cloud laufenden Ableger
        von Visual Studio Code, der neben der IDE auch eine vollständige Linux-Umgebung mit vorinstallierten
        Werkzeugen von Docker oder Node.js bietet. Einzige Voraussetzung hierfür ist, dass der zu bearbeitende
        Quellcode in einem öffentlich sichtbaren Git-Repository auf GitHub liegt. Denn dann kann Gitpod für
        persönliche Projekte kostenlos genutzt werden. Die Anmeldung erfolgt mit dem persönlichen GitHub Account.
        Zwar handelt es sich um ein kommerzielles Angebot, die Plattform ist jedoch vollständig quelloffen.

        [https://gitpod.io/](https://gitpod.io/){target=blank}
    </aside>
</section>
