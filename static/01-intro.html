<section data-chapter="h1" data-background-color="rgb(210,190,210)">
    <h1>Hinweise zur Vorlesung</h1>
    <article class="markdown">
        ### Dieses Kapitel beschreibt ‚Ä¶
        
        * Welche Inhalte wir in der Vorlesung behandeln werden.
        * Welche Kompetenzziele die Modulbeschreibung der DHBW hierf√ºr vorgibt.
        * Wie sich die Pr√ºfungsleistung der Vorlesung zusammensetzt.
        * Welche Software Sie f√ºr die Bearbeitung der √úbungen ben√∂tigen.
    </article>
    <aside class="markdown">
        Willkommen zur Vorlesung ‚ÄûVerteilte Systeme‚Äù im vierten Semester Wirtschaftsinformatik.
        An dieser Stelle im Studium angelangt, haben Sie bereits viel Programmiererfahrung
        gesammelt und k√∂nnen durchaus schon eigene Programme bis hin zu kleineren Webanwendungen
        komplett eigenst√§ndig entwickeln. Diese Kenntnisse wollen wir nun vertiefen und dabei die
        Architektur kennenlernen, die heute fast alle Anwendungen des Alltags definiert: Die
        Architektur verteilter Systeme. Denn egal ob wir im Internet surfen, Musik oder Videos
        streamen, E-Mails schreiben, Kurznachrichten versenden, soziale Medien checken, online
        an Vorlesungen teilnehmen oder einfach nur dieses Vorlesungsskript bearbeiten: Immer
        kommen dabei verteilte Systeme zum Einsatz, die meiste Zeit ohne, dass wir dies bemerken.

        Smartphones, Tables, Arbeitscomputer, IoT-Devices, ja selbst Fahrzeuge sind heute wie
        selbstverst√§ndlich unterneinder vernetzt und mit dem Internet verbunden. Und beinahe
        t√§glich tun sich weitere Anwendungsgebiete auf. Hinter diesen Vorhang wollen wir daher
        nun schauen und verstehen, wie solche Anwendungen funktionieren. Und nat√ºrlich wollen
        wir sie auch selbst bauen k√∂nnen. Diese Vorlesung hilft Ihnen dabei. Und dieses Kapitel
        zeigt, was Sie dabei erwartet.
</section>

<section data-title="Vorlesungsinhalte">
    <article>
        <lsx-accordion>
            <lsx-accordion-page title="<b>3. Semester:</b>&nbsp;Webprogrammierung" active>
                <p>
                    <small>
                        Von der ersten Webseite bis zur eigenen Webanwendung
                    </small>
                </p>

                <lsx-ul emoji="‚úÖ" class="mb-4">
                    <li>Grundlagen des Web</li>
                    <li>Webdesign mit HTML und CSS</li>
                    <li>Responsive Webdesign</li>
                    <li>JavaScript im Browser</li>
                </lsx-ul>

                <img src="01-intro/vorlesungsinhalte-webprog.png" class="d-block w-100">
            </lsx-accordion-page>

            <lsx-accordion-page title="<b>4. Semester:</b>&nbsp;Verteilte Systeme">
                <p>
                    <small>
                        Von Microservices bis zum Internet of Things
                    </small>
                </p>

                <lsx-ul emoji="‚úÖ" class="mb-4">
                    <li>Architekturmuster verteilter Systeme</li>
                    <li>Backendprogrammierung mit JavaScript</li>
                    <li>Synchrone Webservice-Kommunikation</li>
                    <li>Asynchroner Nachrichtenaustausch</li>
                </lsx-ul>

                <img src="01-intro/vorlesungsinhalte-vertsys.png" class="d-block w-100">
            </lsx-accordion-page>
        </lsx-accordion>
    </article>
    <aside class="markdown">
        Die Vorlesung ‚ÄûVerteilte Systeme‚Äú des vierten Semesters baut auf der Vorg√§ngervorlesung
        ‚ÄûWebprogrammierung‚Äú im dritten Semester auf und vervollst√§ndigt das Bild zur Entwicklung
        gesamter Anwendungen. Haben wir uns im dritten Semester √ºberwiegend um die Clientseite
        und hier vor allem um das Web als Anwendungsplattform gek√ºmmert, greifen wir im vierten
        Semester nochmal den Grundgedanken auf, verteilte Anwendungen zu entwickeln, die aus
        mehr Komponenten als dem auf dem eigenen Computer ausgef√ºhrten Quellcode bestehen und
        komplettieren das Bild um unterschiedliche Backendstrukturen und Kommunikationsarten.
        
        Doch nicht nur Webanwendungen wollen wir entwickeln. Benutzeroberfl√§chen mit HTML und CSS
        laufen heute zwar auch au√üerhalb des Browsers. Die vorgestellten Architekturmuster und
        Techniken sind jedoch an keine UI-Technologie gebunden. Mobile Anwendungen, Desktop Apps,
        IoT-Devices uvm. kommen genauso in Frage wie clientseitige Webanwendungen. Hin und wieder
        werden wir daher einen kurzen Blick auch auf diese Anwendungsf√§lle werfen. Konkret werden
        wir daher folgende Inhalte behandeln:

        1. Architekturmuster verteilter Anwendungen
        1. Backendprogrammierung mit JavaScript
        1. Synchrone Webservice-Kommunikation
        1. Asynchroner Nachrichtenaustausch

        Das erste legt dabei den Grundstein f√ºr alle weiteren Inhalte und liefert neben wichtigen
        Begriffsdefinitionen (Was ist √ºberhaupt ein ‚ÄûVerteiltes System‚Äú?) auch einen √úberblick √ºber
        die wichtigsten Architekturbausteine, Struktur- und Kommunikationsmuster. Im zweiten Kapitel
        f√ºhren wir dann die Programmierschiene fort und legen die Grundstein daf√ºr, die vorgestellten
        Muster am Beispiel von Node.js und JavaScript in konkreten Anwendungen umsetzen zu k√∂nnen.
        Kapitel drei und vier liefern hierzu dann das notwendige Hintergrund- und Detailwissen anhand
        vieler Fallbeispiele und Beispielquellcodes.
    </aside>
</section>

<section data-title="Kompetenzziele">
    <article class="markdown">
        ## Fachkompetenz

        <small>Welches neue Wissen eigne ich mir an?</small>

        * Definition und Einsatzgebiete von verteilten Anwendungen
        * Typische Kommunikations- und Architekturmuster verteilter Systeme
        * Synchrone Webservice-Kommunikation mit REST-Webservices
        * Asynchroner Nachrichtenaustausch mit Apache Kafka und anderen

        ## Methodenkompetenz

        <small>Welche neuen Werkzeuge und Methoden kann ich anwenden?</small>

        * Verteilte Anwendungen ganzheitlich konzipieren und umsetzen
        * Alternative Architekturmuster abw√§gen und anhand der Anforderungen ausw√§hlen
        * Entwicklungswerkzeuge wie Kommandozeilentools, IDEs und Debugger bedienen
        * Frontend- und Backendprogrammierung mit JavaScript, Browser und Node.js

        ## Personale und soziale Kompetenz

        <small>Wie entwickele ich mich nicht nur fachlich sondern auch pers√∂nlich weiter?</small>

        * Aktuelle Konzepte in der Entwicklung verteilter Anwendungen kennen und diskutieren
        * Eigene Entw√ºrfe verst√§ndlich kommunizieren und argumentieren
        * Eventuelle Programmfehler erkennen und deren Behebung erkl√§ren k√∂nnen

        ## √úbergreifende Handlungskompetenz

        <small>Welche allgemeinen F√§higkeiten erwerbe ich durch diese Vorlesung?</small>
                
        * Trends und Entwicklungen im gr√∂√üeren Bereich der Anwendungsentwicklung bewerten
        * Sich in Diskussionen einbringen und L√∂sungsvorschl√§ge unterbreiten
        * Sich eigenst√§ndig in neue Themengebiete der Anwendungsentwicklung einarbeiten
    </article>
    <aside>
        <p>
            Zur Erinnerung hier noch einmal die Beschreibung aus dem Modulhandbuch
            der DHBW. Es handelt sich um denselben Auszug, den wir auch am Anfang
            von Webprogrammierung gezeigt haben, da beide Vorlesung zusammen das
            Modul ‚ÄúEntwicklung verteilter Systeme‚Äú bilden:
        </p>
        <div style="font-size:85%" class="markdown">
            ##### Fachkompetenz

            Die Studierenden kennen die grundlegenden Kernkonzepte der Nebenl√§ufigkeit
            und Internet-Kommunikation und die darauf aufbauenden aktuellen Technologien
            und Werkzeuge f√ºr den Entwurf und f√ºr die Implementierung von Web-Anwendungen.
            Die Studierenden kennen die technischen Grundlagen, Konzepte, Architekturen
            und Technologien verteilter Systeme und Anwendungen sowie die g√§ngigen Methoden,
            Werkzeuge, Frameworks und Entwurfsmuster f√ºr die Entwicklung verteilter Anwendungen.

            ##### Methodenkompetenz

            Die Studierenden k√∂nnen die Konzepte, Werkzeuge und Methoden der Web-Programmierung
            anwenden und autonom Web-Anwendungen entwerfen, implementieren und testen. Die Studierenden
            k√∂nnen die Konzepte, Werkzeuge und Methoden der verteilten Systementwicklung anwenden und
            unter Einsatz von Frameworks und Entwurfsmustern einfache verteilte Anwendungen entwerfen,
            implementieren und testen.

            ##### Personale und soziale Kompetenz

            Die Studierenden k√∂nnen eigenst√§ndig verteilte Anwendungsarchitekturen erarbeiten.
            Sie k√∂nnen stichhaltig und sachangemessen √ºber Konzepte, eigene Entw√ºrfe und deren
            Implementierungen sowie die damit verbundenen Probleme argumentieren, eigene Umsetzungen
            plausibel darstellen und eventuelle Fehler nachvollziehbar gegen√ºber anderen begr√ºnden.


            ##### √úbergreifende Handlungskompetenz

            Die Studierenden k√∂nnen eigenst√§ndig aktuelle Methoden der Analyse, des Entwurfs und
            der Implementierung verteilter Systeme und Anwendungen f√ºr betriebliche Problemstellungen
            diskutieren, bewerten und anwenden.
        </div>
        <p>
            Da diese Beschreibung zwar den inhaltlichen Rahmen vorgibt, bei seiner Ausgestaltung
            aber viele Freiheiten bieten, findet sich auf der Seite rechts unsere Auslegung am
            Standort Karlsruhe. Diese lehnt sich an die Lernzeile von ‚ÄûWebprogrammierung‚Äù an und
            deckt sich an vielen Stellen mit dieser. Inhaltlich wird das Bild jedoch nun hin zur
            ganzheitlichen Konzeptionierung und Entwicklung moderner Anwendungen (nicht nur
            clientseitige Webanwendungen) erweitert.
        </p>
    </aside>
</section>

<section data-title="Didaktisches Modell">
    <article>
        <lsx-tab-pages>
            <lsx-tab-page title="Ablauf der Vorlesung">
                <p>
                    Abweichend zum dritten Semester folgt die Vorlesung einem  reduzierten ‚ÄûInverted Classroom Model‚Äú:
                </p>
                <lsx-ul class="mb-3">
                    <li>
                        Wie in Webprogrammierung begleitet das Onlineskript die Pr√§senztermine.
                    </li>
                    <li>
                        Es muss jedoch nicht jeder Termin durch ein Selbststudium vorbereitet werden.
                    </li>
                    <li>
                        Dementsprechen fehlen auch die Vorwissensabfrage und Lernkontrollen in Moodle.
                    </li>
                    <li>
                        Es gibt teilweise jedoch verbindliche Hausaufgaben, die auch der Vorbereitung dienen.
                    </li>
                    <li>
                        Insbesondere die Programmieraufgaben flie√üen als Leistungsnachweis in die Pr√ºfung ein.
                    </li>
                </lsx-ul>

                <lsx-grid-fluid class="p-0">
                    <lsx-row>
                        <lsx-col size="md">
                            <img src="01-intro/didaktisches-modell1.png" class="img-thumbnail d-block w-100" />
                        </lsx-col>
                        <lsx-col size="md">
                            <img src="01-intro/didaktisches-modell2.png" class="img-thumbnail d-block w-100" />
                        </lsx-col>
                    </lsx-row>
                </lsx-grid-fluid>
            </lsx-tab-page>
            <lsx-tab-page title="Vorlesungs√ºbersicht in Moodle">
                <img src="01-intro/moodle1.png" class="img-fluid img-thumbnail mx-auto d-block" />
            </lsx-tab-page>
        </lsx-tab-pages>
    </article>
    <aside class="markdown">
        ##### Ablauf der Vorlesung

        Die Vorlesung im vierten Semester folgt demselben Inverted-Classroom-Modell wie die Vorg√§ngerveranstaltung
        des dritten Semesters. Aufgrund das allgemein h√∂heren Workloads im vierten Semester wird das Model jedoch
        angepasst, so dass nur ein Teil der Pr√§senzveranstaltungen im Selbststudium vorbereitet werden muss. Dies
        spiegelt sich auch in den fehlenden Vorwissensabfragen und Lernkontrollen in Moodle wieder.
        
        Was bleibt ist jedoch das semesterbegleitende Onlineskript, anhand dessen die Inhalte √ºber die Vorlesungen
        hinaus eigenst√§ndig verinnerlicht werden m√ºssen. Neben inhaltlichen Erkl√§rungen finden sich hier insbesondere
        auch verbindliche Programmier√ºbungen, die Leistungsnachweis in die Pr√ºfungsnote einflie√üen. Denn die √úbungen
        sind ausschlaggebend daf√ºr, die vermittelten Konzepte anhand praktischer Fallbeispiele nachvollziehen und
        praktisch anwenden zu k√∂nnen.

        ##### Materialien in Moodle

        Der Screenshot auf der zweiten Seite zeigt den Moodleraum dieser Vorlesung. Jeder Kurs besitzt einen eigene
        Moodleraum, der von der jeweiligen Lehrperson mit Inhalten best√ºckt wird. Neben allgemeinen Punkten wie der
        Anwesenheitsliste (siehe unten) sind hier vor allem das Onlineskript und die Quellcodes zur Vorlesung verlinkt.
        Hinzu kommen ggf. zus√§tzliche Materialien f√ºr die Pr√§senzveranstaltungen unterhalb der jeweiligen √úberschriften.
        Neben den fehlenden Vorwissensabfragen und Lernkontrollen gibt es allerdings noch eine Abweichung zum Vorsemester:
        Die √úbungen, Fallbeispiele und Quizze sind nun in das Onlineskript integriert und werden daher nicht mehr separat
        in Moodle hochgeladen. Dadurch werden die Inhalte noch besser verzahnt und k√∂nnen nicht mehr so leicht √ºbersehen
        oder vergessen werden.

        ##### Elektronische Anwesenheitsliste

        Im vierten Semester f√ºhren wie wieder eine elektronische Anwesenheitsliste in Moodle. Wie gewohnt wird hierf√ºr
        am Anfang der Stunde ein QR-Code gezeigt, √ºber den sich die Teilnehmer*innnen w√§hrend der Stunde selbst eintragen
        k√∂nnen.
    </aside>
</section>

<section data-title="Pr√ºfungsaufgabe">
    <article>
        <lsx-tab-pages>
            <lsx-tab-page title="Allgemeines">
                <lsx-ul>
                    <li>√Ñhnliches Prinzip wie in Webprogrammierung im dritten Semester</li>
                    <li>Anstelle der Lernkontrollen gibt es jedoch Leistungsnachweise zu den √úbungen</li>
                    <li>Und das Aufgabenblatt enth√§lt abgeschlossene Aufgaben zu den jeweiligen Kapiteln</li>
                </lsx-ul>

                <table class="w-100 dhbw-fontsize-small dhbw-table-border" style="margin: 1.2rem 0 1.75rem 0;">
                    <thead>
                        <tr>
                            <th>Semester</th>
                            <th>Portfolioanteil</th>
                            <th>Abgabefrist</th>
                            <th>Gewichtung</th>
                        </tr>
                    </thead>

                    <!-- Drittes Semester -->
                    <tr style="background-color: #eaeaea; color: #888888;">
                        <td>3</td>
                        <td><b>Lernkontrollen in Moodle</b> ‚úîÔ∏è</td>
                        <td>Nach der ersten Vorlesung eines Kapitels</td>
                        <td>2</td>
                    </tr>
                    <tr style="background-color: #eaeaea; color: #888888;">
                        <td>3</td>
                        <td><b>Aufgabenblatt mit Programmierprojekt</b> ‚úîÔ∏è</td>
                        <td>Vor Beginn der Klausurphase</td>
                        <td>4</td>
                    </tr>

                    <!-- Viertes Semester -->
                    <tr style="background-color: white;">
                        <td>4</td>
                        <td><b>Leistungsnachweise der √úbungsaufgaben</b></td>
                        <td>Nach Abschluss des jeweiligen Kapitels</td>
                        <td>1</td>
                    </tr>
                    <tr style="background-color: white;">
                        <td>4</td>
                        <td><b>Aufgabenblatt mit Einzelaufgaben</b></td>
                        <td>Vor Beginn der Klausurphase</td>
                        <td>3</td>
                    </tr>
                </table>

                <lsx-info-box>
                    Jeder in der Tabelle genannte Pr√ºfungsanteil wird mit einer Punktzahl bewertet,
                    die in Prozent umgerechnet wird. Anhand der Teilprozente wird dann ein gewichteter
                    Mittelwert gebildet, um die Note zu ermitteln.
                </lsx-info-box>
            </lsx-tab-page>

            <lsx-tab-page title="Unterlagen in Moodle">
                <img src="01-intro/pf-moodle.png" class="img-fluid img-thumbnail mx-auto d-block" />
            </lsx-tab-page>

            <lsx-tab-page title="Aufgabenblatt">
                <div class="d-flex w-100" style="gap: 0.5em;">
                    <div class="flex-grow-1 flex-shrink-1">
                        <img src="01-intro/pf-blatt1.png" class="img-thumbnail d-block w-100" />
                    </div>
                    <div class="flex-grow-1 flex-shrink-1">
                        <img src="01-intro/pf-blatt2.png" class="img-thumbnail d-block w-100" />
                    </div>
                </div>
            </lsx-tab-page>
        </lsx-tab-pages>
    </article>
    <aside class="markdown">
        ##### Portfolioaufgaben im vierten Semester

        Auch im vierten Semester werden wir wieder ein Aufgabenblatt mit Portfolioaufgaben haben, das zusammen mit
        den Aufgaben des dritten Semesters ein Pr√ºfungsportfolio bildet. Die Vorgehensweise ist im Grunde dieselbe.
        An folgenden Stellen gibt es jedoch Abweichungen:

        * Anstelle der Lernkontrollen m√ºssen Leistungsnachweise f√ºr die √úbungsaufgaben in Moodle hochgeladen werden.
        Diese bestehen f√ºr jede der pr√ºfungsrelevanten √úbungen aus einem ca. ein bis zwei min√ºtigen Video (ungeschnitten),
        indem die L√∂sung vorgef√ºhrt und erkl√§rt werden muss.

        * Anstelle einer gro√üen Programmieraufgabe besteht das Aufgabenblatt aus kleineren, in sich geschlossenen
        Aufgaben zu jedem Kapitel. Zwar muss auch hier programmiert werden. Im Fokus liegt dabei aber jeweils nur
        ein Konzept wie z.B. REST-Webservices, das anhand eines √ºberschaubaren Fallbeispiels praktisch angewendet
        werden soll.

        Grunds√§tzlich sind auch diese Aufgaben in Eigenleistung zu bearbeiten. Die Aufgaben sind daher so gestellt,
        dass Fallbeispiele und L√∂sungswege frei gew√§hlt werden k√∂nnen.

        ##### Berechnung der Note

        √Ñhnlich wie in den meisten anderen Modulen gibt es f√ºr das Modul ‚ÄûEntwicklung verteilter Systeme‚Äú eine
        Modulnote im vierten Semester. Der Portfolioanteil des dritten Semesters erh√§lt keine eigene Note, sondern
        wird mit dem vierten Semester verrechnet. Die Studienordnung schreibt dabei vor, dass die beiden Vorlesungen
        entsprechend ihrer Anzahl Vorlesungsstunden in die Note einflie√üen m√ºssen. Konkret bedeutet das, dass das
        dritte Semester zu 60% und das vierte Semester zu 40% die Note bilden.

        Zur Berechnung der Note werden werden Portfolioartefakte einzeln mit Punkten bewertet. Aus diesen ergibt sich
        eine Prozentzahl, wie viele Punkte tats√§chlich erreicht wurden. Die Prozentzahlen werden dann einfach in einem
        gewichteten Durschnitt miteinander verrechnet. Anhand der Notenskala der DHBW ergibt sich daraus die eigentliche Note.
    </aside>
</section>

<section data-title="Ben√∂tigte Software">
    <article>
        <lsx-tab-pages>
            <lsx-tab-page title="Visual Studio Code">
                <lsx-grid-fluid>
                    <lsx-row class="mb-0">
                        <lsx-col size="md">
                            <p>
                                Als Entwicklungsumgebung werden wir Visual Studio Code, da der Atom-Editor leider nicht mehr
                                weiterentwickelt wird. üôÅ Es handelt sich um eine weit verbreitete IDE mit Unterst√ºtzung f√ºr
                                alle g√§ngigen Programmiersprachen und Betriebssysteme.
                            </p>
                        </lsx-col>
                    </lsx-row>

                    <lsx-row>
                        <lsx-col size="md">
                            <img src="01-intro/vscode-screenshot.png" class="img-thumbnail d-block" style="width: 100%; height: 100%;" />
                        </lsx-col>
                        <lsx-col size="md">
                            <!-- <lsx-youtube class="img-thumbnail embed-responsive" video="KMxo3T_MTvY"></lsx-youtube> -->
                            <div class="img-thumbnail embed-responsive" style="width: 100%; height: 100%;">
                                <iframe class="d-block" style="width: 100%; height: 100%;" src="https://www.youtube-nocookie.com/embed/KMxo3T_MTvY?rel=0&amp;showinfo=0" allowfullscreen></iframe>
                            </div>
                        </lsx-col>
                    </lsx-row>

                    <lsx-row>
                        <lsx-col size="md">
                            <lsx-ul>
                                <li>
                                    Weit verbreitete IDE f√ºr alle g√§ngigen Betriebssysteme
                                </li>
                                <li>
                                    Geschrieben in HTML und JavaScript (basierend auf der Chrome Webengine)
                                </li>
                                <li>
                                    Open-Source von Microsoft (Made in Switzerland) üá®üá≠
                                </li>
                            </lsx-ul>
                        </lsx-col>
                    </lsx-row>
                </lsx-grid-fluid>
            </lsx-tab-page>

            <lsx-tab-page title="Node.js">
                <lsx-grid-fluid>
                    <lsx-row class="mb-0">
                        <lsx-col size="md">
                            <p>
                                F√ºr die Backendprogrammierung werden wir Node.js als JavaScript-Laufzeitumgebung nutzen.
                                Es handelt sich um eine weit verbreitete Runtime f√ºr nebenl√§ufige verteilte Anwendungen
                                auf Basis der V8-Enginge des Google Chrome Browsers.
                            </p>
                        </lsx-col>
                    </lsx-row>

                    <lsx-row>
                        <lsx-col size="md">
                            <img src="01-intro/node.js-logo.svg" class="img-thumbnail d-block" style="width: 100%; height: 100%;" />
                        </lsx-col>
                        <lsx-col size="md">
                            <img src="01-intro/node.js-screenshot.png" class="img-thumbnail d-block" style="width: 100%; height: 100%;" />
                        </lsx-col>
                    </lsx-row>

                    <lsx-row>
                        <lsx-col size="md">
                            <lsx-ul>
                                <li>
                                    Beinhaltet den Node Package Manager zur einfachen Installation aller f√ºr ein Projekt ben√∂tigten Bibliotheken
                                </li>
                                <li>
                                    Liefert uns alle Build- und Testwerkzeuge, die wir w√§hrend der Entwicklung ben√∂tigen
                                </li>
                                <li>
                                    Beinhaltet eine komplette JavaScript-Laufzeitumgebung f√ºr die serverseitige Programmierung
                                </li>
                            </lsx-ul>
                        </lsx-col>
                    </lsx-row>
                </lsx-grid-fluid>
            </lsx-tab-page>

            <lsx-tab-page title="API-Testwerkzeug">
                <lsx-grid-fluid>
                    <lsx-row class="mb-0">
                        <lsx-col size="md">
                            <p>
                                W√§hrend der Entwicklung kommt es immer wieder vor, dass wir sowohl unser eigenen als auch
                                fremden entfernte Services testen m√∂chten. Hierf√ºr ben√∂tigen wir einen beliebigen ‚ÄûAPI Client‚Äù,
                                der uns hierbei unterst√ºtzt.
                            </p>
                        </lsx-col>
                    </lsx-row>

                    <lsx-row>
                        <lsx-col size="md">
                            <div class="img-thumbnail">
                                <lsx-youtube video="Fbzmi1Q5hQU"></lsx-youtube>
                            </div>
                        </lsx-col>
                        <lsx-col size="md">
                            <div class="img-thumbnail">
                                <lsx-youtube video="kPO8Km_EYd4"></lsx-youtube>
                            </div>
                        </lsx-col>
                    </lsx-row>

                    <lsx-row>
                        <lsx-col size="md">
                            <lsx-ul>
                                <li>
                                    <a href="https://httpie.io/" target="_blank">httpie</a>:
                                    Besonders leicht zu nutzen. Web-, Desktop- und Kommandozeilenversion verf√ºgbar.
                                </li>
                                <li>
                                    <a href="https://www.usebruno.com/" target="_blank">bruno</a>:
                                    Newcommer unter den API-Clients. Collections k√∂nnen leicht mit Git versioniert werden.
                                </li>
                                <li>
                                    <a href="https://hoppscotch.io/" target="_blank">hoppscotch</a>:
                                    Besonders leistungsf√§hig vergleichbar mit den gro√üen kommerziellen Anbietern.
                                </li>
                            </lsx-ul>
                            <p>
                                httpie und hoppscotch k√∂nnen direkt im Browser ausgef√ºhrt werden.
                                Sie haben die freie Wahl. Alle drei Clients sind f√ºr die Vorlesung geeignet.
                            </p>
                        </lsx-col>
                    </lsx-row>
                </lsx-grid-fluid>
            </lsx-tab-page>

            <lsx-tab-page title="Gitpod">
                <lsx-grid-fluid>
                    <lsx-row class="mb-0">
                        <lsx-col size="md">
                            <p>
                                Falls Sie auf Ihrem Computer keine zus√§tzliche Software installieren k√∂nnen oder sich bestimmte
                                Dienste √ºber das DHBW-Netzwerk nicht erreichen lassen, k√∂nnen Sie auf die Gitpod Online-IDE ausweichen.
                                Diese bietet eine IDE und Linux-Umgebung direkt in Ihrem Browser.
                            </p>
                        </lsx-col>
                    </lsx-row>

                    <lsx-row>
                        <lsx-col size="md">
                            <img src="01-intro/github-screenshot.png" class="img-thumbnail d-block" style="width: 100%; height: 100%;" />
                        </lsx-col>
                        <lsx-col size="md">
                            <img src="01-intro/gitpod-screenshot.png" class="img-thumbnail d-block" style="width: 100%; height: 100%;" />
                        </lsx-col>
                    </lsx-row>

                    <lsx-row>
                        <lsx-col size="md">
                            <lsx-ul>
                                <li>
                                    IDE und Linux-Umgebung mit vorinstallierten Werkzeugen komplett in der Cloud.
                                </li>
                                <li>
                                    Keine Registrierung erforderlich, sofern Sie bereits einen GitHub Account besitzen.
                                </li>
                                <li>
                                    Quellcodes m√ºssen in einem √∂ffentlich sichtbare Git-Repository auf GitHub liegen.
                                </li>
                            </lsx-ul>
                        </lsx-col>
                    </lsx-row>
                </lsx-grid-fluid>
            </lsx-tab-page>
        </lsx-tab-pages>
    </article>
    <aside class="markdown">
        Ein Handwerker braucht zum Arbeiten sein Werkzeug. Das ist beim Programmieren nat√ºrlich nicht anders.
        Und genau wie beim Handwerkszeug gibt es eine geradezu unendliche Auswahl an Editoren, Frameworks,
        Datenbanken und Servern, die man zur Entwicklung seiner Anwendungen nutzen kann. In der Vorlesung
        haben wir uns daher auf folgende Werkzeuge festgelegt.

        ##### Visual Studio Code

        Visual Studio Code hat sich in den letzten Jahren zu einer der beliebtesten und flexibelsten IDEs
        √ºberhaupt entwickelt. Im Gegensatz zu klassischen IDEs wit Eclipse, NetBeans oder dem gro√üen Bruder
        Visual Studio, ist Visual Studio Code im Kern jedoch √§u√üert kompakt und dank der durchg√§ngigen Verwendung
        von Web-Technologien leicht anpass- und erweiterbar. Ein Blick in den Extension Marketplace wird dies
        best√§tigen. 

        <lsx-info-box type="warning">
            <b>Vorsichtig:</b> <i>A fool with a tool is still a fool.</i> Zu viele Extensions st√∂ren eher,
            als dass Sie bei der Probleml√∂sung helfen.
        </lsx-info-box>

        [https://code.visualstudio.com/](https://code.visualstudio.com/){target=blank}

        ##### Node.js und npm

        Die in der Vorlesung besprochenen Konzepte sind an keine konkrete Programmiersprache gebunden.
        Eine in j√ºngerer Zeit vor allem bei Webentwicklern zunehmend beliebte Sprache ist jedoch JavaScript,
        das dank Laufzeitumgebungen wie Node.js oder Bun inzwischen auch au√üeralb des Browsers l√§uft.
        In der Vorlesung werden wir daher unsere j√ºngst erworbenen JavaScript-Kenntnisse vertiefen und
        JavaScript auch f√ºr die Backendprogrammierung nutzen.

        [https://nodejs.org/](https://nodejs.org/){target=blank}

        ##### API-Testwerkzeug

        W√§hrend der Entwicklung ist es oft erforderlich, auf einem entfernten Host laufende Dienste zu
        testen, noch bevor eine vollst√§ndige Clientanwendung daf√ºr entwickelt wurde. Doch selbst wenn
        ein dedizierter Client (der Begriff wird im n√§chsten Kapitel noch definiert) zur Verf√ºgung steht,
        kann es sinnvoll sein, einen entfernten Service direkt zu testen, um die ausgetauschten Daten
        direkt sehen zu k√∂nnen. Hierf√ºr gibt es eine Vielzahl von Werkzeugen, von denen Postman und Insomnia
        die zwei beliebtesten, kommerziellen Varianten sind. Beide sind jedoch an ein Cloud-Abo des jeweiligen
        Anbieters gebunden und werden inzwischen nicht mehr (Postman) oder nur sehr versteckt (Insomnia)
        als Offline-Werkzeug angeboten.

        In der Vorlesung wollen wir uns nicht von derartigen Gesch√§ftsgebahren abh√§ngig machen und setzen
        eher auf vollst√§ndig quelloffene und datenschutzkonforme L√∂sungen. Die folgenden Werkzeuge k√∂nnen
        unter diesen Gesichtspunkten bedenkenlos empfohlen werden:

        * [httpie](https://httpie.io/){target=_blank}
        * [bruno](https://www.usebruno.com/){target_blank}
        * [hoppscotch](https://hoppscotch.io/){target_blank}

        Welches Werkzeug Sie verwenden spielt f√ºr die Vorlesung keine Rolle und h√§ngt √ºberwiegend von
        pers√∂nlichen Anforderungen und Vorlieben ab. httpie und HOPPSCOTCH bieten den Vorteil, ohne
        Installation auf der jeweiligen Seite direkt im Browser ausgef√ºhrt werden zu k√∂nnen. Wenn Sie
        keine zus√§tzliche Software installieren wollen oder k√∂nnen, ist dies eine gute Wahl. Alle haben
        jedoch gemeinsam, dass es eine vollwertige Desktopversion f√ºr alle g√§ngigen Betriebssysteme gibt,
        in der beliebig viele Projekte lokal verwaltet und dauerhaft gespeichert werden k√∂nnen. Postman
        und Insomnia bieten diesen Vorteil leider nicht mehr.

        ##### Gitpod

        Rein optional aber durchaus eine Alternative, um die Installation lokaler Softwarepakete auf
        Ihrem Computer zu vermeiden. Bei Gitpod handelt es sich um einen in der Cloud laufenden Ableger
        von Visual Studio Code, der neben der IDE auch eine vollst√§ndige Linux-Umgebung mit vorinstallierten
        Werkzeugen von Docker oder Node.js bietet. Einzige Voraussetzung hierf√ºr ist, dass der zu bearbeitende
        Quellcode in einem √∂ffentlich sichtbaren Git-Repository auf GitHub liegt. Denn dann kann Gitpod f√ºr
        pers√∂nliche Projekte kostenlos genutzt werden. Die Anmeldung erfolgt mit dem pers√∂nlichen GitHub Account.
        Zwar handelt es sich um ein kommerzielles Angebot, die Plattform ist jedoch vollst√§ndig quelloffen.

        [https://gitpod.io/](https://gitpod.io/){target=blank}
    </aside>
</section>
