<section data-use-template="deckblatt" data-title="Anhang"></section>

<!-- ====== -->
<!-- DOCKER -->
<!-- ====== -->
<section data-use-template="teilkapitel" data-titel="Docker"></section>

<section data-title="Docker in aller Kürze">
    <section data-title="Was ist Docker?">
        <article>
            <div class="markdown limited-width m-auto mb-4">
                Docker ist eine **Laufzeitumgebung zur Isolation laufender Prozesse**
                unter Linux. (Aktuelle Versionen von Microsoft Windows unterstützen diese
                Funktion inzwischen auch). Die Programme werden hierfür mit allen für ihre
                Ausführung benötigten Systembibliotheken und Hilfsdateien in binäre Filesystem
                Images (hier **Container Image** genannt) verpackt und dann durch den
                Docker Daemon also sog. **Container** ausgeführt, wobei das Wort
                Container hier die Isolation der Prozesse verdeutlichen soll.
        
                Intern werden hierfür verschiedene Mechanismen des Linux-Kernels genutzt,
                um den Programmen vorzugaukeln, dass sie die einzigen laufenden Programme
                innerhalb des Betriebssystems wären. Gute Container Images starten daher
                tatsächlich nur einen Prozess, der automatisch die **Prozess-ID 1**
                bekommt.
        
                Darüber hinaus virtualisiert Docker das Netzwerk sowie den Massenspeicher,
                um die Container noch weiter voneinander zu isolieren. Zusammengehörige
                Container können über ein **virtuelles Netzwerk** untereinander
                kommunizieren und einzelne Ports können vom Host an die Container
                weitergeleitet werden.
        
                Wichtig zu verstehen ist, dass Container ,,immutabel'' sind, was bedeutet,
                dass sie zwar Dateien in ihrem virtuellen Dateisystem erzeugen können,
                diese bei einem Neustart des Containers aber verloren gehen. Über sog.
                **Volumes** können stattdessen externe Massenspeicher angebunden
                werden, um persistente Daten abzulegen.
            </div>
        
            <div class="d-flex align-items-stretch" style="gap: 1em;">
                <img src="99-anhang/docker/docker-1.png" class="d-block w-100 img-thumbnail"/>
                <img src="99-anhang/docker/docker-2.png" class="d-block w-100 img-thumbnail"/>
            </div>
        </article>
    </section>
    
    <section data-title="Container Images bauen mit einem Dockerfile">
        <article class="centered-content">
            <div class="limited-width">
                <div class="markdown">
                    Um ein sog. Image zu bauen, das von Docker als Container ausgeführt werden
                    kann, muss im Quellcode-Verzeichnis der Anwendung eine Datei namens
                    <span class="fn">Dockerfile</span> angelegt werden. Ihre Aufgabe ist zu
                    beschreiben, aus welchen Inhalten (also aus welchen Dateien) sich das Image
                    zusammensetzen soll.
            
                    Hierfür wird in der Regel aus dem „Docker Hub” (oft auch „Registry” genannt,
                    was aber nicht mit der „Node.js Registry” verwechselt werden darf) ein vorhandenes
                    Image referenziert und um eigene Dateien erweitert. Als Basis-Image kann dann
                    entweder ein minimales Betriebssystem-Image (z.B. Debian oder Alpine Linux)
                    oder eine vorkonfigurierte Laufzeitumgebung wie Node.js, Python, … (die selbst
                    auf einem der genannten Betriebssystem-Images basiert) ausgewählt werden.
                </div>
            
                <div class="card p-3 mt-3 mb-3 bg-light">
                    <table class="table table-striped">
                        <tr>
                            <td>
                                <src-code language="docker">FROM node:17-alpine</src-code>
                            </td>
                            <td>
                                Node.js 17.x als Basis-Image verwenden
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <src-code language="docker">ENV NODE_ENV=production HOST=::</src-code>
                            </td>
                            <td>
                                Zur Ausführung benötigte Umgebungsvariablen definieren
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <src-code language="docker">WORKDIR /app</src-code>
                            </td>
                            <td>
                                Wechseln des für die folgenden Befehle verwendeten Arbeitsverzeichnisses im Image
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <src-code language="docker">COPY package.json package-lock.json ./</src-code>
                            </td>
                            <td>
                                Quellcode-Dateien in das eben ausgewählte Arbeitsverzeichnis kopieren
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <src-code language="docker">RUN npm install</src-code>
                            </td>
                            <td>
                                Ausführen eines Befehls, um die benötigten Node.js-Module zu installieren
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <src-code language="docker">COPY src ./src</src-code>
                            </td>
                            <td>
                                Am Schluss den eigentlichen Quellcode in das Filesystem Image kopieren
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <src-code language="docker">EXPOSE 3000/tcp</src-code>
                            </td>
                            <td>
                                Dokumentieren, dass der Container auf TCP-Port 3000 einen Serverdienst bereitstellt
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <src-code language="docker">ENTRYPOINT ["node", "src/index.js"]</src-code>
                            </td>
                            <td>
                                Definition des zur Ausführung des Containers zu startenden Programms
                            </td>
                        </tr>
                    </table>
                </div>
            
                <div class="markdown">
                    Die Reihenfolge der Anweisungen ist wichtig, da die meisten Anweisungen ein neues,
                    sog. „Filesystem Layer” erzeugen, in dem die durch die Anweisung verursachten
                    Änderungen an der Dateistruktur festgehalten werden. Indem sich weniger oft ändernde
                    Dateien an den Anfang gestellt werden, kann die Zeit zum Neubauen eines Containers
                    und die damit verbrauchte Bandbreite deutlich reduziert werden.
                </div>
            </div>
        </article>
    </section>
    
    <section data-title="Netzwerkvirtualisierung mit Docker">
        <article>
            <div class="markdown">
                * Standardmäßig werden Docker Container vollständig isoliert ausgeführt.
                * Sie können zwar auf das Internet zugreifen, selbst aber keine Verbindungen entgegennehmen.
                * Hierfür muss entweder eine Portweiterleitung oder ein virtuelles Netzwerk eingerichtet werden.
                * Eine Portweiterleitung leitet an den Host gerichtete TCP-Anfragen an einen Container weiter.
                * Ein virtuelles Netzwerk hingegen ermöglicht es mehreren Containern, untereinander zu kommunizieren.
            </div>
        
            <div class="d-flex align-items-stretch w-100" style="gap: 1em;">
        
            <div class="card w-100">
                <div class="card-header fw-bold">
                    Start eines Containers mit Portweiterleitung
                </div>
                <div class="card-body p-3">
                    <p>
                        <span class="cmd">docker run -d --name mongodb -p 27777:27017 mongo</span>
                    </p>
                    <table class="table table-striped">
                        <tr>
                            <td>
                                <code>docker run</code>
                            </td>
                            <td>
                                Subkommando zum Starten eines Containers
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>-d</code>
                            </td>
                            <td>
                                Container im Hintergrund ausführen
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>--name mongodb</code>
                            </td>
                            <td>
                                Festen Namen für den Container verwenden
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>-p 27777:27017</code>
                            </td>
                            <td>
                                Anfragen an den TCP-Port 27777 des Hosts an Port 27017 des Containers weiterleiten
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <code>mongo</code>
                            </td>
                            <td>
                                Name des auszuführenden Images
                            </td>
                        </tr>
                    </table>
                </div>
            </div>
        
            <div class="card w-100">
                <div class="card-header fw-bold">
                    Verbinden mehrerer Container über ein virtuelles Netzwerk
                </div>
                <div class="card-body p-3">
                    <p>
                        <span class="cmd">docker net create beispiel</span> <br />
                        Virtuelles Netzwerk mit dem Namen <span class="cmd">beispiel</span> erzeugen
                    </p>
                    <p>
                        <span class="cmd">docker run -d --name mongodb --net beispiel mongo</span> <br />
                        Container im Hintergrund starten und diesen mit dem Beispiel-Netzwerk verbinden.
                        Über das virtuelle Netzwerk können die im Container laufenden Serverdienste
                        aufgerufen werden. Von Außen ist der Container allerdings nicht erreichbar.
                    </p>
                    <p>
                        <span class="cmd">docker run -d --name backend --net beispiel -p 3000:3000 adressbuch-backend</span> <br />
                        Weiteren Container starten und sowohl mit dem Beispiel-Netzwerk verbinden als
                        auch eine Portweiterleitung definieren. Warum? Weil das Backend unserer Anwendung
                        vom Browser aus aufrufbar sein muss, über das virtuelle Netzwerk jedoch auch mit der
                        Datenbank kommunizieren soll.
                    </p>
        
                    <h3>Service Discovery</h3>
                    <p>
                        Über den Domainnamen <span class="fn">mongo</span> kann der
                        Backend-Service die interne IP-Adresse des Datenbank-Containers ermitteln.
                    </p>
        
                    <h3>Load Balancing</h3>
                    <p>
                        Wurden mehrere Instanzen des Datenbank-Containers gestartet, verteilt
                        Docker die Anfragen automatisch auf die unterschiedlichen Instanzen,
                        indem es bei jedem DNS Lookup die IP-Adresse einer anderen Instanz
                        zurück liefert.
                    </p>
                </div>
            </div>
        
            </div>
        </article>
    </section>
    
    <section data-title="Mehrere Container orchestrieren mit Docker Compose">
        <article class="centered-content">
            <div style="max-width: 70em;">
                <div class="markdown">
                    Da die Befehlsketten zur Ausführung und Verknüpfung mehrerer Docker-Container
                    mitunter sehr komplex werden können, lässt sich ein Setup aus zusammehängenden
                    Containern auch deklarativ in einer Datei namens <span class="fn">docker-compose.yml</span>
                    beschreiben. Das Werkzeug **Docker Compose** übernimmt dann den Start und auch die
                    Beendigung aller Container in der richtigen Reihenfolge. Außerdem kann damit eine
                    einfache Skalierung durch Starten mehrerer, paralleler Containerinstanzen erreicht
                    werden. Mit **Docker Swarm** kann eine so definierte Anwendung auch ganz einfach
                    in einem Cluster produktiv deployed werden.
                </div>
            
                <div class="card p-3 mt-3 mb-3 bg-light">
                    <table class="table table-striped">
                        <tr>
                            <td>
                                <source-code language="yaml">
                                    version: "3.9"
                                </source-code>
                            </td>
                            <td>
                                Definition der Version des Docker-Compose-Dateiformats
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <source-code language="yaml">
                                    volumes:
                                        dbdata:
                                        dbconfig:
                                </source-code>
                            </td>
                            <td>
                                Aufzählung von sog. Volumes zur Ablage persistenter Daten
                            </td>
                        </tr>
                        <tr>
                            <td>
                                <source-code language="yaml">
                                    services:
                                </source-code>
                            </td>
                            <td>
                                Beginn der Service-Definitionen mit den zu startenden Containern
                            </td>
                        </tr>
                        <tr>
                            <td style="padding-left: 3em;">
                                <source-code language="yaml">
                                        # MongoDB-Datenbank
                                        mongodb:
                                            image: mongo
                                            restart: always
                                            environment:
                                                MONGO_INITDB_ROOT_USERNAME: dbuser
                                                MONGO_INITDB_ROOT_PASSWORD: dbpass
                                            volumes:
                                                - dbdata:/data/db
                                                - dbconfig:/data/configdb
                                </source-code>
                            </td>
                            <td>
                                <p>
                                    Definition des Containers <span class="scr">mongodb</span> zur Ausführung
                                    des Images <span class="scr">mongo</span> aus dem Docker Hub.
                                </p>
                                <p>
                                    Bei einem Absturz wird der Container automatisch neugestartet (Resilienz).
                                </p>
                                <p>
                                    Im Container werden zwei Umgebungsvariablen mit Konfigurationswerten für
                                    einen beim ersten Start anzulegenden Admin-Benutzer definiert.
                                </p>
                                <p>
                                    Durch die oben benannten Volumes werden die Inhalte der beiden Verzeichnisse
                                    <span class="fn">/data/db</span> und <span class="fn">/data/configdb</span>
                                    mit dem Host geteilt und bleiben somit nach einem Neustart des Containers
                                    erhalten.
                                </p>
                            </td>
                        </tr>
                        <tr>
                            <td style="padding-left: 3em;">
                                <source-code language="yaml">
                                    # Adressbuch-Backend (Produktivmodus)
                                    backend:
                                        build:
                                            context: ./Backend
                                        depends_on:
                                            - mongodb
                                        restart: always
                                        environment:
                                            HOST: "::"
                                            PORT: 3000
                                            MONGODB: mongodb://dbuser:dbpass@mongodb:27017/
                                        deploy:
                                            replicas: 3
                                </source-code>
                            </td>
                            <td>
                                <p>
                                    Definition des Containers <span class="scr">backend</span>, der aus dem
                                    <span class="fn">Dockerfile</span> im Unterverzeichnis <span class="fn">Backend</span>
                                    gebaut wird.
                                </p>
                                <p>
                                    Der Container kann erst gestartet werden, wenn der Container mit dem Namen
                                    <span class="scr">mongodb</span> läuft.
                                </p>
                                <p>
                                    Bei einem Absturz wird der Container automatisch neugestartet (Resilienz).
                                </p>
                                <p>
                                    Im Container werden drei Umgebungsvariablen mit den Verbindungsdaten zur
                                    Mongo-Datenbank definiert.
                                </p>
                                <p>
                                    Standardmäßig werden drei Instanzen des Containers gestartet.
                                </p>
                            </td>
                        </tr>
                    </table>
                </div>
            </div>    
        </article>
    </section>
    
    <section data-title="Typische Befehle zur Verwendung von Docker">
        <article class="centered-content">
            <div class="d-flex align-items-stretch w-100" style="gap: 1em;">
                <!-- Docker -->
                <div class="card w-100">
                    <div class="card-header fw-bold">
                        Docker
                    </div>
                    <div class="card-body p-3 markdown">
                        * <span class="cmd">docker help</span>: <br />
                        Hilfe! 🤕
                    
                        * <span class="cmd">docker &lt;kommando&gt; help</span>: <br />
                            Hilfe zu einem Docker-Subkommando
                    
                        * <span class="cmd">docker run -d &lt;container&gt;</span>: <br />
                            Start eines Containers im Hintergrund
                    
                        * <span class="cmd">docker run -it &lt;container&gt; &lt;befehl&gt;</span>: <br />
                            Ausführen eines interaktiven Befehls in einem neuen Container
                    
                        * <span class="cmd">docker container ls</span>: <br />
                            Alle laufenden Container anzeigen
                    
                        * <span class="cmd">docker container stop &lt;name&gt;</span> <br />
                            Beenden eines laufenden Containers
                    
                        * <span class="cmd">docker logs &lt;name&gt;</span> <br />
                            Konsolen- und Log-Ausgaben eines Containers zeigen
                    
                        * <span class="cmd">docker net create &lt;netwerk&gt;</span> <br />
                            Neues, virtuelles Netzwerk zur Kommunikation mehrerer Container untereinander erstellen
                    
                        * <span class="cmd">docker system prune</span> <br />
                            Nicht mehr benötigte Ressourcen freigeben (wichtig!)
                    
                        * <span class="cmd">docker volume prune</span> <br />
                            Nicht mehr verwendete Volumes löschen, da diese sehr viel Speicher belegen können.
                
                        <lsx-info-box type="warning" title="Achtung, Datenverlust!">
                            Es werden alle Volumes gelöscht, die aktuell von keinem laufenden Container
                            genutzt werden. Dadurch sind ggf. dann auch die persistenten Daten der MongoDB
                            weg, wenn diese bei Ausführung des Befehls gerade nicht läuft.
                        </lsx-info-box>
                    </div>
                </div>
    
                <!-- Docker Compose -->
                <div class="card w-100">
                    <div class="card-header fw-bold">
                        Docker Compose
                    </div>
                    <div class="card-body p-3 markdown">
                        * <span class="cmd">docker compose up</span>:  <br />
                        Start mehrerer zusammengehöriger Docker Container **im Vordergrund**
                
                        * <span class="cmd">docker compose up -d</span>: <br />
                            Start mehrerer zusammengehöriger Docker Container **im Hintergrund**
                    
                        * <span class="cmd">docker compose down</span>:  <br />
                            Stoppen der mit Docker Compose gestarteten Container
                    
                        * <span class="cmd">docker compose build</span>:  <br />
                            Neubauen aller Container Images anhand ihres <span class="fn">Dockerfile</span>
                    </div>
                </div>
            </div>
        </article>
    </section>    
</section>

<section data-title="Übungsaufgaben" data-background-color="rgb(231, 221, 141)">
    <!-- TODO -->
    <section data-title="Aufgabe 1: Ein kleines Docker-Quiz">
        <article>
            <lsx-tab-pages>
                <lsx-tab-page title="Aufgabe 1.1">
                    <lsx-quiz>
                        <lsx-exercise title="XXX">
                            xxx
                        </lsx-exercise>
                    </lsx-quiz>
                </lsx-tab-page>

                <lsx-tab-page title="Aufgabe 1.2">
                    <lsx-quiz>
                        <lsx-exercise title="XXX">
                            xxx
                        </lsx-exercise>
                    </lsx-quiz>
                </lsx-tab-page>
            </lsx-tab-pages>
        </article>
        <aside>
            <p>
                Was wäre die moderne Softwareentwicklung ohne Docker und ohne Anwendungscontainer?
                Auch der Betrieb der meisten verteilten Anwendungen wäre inzwischen völlig undenkbar.
                Hier können Sie Ihr Wissen darüber überprüfen.
            </p>
            <img src="shared/quiz.png" class="img-fluid d-block" style="max-width: 20em;"/>
            <p>
                <small>
                    Bildnachweis:
                    <a href="https://pixabay.com/illustrations/quiz-tiles-letters-red-game-test-2058883/" target="_blank">Pixabay: 905513</a>
                </small>
            </p>
        </aside>
    </section>

    <section data-title="Aufgabe 2: Wir erkunden Docker" data-background-color="rgb(231, 221, 141)">
        <article>
            <div class="markdown">
                Öffnen Sie den folgenden Link zum Starten der GitPod Online IDE mit den Quellcodes
                zur Vorlesung. Neben einem an Visual Studio Code angelehnten Code-Editor und einer
                Linux-Umgebung mit Node.js und anderen Werkzeugen, stellt diese Ihnen auch Docker
                und Docker Compose zur Verfügung. Sie können somit Docker ausprobieren oder gar am
                Portfolioprojekt der Vorlesung arbeiten, ohne etwas auf Ihrem Rechner installieren
                zu müssen. Im Gegenzug benötigen Sie allerdings eine dauerhafte Internetverbindung,
                um programmieren zu können.
            
                <a href="https://www.gitpod.io/#https://github.com/DennisSchulmeister/dhbwka-wwi-vertsys-2022-quellcodes" target="_blank" class="fw-bold">Online IDE: Quellcodes zur Vorlesung</a>
            
                ![Gitpod](99-anhang/docker/gitpod-2.png){.img-thumbnail .img-responsive .limited-width}
            </div>
    
            <lsx-tab-pages>
                <lsx-tab-page title="Anwendung starten" class="markdown">
                    Falls noch nicht geschehen, öffnen Sie über das Hamburger-Menü oben links ein
                    neues Terminal. In diesem Wechseln Sie mit dem <span class="cmd">cd</span>-Befehl
                    in das Adressbuch-Beispiel:
                
                    <span class="cmd">cd Beispielanwendung\ Adressbuch</span>
                
                    Um nicht den gesamten Befehl eintippen zu müssen, genügt es, wenn Sie nur die
                    ersten paar Buchstaben tippen und dann die <kbd>Tab</kbd>-Taste drücken, um
                    die sog. „Command Completion” der Konsole auszuführen. Da es mehrere Verzeichnisse
                    mit dem Wort „Beispielanwendung” am Anfang gibt, drücken Sie anschließend
                    <kbd>A</kbd> und dann wieder <kbd>Tab</kbd>, damit sich der Befehl vervollständigt.
                
                    Das Tolle an GitPod ist, dass innerhalb des Terminals ausgeführte Serverdienste
                    wie z.B. der Backend-Service der Anwendung über eine öffentliche URL testbar
                    gemacht werden. Dies benötigen wir, damit die Frontend-Anwendung (die ja innerhalb
                    des Browsers und somit nicht in der Linux-Umgebung der IDE läuft) auf das Backend
                    zugreifen kann. Im ersten Schritt geht es daher darum, die URL des Backend-Services
                    zu ermitteln und in der Umgebungsvariable `API_KEY` abzulegen. Gehen Sie hierfür
                    wie folgt vor:
                
                    1. Starten Sie alle Container mit dem Befehl <br />
                    <span class="cmd">docker-compose -f docker-compose.dev.yml up -d</span>
                
                    1. Öffnen Sie links in der Sidebar den „Remote Explorer”.
                
                    1. Schalten Sie alle Ports frei, um eine öffentliche URL zu erzeugen.
                
                    1. Öffnen Sie die Vorschau für den Port 3000.
                
                    1. Kopieren Sie sich die URL des Services aus dem Vorschaufenster.
                
                    1. Erzeugen Sie die Umgebungsvariable im Terminal mit folgendem Befehl: <br />
                    <span class="cmd">export API_URL=https://3000-….gitpod.io</span>
                
                    1. Starten Sie anschließend mit folgenden Befehlen alle Container neu: <br />
                    <span class="cmd">docker-compose -f docker-compose.dev.yml down</span> <br />
                    <span class="cmd">docker-compose -f docker-compose.dev.yml up -d</span> <br />
                
                    1. Öffnen Sie anschließend die Vorschau für den Remote Port 8080.
                    Wenn Sie wollen können Sie die URL aus dem Vorschaufenster in
                    einen neuen Browser-Tab einfügen. Auf jeden Fall testen Sie, ob
                    sich die App fehlerfrei bedienen lässt.
                </lsx-tab-page>
    
                <lsx-tab-page title="Quellcode ändern" class="markdown">
                    Nehmen Sie nun eine Änderung am Backend-Quellcode vor und laden
                    Sie die Vorschauseite neu. Beobachten Sie dabei, dass die
                    Änderung sofort aktiv wurde. Anschließend nehmen Sie eine
                    Änderung am Frontend-Quellcode vor und laden Sie Vorschseite
                    wieder neu. Beobachten Sie auch hier, dass die Änderung ohne
                    manuelles Eingreifen sofort aktiv wurde.
                </lsx-tab-page>
    
                <lsx-tab-page title="Docker-Compose-File anpassen" class="markdown">
                    Versuchen Sie abschließend, mit der Datei <span class="fn">docker-compose.prod.yml</span>
                    die Produktivversion der Anwendung zu starten. Verschen Sie dann,
                    die in der Entwicklungsversion definierte Mongo-Admin-Oberfläche
                    in die Produktiversion aufzunehmen. Welche Schritte sind hierür
                    notwendig?
                </lsx-tab-page>
            </lsx-tab-pages>
        </article>
        <aside>
            <p>
                Die vorherigen Seiten haben die wichtigsten Befehle rund um Docker sehr kurz
                zusammengefasst. In dieser Aufgabe wollen wir sie nun anwenden, um Docker im
                Einsatz zu sehen und seine Funktionalitäten besser zu verstehen.
            </p>
            <img src="shared/github_atom.png" class="img-fluid d-block"/>
            <p>
                <small>
                    Bildnachweis:
                    <a href="https://atom.io/" target="_blank">Atom Webseite</a>
                </small>
            </p>
        </aside>
    </section>
</section>

<!-- ============== -->
<!-- RECHTSHINWEISE -->
<!-- ============== -->
<section data-use-template="teilkapitel" data-titel="Rechtshinweise"></section>

<section data-background-color="rgb(158, 203, 231)">
    <h1>Kontakt und Lizenz</h1>
    <article>
        <h4>Creative Commons Namensnennung 4.0 International</h4>
        <ul>
            <li>Beliebiges Teilen ist erlaubt</li>
            <li>Die Unterlagen dürfen bearbeitet und verändert werden</li>
            <li>Wenn die Namens- und Urheberangaben erhalten bleiben</li>
            <li>Und keine weiteren Einschränkungen auferlegt werden</li>
        </ul>
        <span style="font-size: 400px; color: white;" class="dhbw-text-shadow" >§</span>
    </article>
    <aside style="font-size: 80%">
        <h4>Kontaktdaten</h4>
        <p>
            Prof. Dr. Michael Decker<br/>
            E-Mail: <a data-email-address>michael.decker dhbw-karlsruhe.de</a><br/>
        </p>
        <p>
            Dennis Schulmeister-Zimolong<br/>
            E-Mail: <a data-email-address>dhbw windows3.de</a><br/>
        </p>

        <h4>Urheberrecht und Lizenzvereinbarung</h4>
        <p>
            © 2024 Prof Dr. Michael Dacker und Dennis Schulmeister-Zimolong, DHBW Karlsruhe<br/>
            <a href="https://github.com/DennisSchulmeister/dhbwka-wwi-vertsys-2024-skript" target="_blank">https://github.com/DennisSchulmeister/dhbwka-wwi-vertsys-2024-skript</a>
        </p>
        <img src="https://i.creativecommons.org/l/by/4.0/88x31.png" alt="Creative Commons Lizenzvertrag" />
        <p>
            Das Werk <i>Vorlesung "Webprogrammierung" im Studiengang Wirtschaftsinformatik an der DHBW Karlsruhe</i>
            von <a href="http://www.wpvs.de" target="_blank">Dennis Schulmeister-Zimolong im Auftrag der Dualen Hochschule
            Baden-Württemberg Karlsruhe</a> ist lizenziert unter
            <a href="http://creativecommons.org/licenses/by/4.0/" target="_blank"><i>Creative Commons Namensnennung 4.0 International</i></a>.
        </p>
        <p>
            Sie dürfen:
        </p>
        <ul>
            <li>
                <b>Teilen</b> — das Material in jedwedem Format oder Medium vervielfältigen
                und weiterverbreiten
            </li>
            <li>
                <b>Bearbeiten</b> — das Material remixen, verändern und darauf aufbauen
                und zwar für beliebige Zwecke, sogar kommerziell.
            </li>
        </ul>
        <p>
            Unter folgenden Bedingungen:
        </p>
        <ul>
            <li>
                <b>Namensnennung</b> — Sie müssen angemessene Urheber- und Rechteangaben
                machen, einen Link zur Lizenz beifügen und angeben, ob Änderungen
                vorgenommen wurden. Diese Angaben dürfen in jeder angemessenen Art
                und Weise gemacht werden, allerdings nicht so, dass der Eindruck
                entsteht, der Lizenzgeber unterstütze gerade dich oder deine Nutzung
                besonders.
            </li>
            <li>
                <b>Keine weiteren Einschränkungen</b> — Sie dürfen keine zusätzlichen Klauseln
                oder technische Verfahren einsetzen, die anderen rechtlich irgendetwas
                untersagen, was die Lizenz erlaubt.
            </li>
        </ul>
        <p>
            Es werden keine Garantien gegeben und auch keine Gewähr geleistet.
            Die Lizenz verschafft dir möglicherweise nicht alle Erlaubnisse,
            die du für die jeweilige Nutzung brauchst. Es können beispielsweise
            andere Rechte wie Persönlichkeits- und Datenschutzrechte zu beachten
            sein, die deine Nutzung des Materials entsprechend beschränken.
        </p>
    </aside>
</section>