<section data-chapter="h1" data-title="Architektur verteilter Systeme" data-background-color="rgb(210,190,210)">
    <article class="markdown">
        ### Nach Abschluss dieses Kapitels können Sie …
        
        * den Begriff verteiltes System erklären und von ähnlichen Begriffen abgrenzen.
        * Beispiele für verteilte Anwendungen nennen und von normalen Anwendungen abgrenzen.
        * die wichtigsten Gründe für die Entwicklung verteilter Systeme nennen. 💰
        * die Begriffe Client, Server und Peer definieren und voneinander abgrenzen.
        * die gängigsten Architekturmuster verteilter Anwendungen beschreiben.
        * die Bedeutung des CAP-Theorem verstehen und seine Bedeutung wiedergeben.
        * die Schwierigkeiten zeitlicher Wechselwirkungen verteilter Anwendungen erkennen.

        <span style="font-size: 240px; color: white;" class="dhbw-text-shadow" >🏁</span>
    </article>
</section>

<!-- ===================== -->
<!-- Technische Grundlagen -->
<!-- ===================== -->
<section data-use-template="teilkapitel" data-titel="Technische Grundlagen"></section>

<section data-title="Was ist ein verteiltes System?" data-background-image="02-architektur/definition-hintergrund.jpg" data-background-blur="5px">
    <section data-title="Alltäglicher Sprachgebrauch" class="centered-content">
        <lsx-grid-fluid class="p-0 limited-width2">
            <lsx-row>
                <lsx-col size="md-8">
                    <lsx-youtube video="UWU14-EK9CE" aspect-ratio="16x9" class="w-100 mb-0"></lsx-youtube>
    
                    <small>
                        <small>
                            Quelle: Filmausschnitt aus „Star Trek der Film (1979)”
                        </small>
                    </small>
                </lsx-col>
                <lsx-col size="md" class="markdown lead centered-content align-items-start">
                    Jeden Tag sprechen wir von Systemen:
                    
                    <lsx-ul emoji="🚀">
                        <li><i>„Du musst dich am System anmelden.”</i></li>
                        <li><i>„Das ist im System gespeichert.”</i></li>
                        <li><i>„Mein Betriebssystem hängt mal wieder.”</i></li>
                    </lsx-ul>
    
                    Doch was ist überhaupt ein „System“
                    <span style="color: crimson; text-shadow: 1px 1px 1px rgba(0,0,0,0.5);">⁉️</span>
                </lsx-col>
            </lsx-row>
        </lsx-grid-fluid>
    </section>

    <section data-title="System" class="centered-content">
        <div class="limited-width">
            <blockquote class="blockquote fst-italic">
                <p>
                    Als System (altgriechisch sýstēma „aus mehreren Einzelteilen zusammengesetztes Ganzes“)
                    wird im Allgemeinen ein abgrenzbares, natürliches oder künstliches „Gebilde“ bezeichnet,
                    das aus verschiedenen Komponenten mit unterschiedlichen Eigenschaften besteht, die aufgrund
                    bestimmter geordneter Beziehungen untereinander als gemeinsames Ganzes betrachtet werden
                    (können).
                </p>
                <figcaption class="blockquote-footer">
                    <cite>Wikipedia zum Begriff „System”</cite>
                </figcaption>
            </blockquote>
    
            <h4>Wichtige Stichworte dieser Definition</h4>
    
            <lsx-ul emoji="☑️">
                <li>Aus mehren Einzelteilen zusammengesetztes Ganzes</li>
                <li>Abgrenzbares Gebilde aus verschienden Komponenten</li>
                <li>Geordnete Beziehungen untereinander</li>
                <li>Als gemeinsames Ganzes betrachtet</li>
            </lsx-ul>
        </div>
    </section>

    <section data-title="Verteiltes System" class="centered-content">
        <div class="limited-width2">
            <lsx-grid-fluid class="p-0 mb-4">
                <lsx-row>
                    <lsx-col size="md">
                        <blockquote class="blockquote fst-italic card p-2">
                            <p>
                                A distributed system stops you from getting any work done because computer crashed
                                that you didn't even know it existed.
                            </p>
                            <figcaption class="blockquote-footer">
                                <cite>Scherzhafte Definition nach Leslie Lamport</cite>
                            </figcaption>
                        </blockquote>
                    </lsx-col>
    
                    <lsx-col size="md">
                        <blockquote class="blockquote fst-italic card p-2">
                            <p>
                                A distributed system is a collection of [computers] that appears to its users as a single
                                coherent system.
                            </p>
                            <figcaption class="blockquote-footer">
                                <cite>Steen & Tanenbaum</cite>
                            </figcaption>
                        </blockquote>
                    </lsx-col>
                </lsx-row>
            </lsx-grid-fluid>
    
            <h4>Arbeitsdefinition für diese Vorlesung</h4>
    
            <lsx-ul emoji="☑️">
                <li>Mehrere, voneinander unabhängig agierende Computer (muss zumindest möglich sein)</li>
                <li>Datenaustausch über ein Netzwerk ohne geteilten Hauptspeicher</li>
                <li>Die Knoten arbeiten zusammen, um eine übergeordnete, gemeinsame Aufgabe zu erfüllen</li>
            </lsx-ul>
        </div>
    </section>

    <section data-title="Fallbeispiele" class="centered-content">
        <div class="centered-content flex-row flex-wrap gap-3">
            <!-- Das Internet -->
            <lsx-modal>
                <lsx-thumbnail style="height: 18em;" class="mw-100">
                    <img src="02-architektur/arpanet.png" class="d-block h-100 mw-100 dhbw-thumbnail"/>
                </lsx-thumbnail>
                <lsx-content>
                    <lsx-card title="Das Internet" bold class="mh-100">
                        <lsx-card-body class="overflow-scroll">
                            <p class="lead mb-4" style="text-align: justify;">
                                Das größte verteilte System weltweit ist natürlich das Internet. Es ging in der heutigen
                                Form 1983 aus dem bereits seit den 1960ern entwickelten ARPANET hervor. Die Abbildung unten
                                zeigt eine zeitgenössische Karte mit allen damals an das ARPANET angeschlossenen Knoten.
                            </p>
                            <img src="02-architektur/arpanet.png" class="d-block m-auto mw-100" style="max-height: 80vh;"/>
                        </lsx-card-body>
                    </lsx-card>
                </lsx-content>
            </lsx-modal>

            <!-- Webanwendungen -->
            <lsx-modal>
                <lsx-thumbnail style="height: 18em;" class="mw-100">
                    <img src="02-architektur/webapp.png" class="d-block h-100 mw-100 dhbw-thumbnail"/>
                </lsx-thumbnail>
                <lsx-content>
                    <lsx-card title="Webanwendungen" bold class="mh-100">
                        <lsx-card-body class="overflow-scroll">
                            <p class="lead mb-4" style="text-align: justify;">
                                Webanwendungen mit Serverbackend sind ebenfalls verteilte Systeme (bzw. verteilte Anwendungen,
                                je nachdem wie genau man diese beiden Begriffe unterscheiden will). Ausschlaggebend hierfür ist
                                das Zusammenspiel von Browser, Webserver und weiteren Komponenten. Man kann es sich aber auch
                                so herleiten, dass Webanwendungen ein Teilausschnitt des größten verteilten Systems, nämlich
                                des Internets, sind.
                            </p>
                            <img src="02-architektur/webapp.png" class="d-block m-auto mw-100" style="max-height: 80vh;"/>
                        </lsx-card-body>
                    </lsx-card>
                </lsx-content>
            </lsx-modal>

            <!-- Internet of Things -->
            <lsx-modal>
                <lsx-thumbnail style="height: 18em;" class="mw-100">
                    <img src="02-architektur/iot.jpg" class="d-block h-100 mw-100 dhbw-thumbnail"/>
                </lsx-thumbnail>
                <lsx-content>
                    <lsx-card title="Internet of Things" bold class="mh-100">
                        <lsx-card-body class="overflow-scroll">
                            <p class="lead mb-4" style="text-align: justify;">
                                IoT-Anwendungen zählen ebenfalls zu den größten verteilten Systemen (bzw. verteilten
                                Anwendungen) weltweit, da oft viele tausend physische Geräte über das Internet miteinander
                                verbunden sind. Hinzu kommen meist große Serverbackends zur Überwachung und Steuerung der
                                Geräte sowie der Datensammlung und Auswertung.
                            </p>
                            <div class="d-flex flex-wrap justify-content-center align-items-center gap-3">
                                <img src="02-architektur/iot.jpg" class="d-block h-100 mw-100" style="max-height: 40vh;"/>
                                <img src="02-architektur/iot-cartoon.png" class="d-block h-100 mw-100" style="max-height: 40vh;"/>
                            </div>
                        </lsx-card-body>
                    </lsx-card>
                </lsx-content>
            </lsx-modal>

            <!-- Blockchain -->
            <lsx-modal>
                <lsx-thumbnail style="height: 18em;" class="mw-100">
                    <img src="02-architektur/blockchain1.jpg" class="d-block h-100 mw-100 dhbw-thumbnail"/>
                </lsx-thumbnail>
                <lsx-content>
                    <lsx-card title="Blockchain" bold class="mh-100">
                        <lsx-card-body class="overflow-scroll">
                            <p class="lead style="text-align: justify;">
                                Bei der Blockchain handelt es sich um eine kryptographisch abgesicherte, verteilte
                                Datenbank, an die nur neue Inhalte angehängt, aber keine enthaltenen Daten gelöscht
                                werden können. Man spricht hier auch von Transaktionen. Eine Transaktion gilt nur
                                dann als bestätigt, wenn mehr als die Hälfte aller Hauptknoten diese in ihre lokale
                                Version der Blockchain-Datenbasis aufnimmt. Die Daten werden hierfür in einem P2P-Netzwerk
                                veröffentlicht und untereinander ausgetauscht.
                            </p>
                            <p class="mb-4" style="text-align: justify;">
                                Bitcoin leicht erklärt:
                                <a href="https://www.wpvs.de/repo/publikationen/Wie%20funktioniert%20eigentlich%20Bitcoin.pdf" target="_blank">Wie funktioniert eigentlich Bitcoin?</a>
                            </p>
                            <div class="d-flex flex-wrap justify-content-center align-items-center gap-5">
                                <img src="02-architektur/blockchain1.jpg" style="height: 20em; max-height: 40vh; max-width: 100%;"/>
                                <img src="02-architektur/blockchain2.png" style="height: 20em; max-height: 40vh; max-width: 100%;"/>
                                <img src="02-architektur/blockchain3.png" style="height: 20em; max-height: 40vh; max-width: 100%;"/>
                            </div>
                        </lsx-card-body>
                    </lsx-card>
                </lsx-content>
            </lsx-modal>

            <!-- MIDI -->
            <lsx-modal>
                <lsx-thumbnail style="height: 18em;" class="mw-100">
                    <img src="02-architektur/midi.png" class="d-block h-100 mw-100 dhbw-thumbnail"/>
                </lsx-thumbnail>
                <lsx-content>
                    <lsx-card title="Musical Instrument Digital Interface" bold class="mh-100">
                        <lsx-card-body class="overflow-scroll">
                            <p class="lead mb-4" style="text-align: justify;">
                                <a href="https://de.wikipedia.org/wiki/MIDI" target="_blank">MIDI</a>
                                ist eine 1982 eingeführte Digitalschnittstelle zur Verbindung elektronischer Musikgeräte.
                                Ursprünglich zur herstellerübergreifenden Verbindung von Synthesizern und Masterkeyboards vorgesehen,
                                können damit heute alle möglichen Geräte gesteuert werden. Technisch gesehen beinhalten die Geräte
                                hierfür einen eingebetteten Mikroprozessor, um MIDI-Nachrichten senden und empfangen zu können.
                                Die Nachrichten selbst sind überwiegend drei Bytes lang und kodieren musikalische Ereignisse wie
                                das Spielen einer Note oder Drücken des Haltepedals.
                            </p>
                            <!-- <lsx-youtube class="img-thumbnail embed-responsive" video="Kpzhh9_5iqB0"></lsx-youtube> -->
                            <div class="centered-content">
                                <div class="embed-responsive ratio ratio-16x9 limited-width">
                                    <iframe class="d-block" src="https://www.youtube-nocookie.com/embed/pzhh9_5iqB0?rel=0&amp;showinfo=0" allowfullscreen></iframe>
                                </div>
                            </div>
                        </lsx-card-body>
                    </lsx-card>
                </lsx-content>
            </lsx-modal>
        </div>
    </section>

    <section data-title="Alltägliche Beispiele" class="centered-content">
        <div class="limited-width2">
            <p class="dhbw-text-columns mb-5" detail-content>
                Auch wenn wir es inzwischen kaum noch merken, begleiten verteilte Systeme und Anwendungen
                schon seit langem unseren Alltag. Wie selbstverständlich surfen wir im Internet, teilen
                Bilder online oder verschicken Kurznachrichten mit dem Smartphone. Abends streamen wir dann
                die neuste Folge unserer Lieblingsserie und geht es nach dem Willen der Hersteller, steuern
                wir schon bald sämtliche Haushaltsgeräte ganz bequem per Sprachbefehl vom Sofa aus, optimieren
                den Straßenverkehr mit vernetzten Fahrzeugen und überwachen unsere Umwelt mit immer mehr IoT-Devices.
                Ohne Zweifel leben wir in einer vernetzten Welt, in der immer mehr Computer, Smartphones,
                Smart TVs und viele andere Gegenstände miteinander verbunden sind.
            </p>
    
            <lsx-grid-fluid class="p-0">
                <lsx-row>
                    <lsx-col size="md">
                        <img src="02-architektur/alltag-internet.png" class="img-thumbnail d-block" style="width: 100%" />
                        Sämtliche Internetdienste
                        <p class="dhbw-fontsize-tiny">
                            <small>
                                Bildnachweis: <a href="https://pixabay.com/illustrations/email-newsletter-marketing-online-3249062/" target="_blank">Pixabay: ribkhan</a>
                            </small>
                        </p>
                    </lsx-col>
                    <lsx-col size="md">
                        <img src="02-architektur/alltag-mobile.jpg" class="img-thumbnail d-block" style="width: 100%" />
                        Mobile Kommunikation
                        <p class="dhbw-fontsize-tiny">
                            <small>
                                Bildnachweis: <a href="https://pixabay.com/photos/communication-communicate-3095538/" target="_blank">Pixabay: Bru-nO</a>
                            </small>
                        </p>
                    </lsx-col>
                </lsx-row>
                <lsx-row>
                    <lsx-col size="md">
                        <img src="02-architektur/alltag-forschung.jpg" class="img-thumbnail d-block" style="width: 100%" />
                        Forschung und Wissenschaft
                        <p class="dhbw-fontsize-tiny">
                            <small>
                                Bildnachweis: <a href="https://pixabay.com/photos/moon-landing-apollo-11-nasa-60582/" target="_blank">Pixabay: WikiImages</a>
                            </small>
                        </p>
                    </lsx-col>
                    <lsx-col size="md">
                        <img src="02-architektur/alltag-vod.jpg" class="img-thumbnail d-block" style="width: 100%" />
                        Video-on-Demand
                        <p class="dhbw-fontsize-tiny">
                            <small>
                                Bildnachweis: <a href="https://unsplash.com/photos/ngMtsE5r9eI" target="_blank">Unsplash: jenskreuter</a>
                            </small>
                        </p>
                    </lsx-col>
                </lsx-row>
                <lsx-row>
                    <lsx-col size="md">
                        <img src="02-architektur/alltag-autonomes-fahren.jpg" class="img-thumbnail d-block" style="width: 100%" />
                        Autonomes Fahren
                    </lsx-col>
                    <lsx-col size="md">
                        <img src="02-architektur/alltag-iot.jpg" class="img-thumbnail d-block" style="width: 100%" />
                        Internet of Things
                        <p class="dhbw-fontsize-tiny">
                            <small>
                                Bildnachweis: <a href="https://pixabay.com/photos/smarthome-smart-house-smart-4447520/" target="_blank">Pixabay: haus_automation</a>
                            </small>
                        </p>
                    </lsx-col>
                </lsx-row>
            </lsx-grid-fluid>
        </div>
    </section>

    <section data-title="Heute übliche Programmiermodelle">
        <article class="centered-content">
            <div class="limited-width2">
    
                <lsx-grid-fluid>
                    <lsx-row>
                        <lsx-col size="md">
                            <lsx-card title="App-Server / Frameworks" bold class="h-100">
                                <lsx-card-body class="h-100 d-flex flex-column">
                                    <lsx-ul emoji="🎙️">
                                        <li>Beinhalten für Business Apps übliche Grundfunktionen</li>
                                        <li>Unterstützen verschieden Schnittstellentechnologien</li>
                                        <li>Oft auf die Entwicklung von Webanwendungen ausgerichtet</li>
                                    </lsx-ul>
    
                                    <div style="flex: 1"></div>
                                    <img src="02-architektur/arten-appserver.png" alt="" class="w-100" />
                                </lsx-card-body>
                            </lsx-card>
                        </lsx-col>
    
                        <lsx-col size="md">
                            <lsx-card title="Entfernte Methodenaufrufe" bold class="h-100">
                                <lsx-card-body class="h-100 d-flex flex-column">
                                    <lsx-ul emoji="🎙️">
                                        <li>Direkter Aufruf von Funktionen/Methoden des Servers</li>
                                        <li>Sowohl prozedural als auch objekt-orientiert möglich</li>
                                        <li>Teilweise auch zwischen verschiedenen Programmiersprachen</li>
                                    </lsx-ul>
    
                                    <div style="flex: 1"></div>
                                    <img src="02-architektur/arten-methodenaufrufe.png" alt="" class="w-100" />
                                </lsx-card-body>
                            </lsx-card>
                        </lsx-col>
                    </lsx-row>
    
                    <lsx-row>
                        <lsx-col size="md">
                            <lsx-card title="Webservices" bold class="h-100">
                                <lsx-card-body class="h-100 d-flex flex-column">
                                    <lsx-ul emoji="🎙️">
                                        <li>Grundsätzlich dieselbe Idee wie bei entfernten Methodenaufrufen</li>
                                        <li>Jedoch auf Basis von Webstandards wie HTTP, XML, JSON</li>
                                        <li>Früher SOAP, heute überwiegend REST-Webservices</li>
                                    </lsx-ul>
    
                                    <div style="flex: 1"></div>
                                    <img src="02-architektur/arten-webservices.png" alt="" class="w-100" />
                                </lsx-card-body>
                            </lsx-card>
                        </lsx-col>
    
                        <lsx-col size="md">
                            <lsx-card title="Message Broker" bold class="h-100">
                                <lsx-card-body class="h-100 d-flex flex-column">
                                    <lsx-ul emoji="🎙️">
                                        <li>Grundsätzlich asynchroner Nachrichtenaustausch</li>
                                        <li>Mehrere Empfänger für eine Nachricht möglich und üblich</li>
                                        <li>Store and Forward der Nachrichten in einer FIFO-Warteschlange</li>
                                    </lsx-ul>
    
                                    <div style="flex: 1"></div>
                                    <img src="02-architektur/arten-pubsub.png" alt="" class="w-100" />
                                </lsx-card-body>
                            </lsx-card>
                        </lsx-col>
                    </lsx-row>
                </lsx-grid-fluid>
            </div>
        </article>
    </section>

    <section data-title="Historische Entwicklung">
        <article class="centered-content">
            <div class="centered-content flex-row flex-wrap gap-3">
                <!-- Host-to-Host -->
                <lsx-modal>
                    <lsx-thumbnail style="height: 14em;" class="mw-100">
                        <img src="02-architektur/historie-abb1.jpg" class="d-block h-100 mw-100 dhbw-thumbnail"/>
                    </lsx-thumbnail>
                    <lsx-content>
                        <lsx-card title="Host-to-Host" bold class="mh-100 mw-100" style="width: 35em;">
                            <lsx-card-body class="overflow-scroll">
                                <p style="text-align: justify; hyphens: auto;">
                                    Vor Erfindung des ARPANET und ähnlicher Computernetze in den 1960er-Jahren gab es noch kein
                                    anerkanntes Modell, wie zwei Computer untereinander Daten austauschen können. Die einzige
                                    Möglichkeit war, eine direkte Kabelverbindung „host-to-host” herzustellen, wobei hierfür
                                    Hard- und Software auf beiden Seiten komplett selbst entwickelt werden mussten.
                                </p>
                                
                                <lsx-ul emoji="🔌" class="lead mb-4">
                                    <li>Direkte Kabelverbindung zwischen zwei Rechnern</li>
                                    <li>Keine Unterstützung durch das Betriebssystem</li>
                                </lsx-ul>
                                
                                <img src="02-architektur/historie-kabel.svg" alt="Zwei VS-Knoten mit direkter Kabelverbindung" style="width: 100%; margin-bottom: 1em;" />
                                <img src="02-architektur/historie-abb1.jpg" alt="" style="width: 100%;" />
                            </lsx-card-body>
                        </lsx-card>
                    </lsx-content>
                </lsx-modal>
    
                <!-- Packet Switching -->
                <lsx-modal>
                    <lsx-thumbnail style="height: 14em;" class="mw-100">
                        <img src="02-architektur/historie-abb2.jpg" class="d-block h-100 mw-100 dhbw-thumbnail"/>
                    </lsx-thumbnail>
                    <lsx-content>
                        <lsx-card title="Packet Switching" bold class="mh-100 mw-100" style="width: 35em;">
                            <lsx-card-body class="overflow-scroll">
                                <p style="text-align: justify; hyphens: auto;">
                                    In den ausgehenden 1960er-Jahren wurde für die neuentwickelten Computernetzwerke das auch heute
                                    noch gültige Prinzip des Packet Switching erfunden. Die Idee dahinter ist, die zu versendenden
                                    Daten in kleine Pakete zu zerlegen und jedes Paket seinen eigenen Weg durch das Netzwerk vom
                                    Sender zum Empfänger suchen zu lassen. Heute haben wir Router für diese Aufgabe. Im ARPANET hießen
                                    diese „Interface Message Processor” und waren so groß wie ein Schrank.
                                </p>
    
                                <lsx-ul emoji="📦" class="lead mb-4">
                                    <li>NCP und später TCP als Vorläufer von TCP/IP</li>
                                    <li>Weltweiter Datenaustausch zwischen allen Hosts</li>
                                    <li>Anschluss des Computers hierfür an einen <a href="https://en.wikipedia.org/wiki/Interface_Message_Processor" target="_blank">IMP</a></li>
                                </lsx-ul>
    
                                <img src="02-architektur/imp-subnet.svg" alt="Netzwerktopologie des früheren ARPANET" style="width: 100%; margin-bottom: 1em;" />
    
                                <!-- <lsx-youtube class="img-thumbnail embed-responsive" video="yU9oMOcRsuE"></lsx-youtube> -->
                                <div class="centered-content">
                                    <div class="embed-responsive ratio ratio-16x9 limited-width">
                                        <iframe class="d-block" src="https://www.youtube-nocookie.com/embed/yU9oMOcRsuE?rel=0&amp;showinfo=0" allowfullscreen></iframe>
                                    </div>
                                </div>
                            </lsx-card-body>
                        </lsx-card>
                    </lsx-content>
                </lsx-modal>
    
                <!-- Sockets- und Middleware -->
                <lsx-modal>
                    <lsx-thumbnail style="height: 14em;">
                        <img src="02-architektur/historie-abb3.jpg" class="d-block h-100 mw-100 dhbw-thumbnail"/>
                    </lsx-thumbnail>
                    <lsx-content>
                        <lsx-card title="Streams und Sockets" bold class="mh-100 mw-100" style="width: 35em;">
                            <lsx-card-body class="overflow-scroll">
                                <p style="text-align: justify; hyphens: auto;">
                                    Obwohl die heute vorherrschenden Streams und Sockets noch nicht erfunden waren (dies geschah erst 1983 mit
                                    Veröffentlichung der Socket API für BSD Unix), suchte man bereits in den 1970er-Jahren nach Möglichkeiten,
                                    die Netzwerkprogrammierung zu vereinfachen. In dieser Zeit wurde der „entfernte Prozeduraufruf“ erfunden,
                                    bei dem die Unterprogramme (bzw. Funktionen bzw. Methoden, je nach Programmiersprache) eines Serverprogramms
                                    über das Netzwerk direkt aufgerufen werden können, ohne den konkreten Datenaustausch auf Byte-Ebene hierfür
                                    kennen zu müssen.
                                </p>
    
                                <lsx-ul emoji="📃" class="lead mb-4">
                                    <li><a href="https://de.wikipedia.org/wiki/Remote_Procedure_Call" target="_blank">Remote Procedure Call</a> ab den 1970ern</li>
                                    <li>Zunächst konkurrierende Programmiermodelle</li>
                                    <li>Streams und Sockets ab 1983 in BSD Unix</li>
                                </lsx-ul>
    
                                <img src="02-architektur/historie-sockets.svg" alt="Zwei VS-Knoten mit Middleware" style="width: 100%; margin-bottom: 1em;" />
                                <img src="02-architektur/historie-abb3.jpg" alt="" style="width: 100%;" />
                            </lsx-card-body>
                        </lsx-card>
                    </lsx-content>
                </lsx-modal>
    
                <!-- Applikationsserver -->
                <lsx-modal>
                    <lsx-thumbnail style="height: 14em;">
                        <img src="02-architektur/historie-abb4.jpg" class="d-block h-100 mw-100 dhbw-thumbnail"/>
                    </lsx-thumbnail>
                    <lsx-content>
                        <lsx-card title="Applikationsserver" bold class="mh-100 mw-100" style="width: 35em;">
                            <lsx-card-body class="overflow-scroll">
                                <p style="text-align: justify; hyphens: auto;">
                                    Mit zunehmendem Umfang der Anforderungen stieg spätestens ab Mitte der 1990er-Jahre auch die
                                    Komplexität typischer verteilter Anwendungen deutlich an. In Folge daraus versuchte man über
                                    den Datenaustauschs hinausgehende Querschnittsfunktionen typischer Informationssysteme in sog.
                                    Applikationsserver auszugliedern, die als generische Laufzeitumgebung frei programmierbar an
                                    den jeweiligen Anwendungsfall angepasst werden konnten.
                                </p>
                                <p style="text-align: justify; hyphens: auto;">
                                    Aus heutiger Sicht vereinfacht das damit verbundene Programmiermodell die Erstellung neuer
                                    Anwendungen zwar drastisch, wird aber dennoch als schwerfällig und komplex empfunden. Heute
                                    geht der Trend stattdessen mehr in die Richtung, die ehemals vom Applikationsserver bereitgestellten
                                    Funktionen in Form Quellcode-Bibliotheken oder Micro-Frameworks zu integrieren.
                                </p>
    
                                <lsx-ul emoji="🚢" class="lead mb-4">
                                    <li>Große Applikationsserver ab den 1990ern</>
                                    <li>Zunächst RPC später Webtechnologien</li>
                                    <li>Heute eher leichtgewichtigere Micro-Frameworks</li>
                                </lsx-ul>
    
                                <img src="02-architektur/historie-appserver.svg" alt="Drei VS-Knoten von denen einer ein Applikationsserver ist" style="width: 100%; margin-bottom: 1em;" />
                                <img src="02-architektur/historie-abb4.jpg" alt="" style="width: 100%;" />
                            </lsx-card-body>
                        </lsx-card>
                    </lsx-content>
                </lsx-modal>
            </div>
        </article>
    </section>
</section>

<section data-title="Der TCP/IP-Protokollstapel">
    <section data-title="Beteiligte Komponenten">
        <article class="centered-content">
            <div class="limited-width">
                <div class="markdown mb-4" detail-content>
                    Die überwiegende Mehrheit der verteilten Anwendungen laufen heute über das Internet oder nutzen zumindest
                    den TCP/IP-Protokollstapel. Das verteilte System besteht in diesem Fall aus einer beliebigen Anzahl von
                    Rechnerknoten mit einem netzwerkfähigen Betriebssystem, die über untereinander Nachrichten austauschen können.
                    Die auf den Rechnern laufenden Programmkomponenten bilden in ihrer Gesamtheit die eigentliche verteilte
                    Anwendung.
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" role="switch" id="tcpip-details-switch">
                            <label class="form-check-label" for="tcpip-details-switch">Details anzeigen</label>
                        </div>
                    </div>
                    <div class="card-body">
                        <img src="02-architektur/tcpip-stack1.png" id="tcpip-stack1" class="d-block w-100" alt="Vereinfachter schematischer Aufbau eines verteilten Systems">
                        <img src="02-architektur/tcpip-stack2.png" id="tcpip-stack2" class="d-block w-100 hidden" alt="Vereinfachter schematischer Aufbau eines verteilten Systems">
                    </div>
                </div>

                <div id="tcpip-stack3" class="markdown hidden" detail-content>
                    Der Netzwerk-Stack des Betriebssystems wird grob wie folgt unterteilt:

                    * **Netzwerkschicht:** Dient der Anbindung an das physikalische Netzwerk, z.B. Ethernet oder WiFi.

                    * **Vermittlungsschicht:** Dient der Adressierung der Rechnerknoten und dem Routing von Datenpaketen
                      über lokale Netzwerkgrenzen hinweg. Auf dieser Ebene läuft das
                      [Internet Protocol (IP)](https://de.wikipedia.org/wiki/Internet_Protocol){target=_blank}, das jedem
                      Rechner eine (global) eindeutige IP-Adresse zuweist.

                    * **Transportschicht:** Dient der Adressierung mehrerer Dienste auf einem Rechner und der optionalen
                      Sicherstellung eine zuverlässigen Datenaustauschs. Auf dieser Ebene laufen das
                      [Transport Control Protocol (TCP)](https://de.wikipedia.org/wiki/Transmission_Control_Protocol){target=_blank}
                      und das [User Datagram Protocol (UDP)](https://de.wikipedia.org/wiki/User_Datagram_Protocol){target=_blank},
                      welche die Portnummern verwalten.

                    * **Anwendungsschicht:** Die eigentlichen auf dem Rechnerknoten laufenden Anwendungsprogramme.
                      Im einfachsten Fall nutzen diese die unteren Schichten direkt, um untereinander Daten auszutauschen.
                      Die meisten Betriebssysteme bzw. Programmiersprachen stellen hierfür
                      [Streams und Sockets](https://de.wikipedia.org/wiki/Socket_%28Software%29){target=_blank}
                      als Programmierschnittstelle bereit.

                      In größeren Anwendungen kommen jedoch spezialisierte Anwendungsprotokolle zum Einsatz, die
                      losgelöst vom fachlichen Anwendungscode entwickelt werden.
                </div>

                <script>
                    window.toggle_tcpip_details = function() {
                        let checkbox = document.querySelector("#tcpip-details-switch");
                        let image1   = document.querySelector("#tcpip-stack1");
                        let image2   = document.querySelector("#tcpip-stack2");
                        let details  = document.querySelector("#tcpip-stack3");

                        image1.classList.remove("hidden");
                        image2.classList.remove("hidden");
                        details.classList.remove("hidden");

                        if (checkbox.checked) {
                            image1.classList.add("hidden");
                        } else {
                            image2.classList.add("hidden");
                            details.classList.add("hidden");
                        }
                    }

                    window.addEventListener("ls-slide-changed", () => {
                        window.setTimeout(function() {                    
                            let checkbox = document.querySelector("#tcpip-details-switch");
                            if (!checkbox) return;

                            checkbox.addEventListener("change", toggle_tcpip_details);
                        }, 1000);
                    });
                </script>
            </div>
        </article>
    </section>

    <section data-title="Fallbeispiel: Sockets in Node.js">
        <article class="centered-content">
            <div class="limited-width2 mb-4">
                <div class="markdown dhbw-text-columns mb-4" detail-text>
                    Das nachfolgende Beispiel zeigt eine kleine Client/Server-Anwendung mit Node.js und JavaScript.
                    Client und Server setzen auf dem eben gezeigten TCP/IP-Protokollstapel auf und nutzen die Klassen
                    [`net.Server`](https://nodejs.org/docs/latest/api/net.html#class-netserver){target=_blank} bzw.
                    [`net.Socket`](https://nodejs.org/docs/latest/api/net.html#class-netsocket){target=_blank} für
                    den Datenaustausch. Es handelt sich dabei um die niedrigste Ebene, auf der Netzwerkanwendungen
                    mit [Node.js](https://nodejs.org/en){target=_blank} programmiert werden können.
                </div>

                <div class="d-flex flex-column gap-3 mb-4 fs-6">
                    <div class="d-flex gap-3 align-items-center">
                        <lsx-github-edit url="https://github.com/DennisSchulmeister/dhbwka-wwi-vertsys-2024-quellcodes/tree/main/1%20Architektur%20verteilter%20Systeme/Beispiele/Socket-Minimalbeispiel"></lsx-github-edit>
                        <div>Minimalbeispiel</div>
                    </div>
                    <div class="d-flex gap-3 align-items-center">
                        <lsx-github-edit url="https://github.com/DennisSchulmeister/dhbwka-wwi-vertsys-2024-quellcodes/tree/main/1%20Architektur%20verteilter%20Systeme/Beispiele/Socket-Sprachserver"></lsx-github-edit>
                        <div>Sprachserver</div>
                    </div>
                </div>

                <lsx-accordion class="mb-4">
                    <lsx-accordion-page title="Grundgerüst der Serveranwendung" bold>
                        <div class="markdown" detail-text>
                            Innerhalb der Serveranwendung muss ein Server-Objekt erzeugt und dessen
                            <src-code language="javascript">listen()</src-code>-Methode aufgerufen werden,
                            um TCP/IP-Verbindungsanfragen behandeln zu können. Für jeden neuen Client wird
                            eine Rückruffunktion zur Abwicklung des Datenaustauschs aufgerufen. Diese bekommt
                            ein <code>Socket</code>-Objekt zum Senden und Empfangen der Daten übergeben.
                        </div>

                        <lsx-tab-pages>
                            <lsx-tab-page title="Schritte">
                                <lsx-ul>
                                    <li>
                                        <code>Server</code>-Objekt erzeugen mit <src-code language="javascript">net.createServer()</src-code>
                                    </li>
                                    <li>
                                        <src-code language="javascript">listen()</src-code>-Methode aufrufen, um auf
                                        Clientverbindungen zu warten
                                    </li>
                                    <li>
                                        Callback-Funktion zur Abwicklung der Kommunikation mit einem Client übergeben
                                    </li>
                                    <li>
                                       Innerhalb der Client-Funktionen die <code>Socket</code>-Events und Metoden verwenden
                                    </li>
                                </lsx-ul>
                            </lsx-tab-page>

                            <lsx-tab-page title="Quellcode">
                                <source-code language="javascript">
                                    import net from "net";
        
                                    // Socket-Server starten
                                    let server = net.createServer(socket => {
                                        // Verbindung mit neuem Client hergestellt
                                        log(socket, "Client verbunden");
                                    
                                        socket.setEncoding("utf-8");
                                        socket.setNoDelay();
                                        socket.write("Hallo! Ich bin der Server.\n");
                                    
                                        socket.on("error", err => log(socket, err));
                                        socket.on("close", () => log(socket, "Client getrennt"));
                                    
                                        socket.on("data", data => {
                                            log(socket, "Empfangene Daten:", data);
                                            socket.write(data);
                                        });
                                    });
                                    
                                    server.listen("7000", "localhost");
                                </source-code>
                            </lsx-tab-page>
                        </lsx-tab-pages>
                    </lsx-accordion-page>

                    <lsx-accordion-page title="Grundgerüst der Clientanwendung" bold>
                        <div class="markdown" detail-text>
                            Die Programmierung der Clientseite erfolgt grundsätzlich gleich, nur dass hier die Methode
                            <src-code language="javascript">net.createConnection()</src-code> verwendet werden muss, um
                            eine Verbindung zum Server herzustellen. Analog zum Serverbeispiel erwartet diese eine
                            Callback-Funktion innerhalb derer ein <code>Socket</code>-Objekt zur Abwicklung des
                            Datenaustauschs verwendet werden kann. Was den hier gezeigten Quellcode allerdings komplexer
                            als die Serverseite macht, ist dass hier mit Hilfe der Klasse <code>EventEmitter</code>
                            eine Synchronisation zwische den vielen Event Handlern hergestellt werden muss, um die
                            Reihenfolge aus Anfrage und Antwort korrekt einhalten zu können.
                        </div>

                        <lsx-tab-pages>
                            <lsx-tab-page title="Schritte">
                                <lsx-ul>
                                    <li>
                                        <code>Spcket</code>-Objekt erzeugen mit <src-code language="javascript">net.createConnection()</src-code>
                                    </li>
                                    <li>
                                        Callback-Funktion zur Abwicklung der Kommunikation mit einem Server übergeben
                                    </li>
                                    <li>
                                        Innerhalb der Client-Funktionen die <code>Socket</code>-Events und Metoden verwenden
                                    </li>
                                    <li>
                                        Ggf. Klassen wie <code>EventEmitter</code> nutzen, um die richtige Reihenfolge sicherzustellen
                                    </li>
                                </lsx-ul>
                            </lsx-tab-page>

                            <lsx-tab-page title="Quellcode">
                                <source-code language="javascript">
                                    import net                from "net";
                                    
                                    import * as readline      from 'node:readline/promises';
                                    import {stdin as input}   from 'node:process';
                                    import {stdout as output} from 'node:process';
                                    
                                    import {EventEmitter}     from 'node:events';
                                    import {once}             from 'node:events';
                                    
                                    let rl           = readline.createInterface({input, output});
                                    let dataReceived = new EventEmitter();
                                    let connected    = false;
                                    
                                    // Verbindung mit Server herstellen und Protokoll abwickeln
                                    let socket = net.createConnection({host: "localhost", port: 7000}, async () => {
                                        socket.setNoDelay();
                                        connected = true;
                                                                
                                        while (connected) {
                                            let input = await rl.question("Ihre Eingabe: ");
                                            if (!connected) break;
                                    
                                            // Daten an den Server schicken
                                            if (input) {
                                                socket.write(input);
                                        
                                                // Antwort vom Server anzeigen
                                                let response = await once(dataReceived, "data");
                                                console.log("Server:", response[0], "\n");
                                            } else {
                                                connected = false;
                                            }
                                        }
                                    
                                        // Verbindung trennen
                                        socket.end();
                                        socket.destroy();
                                    
                                        rl.close();
                                    });
                                    
                                    
                                    // Empfangene Daten an die Hauptschleife oben schicken
                                    socket.on("data", data => {
                                        data = data.toString();
                                        dataReceived.emit("data", data);
                                    });
                                    
                                    socket.on("error", err => console.error("\n", err));
                                    socket.on("end", () => connected = false);
                                </source-code>
                            </lsx-tab-page>
                        </lsx-tab-pages>
                    </lsx-accordion-page>

                    <lsx-accordion-page title="Ausgetauschte Rohdaten" bold>
                        <div class="markdown mb-4" detail-text>
                            In der Tradition klassischer Internetdienste nutzt die Beispielanwendung ein einfach
                            gestricktes, textbasiertes Protokoll zur Verständigung zwischen Client und Server.
                            Der Screenshot zeigt die zwischen beiden Seiten ausgetauschten Daten, wobei die Sitzung
                            immer mit einer `HELLO`-Nachricht vom Client an den Server beginnt. Für dieses Beispiel
                            wurde mit dem Programm [netcat](https://de.wikipedia.org/wiki/Netcat){target=_blank}
                            eine direkte Socketverbindung zum Server hergestellt, anstelle die JavaScript-Clientanwendung
                            zu verwenden.
                        </div>

                        <img src="02-architektur/socket-netcat.png" class="d-block w-100" alt="Ausgetauschte Rohdaten">
                    </lsx-accordion-page>
                </lsx-accordion>

                <div class="d-flex flex-column flex-md-row gap-3">
                    <img src="02-architektur/socket-server.png" class="img-thumbnail d-block w-100" alt="Serverprogramm">
                    <img src="02-architektur/socket-client.png" class="img-thumbnail d-block w-100" alt="Clientprogramm">
                </div>
            </div>
        </article>
    </section>

    <section data-title="Benutzeroberfläche des Beispiels">
        <article class="centered-content">
            <div style="width: 35em; max-width: 100%;">
                <img src="02-architektur/frontenders-and-backenders.jpeg" class="d-block w-100">
                <small>
                    <small>
                        Bildnachweis:
                        <a href="https://turnoff.us/geek/frontenders-and-backenders/" target="_blank">turnoff.us</a>
                    </small>
                </small>
            </div>
        </article>
    </section>

    <section data-title="Von Clients, Servern und Peers">
        <article class="centered-content">
            <div class="limited-width2">
                <p class="mb-4">
                    Im Zusammenhang mit verteilten Netzwerkanwendungen haben sich bereits früh folgende Begriffe
                    mit fester Bedeutung etabliert. Leider werden aber gerade die Begriffe „Server” und „Service”
                    im alltäglichen Sprachgebrauch heutzutage sehr unscharf verwendet.
                </p>
    
                <table class="w-100 mb-5">
                    <tr>
                        <td style="padding-right: 0.5em;">
                            💿
                        </td>
                        <td style="padding-right: 0.5em;">
                            <b>Server</b>
                        </td>
                        <td>
                            Langlaufendes Programm, das einen Dienst zur Verfügung stellt.
                            <span style="color: darkred;">
                                Wartet darauf, bis sich ein Client mit ihm verbindet.
                            </span>
                        </td>
                    </tr>
                    <tr>
                        <td style="padding-right: 0.33em;">
                            💿
                        </td>
                        <td style="padding-right: 0.5em;">
                            <b>Client</b>
                        </td>
                        <td>
                            Kurzlebiges Programm, das den Dienst nutzt.
                            <span style="color: darkred;">
                                Stellt hierfür eine Verbindung zum Server her.
                            </span>
                        </td>
                    </tr>
                    <tr>
                        <td style="padding-right: 0.5em; padding-bottom: 1em;">
                            💿
                        </td>
                        <td style="padding-right: 0.5em; padding-bottom: 1em;">
                            <b>Peer</b>
                        </td>
                        <td style="padding-bottom: 1em;">
                            Spezielles Programm, das sowohl Client als auch Server ist.
                        </td>
                    </tr>
                    <tr style="border: 0px dashed black; border-top-width: 1px;">
                        <td style="padding-top: 1em; padding-right: 0.5em;">
                            🖥
                        </td>
                        <td style="padding-top: 1em; padding-right: 0.5em;">
                            <b>Host</b>
                        </td>
                        <td style="padding-top: 1em;">
                            Der Rechner, auf dem die Software läuft.
                            <span style="color: darkred;">
                                Oft sagen die Leute „Server” und meinen damit den „Host”.
                            </span>
                        </td>
                    </tr>
                </table>
        
                <div class="d-flex gap-3">
                    <lsx-card title="Client/Server-Architektur" bold>
                        <img src="02-architektur/client-server.svg" alt="Skizze mit vielen Clients und einem Server in der Mitte" class="d-block w-100" />
                    </lsx-card>
                    <lsx-card title="Peer-to-Peer-Architektur" bold>
                        <img src="02-architektur/peer-to-peer.svg" alt="Skizze mit vielen untereinander verbundenen Peers" class="d-block w-100" />
                    </lsx-card>
                </div>
            </div>
        </article>
    </section>
    
    <section data-title="Grundlegende Architekturmodelle">
        <article class="centered-content">
            <div class="limited-width2">
                <lsx-tab-pages class="w-100">
                    <lsx-tab-page title="Client/Server">
                        <p class="dhbw-text-columns mb-4" detail-content>
                            Dies ist die einfachste Architektur von allen. Sie besteht lediglich aus einem Server,
                            der einen Dienst anbietet und den Clients, welche den Dienst konsumieren. Sehr oft kommt
                            dabei ein synchrones, den Client blockierendes Request/Reply-Verfahren zum Einsatz, das
                            besonders einfach zu programmieren ist. Technisch gesehen ist dies aber kein Muss, da
                            Sockets prinzipiell jede Kommunikationsreihenfolge zulassen.
                        </p>

                        <lsx-grid-fluid class="p-0">
                            <lsx-row>
                                <lsx-col size="md" class="d-flex justify-content-center mb-4 mb-md-0">
                                    <img src="02-architektur/architektur-client-server.svg" alt="Skizze eines Servers und dreier Clients" class="d-block m-auto" style="max-width: 45em;" />
                                </lsx-col>
                                <lsx-col size="md" class="d-flex justify-content-center align-items-center">
                                    <lsx-card title="Fallbeispiele" style="flex: 1;">
                                        <lsx-ul emoji="✅">
                                            <li>
                                                Browser und Webserver im World Wide Web
                                            </li>
                                            <li>
                                                Browser App mit Zugriff auf den Server via Websockets
                                            </li>
                                            <li>
                                                Wartungszugang auf einen Rechner per Secure Shell
                                            </li>
                                            <li>
                                                Zugriff auf ein E-Mailpostfach mit IMAP
                                            </li>
                                            <li>
                                                Zentrale Quellcodeverwaltung mit Subversion
                                            </li>
                                            <li>
                                                WebDAV-Zugriff auf einen geteilten Onlineordner
                                            </li>
                                        </lsx-ul>
                                    </lsx-card>
                                </lsx-col>
                            </lsx-row>
                        </lsx-grid-fluid>
                    </lsx-tab-page>
        
                    <lsx-taAufzeichnung der aufgerufenen URL-Routenb-page title="Dreischichtenarchitektur">
                        <p class="dhbw-text-columns mb-4" detail-content>
                            Hierbei handelt es sich ebenfalls um eine Client/Server-Architektur, jedoch greift der Server zusätzlich
                            auf eine Datenbank zu. Client, Server und Datenbank werden daher den drei Schichten <b>Darstellung</b>,
                            <b>Anwendungslogik</b> und <b>Datenhaltung</b> zugeordnet. Für die Darstellung wurden früher ausschließlich
                            native Clients verwendet, die heute zunehmend von Webanwendungen und mobilen Apps verdrängt werden. Die
                            Schichten für die Anwendungslogik und Datenhaltung können hingegen auch mehrere Server umfassen.
                        </p>

                        <lsx-grid-fluid class="p-0">
                            <lsx-row>
                                <lsx-col size="md" class="d-flex justify-content-center mb-4 mb-md-0">
                                    <img src="02-architektur/architektur-3schichten.svg" alt="Skizze einer Dreischichtenarchitektur" class="d-block limited-width m-auto" />
                                </lsx-col>
                                <lsx-col size="md" class="d-flex justify-content-center align-items-center">
                                    <lsx-card title="Fallbeispiele" style="flex: 1;">
                                        <lsx-ul emoji="✅">
                                            <li>
                                                Jede Webanwendung mit einer Datenbank im Hintergrund
                                            </li>
                                            <li>
                                                Informationssysteme ohne eigenständigen Präsentationsserver
                                            </li>
                                            <li>
                                                Die meisten ERP- und CRM-Systeme (SAP S/4HANA, Navision, …)
                                            </li>
                                            <li>
                                                Per Webservice erreichbare Microservices
                                            </li>
                                        </lsx-ul>
                                    </lsx-card>
                                </lsx-col>
                            </lsx-row>
                        </lsx-grid-fluid>
                    </lsx-taAufzeichnung>
        
                    <lsx-tab-page title="Vierschichtenarchitektur">
                        <p class="dhbw-text-columns mb-4" detail-content>
                            Hierbei handelt es sich um eine Variation der Dreischichtenarchitektur, bei der die mittlere Sicht
                            in eine <b>Präsentations-</b> und eine <b>Anwendungsschicht</b> zerlegt wurde. Dieses Modell
                            findet man häufig bei ERP-Systemen, die mehrere Clienttechnologien unterstützen müssen.
                        </p>

                        <lsx-grid-fluid class="p-0">
                            <lsx-row>
                                <lsx-col size="md" class="d-flex justify-content-center mb-4 mb-md-0">
                                    <img src="02-architektur/architektur-4schichten.svg" alt="Skizze einer Dreischichtenarchitektur" class="d-block limited-width m-auto" />
                                </lsx-col>
                                <lsx-col size="md" class="d-flex justify-content-center align-items-center">
                                    <lsx-card title="Fallbeispiele" style="flex: 1;">
                                        <lsx-ul emoji="✅">
                                            <li>
                                                ERP- und CRM-Systeme mit Präsentationsserver
                                            </li>
                                            <li>
                                                Typische Single Page Apps mit Webservice-Backend
                                            </li>
                                        </lsx-ul>
                                    </lsx-card>
                                </lsx-col>
                            </lsx-row>
                        </lsx-grid-fluid>
                    </lsx-tab-page>
        
                    <lsx-tab-page title="Microservices">
                        <p class="dhbw-text-columns mb-4" detail-content>
                            Microservices zerlegen eine große, monolithische Anwendung in viele kleine Teilanwendungen. Jeder Microservice hat
                            ein klar umrissenes Aufgabengebiet, besitzt eine gut dokumentierte und versionierte Schnittstelle und wird in der
                            Regel von einem eigenen Team entwickelt und betrieben. Entwicklung, Test und Betrieb sind sehr stark automatisiert.
                            Microservices eignen sich daher oft für große Firmen mit mehreren, unabhängigen Entwicklungsmannschaften.
                        </p>

                        <div class="form-check form-switch mb-4 fw-bold">
                            <input class="form-check-input" type="checkbox" role="switch" id="microservices-switch">
                            <label class="form-check-label microservices-switch-off" for="microservices-switch">Beschreibung</label>
                            <label class="form-check-label microservices-switch-on hidden" for="microservices-switch">Fallbeispiel</label>
                        </div>

                        <lsx-grid-fluid class="p-0 microservices-switch-off">
                            <lsx-row>
                                <lsx-col size="md" class="d-flex justify-content-center mb-4 mb-md-0">
                                    <img src="02-architektur/microservices.png" alt="Skizze einer Microservice-Architektur" class="d-block limited-width m-auto" />
                                </lsx-col>
                                <lsx-col size="md" class="d-flex justify-content-center align-items-center">
                                    <lsx-card title="Fallbeispiele" style="flex: 1;">
                                        <lsx-ul emoji="✅">
                                            <li>
                                                Amazon gilt als Erfinder, obwohl sie den Begriff nicht verwenden
                                            </li>
                                            <li>
                                                Große Internetplattformen wie eBay, Netflix, SoundCloud, Spotify, …
                                            </li>
                                            <li>
                                                So gut wie jede größere Cloud-Anwendung
                                            </li>
                                        </lsx-ul>
                                    </lsx-card>
                                </lsx-col>
                            </lsx-row>
                        </lsx-grid-fluid>

                        <img src="02-architektur/microservices-beispiel.png" alt="Fallbeispiel für eine Microservice-Architektur" class="d-block w-100 hidden microservices-switch-on">

                        <script>
                            window.toggle_microservices_content = function() {
                                let checkbox = document.querySelector("#microservices-switch");

                                for (let element of document.querySelectorAll(".microservices-switch-off, .microservices-switch-on")) {
                                    element.classList.add("hidden");
                                }

                                for (let element of document.querySelectorAll(checkbox.checked ? ".microservices-switch-on" : ".microservices-switch-off")) {
                                    element.classList.remove("hidden");
                                }
                            }
        
                            window.addEventListener("ls-slide-changed", () => {
                                window.setTimeout(function() {                    
                                    let checkbox = document.querySelector("#microservices-switch");
                                    if (!checkbox) return;
        
                                    checkbox.addEventListener("change", toggle_microservices_content);
                                }, 1000);
                            });
                        </script>
                    </lsx-tab-page>
                    
                    <lsx-tab-page title="Reverse Proxy / API-Gateway">
                        <p class="dhbw-text-columns mb-4" detail-content>
                            Serverseitig kann ein Reverse Proxy als API-Gateway eingesetzt werden, um die eingehenden Anfragen
                            zu bündeln. Dadurch wird es möglich, zusätzliche Sicherheitsprüfungen zu implementieren, häufig
                            angefragte Inhalte zu cachen oder eine transparente Lastverteilung vorzunehmen.
                        </p>

                        <lsx-grid-fluid class="p-0">
                            <lsx-row>
                                <lsx-col size="md" class="d-flex justify-content-center mb-4 mb-md-0">
                                    <img src="02-architektur/proxy-serverseitig.png" alt="Architekturskizze mit serverseitigem Proxy" style="max-height: 16em; max-width: 100%;" />
                                </lsx-col>
                                <lsx-col size="md" class="d-flex justify-content-center align-items-center">
                                    <lsx-card title="Fallbeispiele" style="flex: 1;">
                                        <lsx-ul emoji="✅">
                                            <li>
                                                Steigerung der Performance durch Caching häufig angefragter Daten
                                            </li>
                                            <li>
                                                Implementierung von Zugangsbeschränkungen und Upload Filtern
                                            </li>
                                            <li>
                                                Realisierung von Paywalls zum Ausfiltern kostenpflichtiger Inhalte
                                            </li>
                                            <li>
                                                Sicherstellen einer vorgelagerten, zentralen Authentifizierung
                                            </li>
                                            <li>
                                                Überlöastung vermeiden durch Rate Limiting / Throttling
                                            </li>
                                            <li>
                                                Monitoring und statistische Aufzeichnung der Nutzung
                                            </li>
                                            <li>
                                                <u>Serverseitige</u> Lastverteilung
                                            </li>
                                        </lsx-ul>
                                    </lsx-card>
                                </lsx-col>
                            </lsx-row>
                        </lsx-grid-fluid>
                    </lsx-tab-page>
                    
                    <lsx-tab-page title="Proxy">
                        <p class="dhbw-text-columns mb-4" detail-content>
                            Ein clientseitiger Proxy bildet die Schnittstelle eines entfernten Servers innerhalb
                            des lokalen Netzwerks ab. Die Anfragen der Clients werden nicht direkt an den Server
                            sondern an den lokalen Proxy gesendet, der daraufhin entscheiden kann, ob er die
                            Anfragen weiterleitet oder selbst beantwortet.
                        </p>

                        <lsx-grid-fluid class="p-0">
                            <lsx-row>
                                <lsx-col size="md" class="d-flex justify-content-center mb-4 mb-md-0">
                                    <img src="02-architektur/proxy-clientseitig.png" alt="Architekturskizze mit clientseitigem Proxy" style="max-height: 16em; max-width: 100%;" />
                                </lsx-col>
                                <lsx-col size="md" class="d-flex justify-content-center align-items-center">
                                    <lsx-card title="Fallbeispiele" style="flex: 1;">
                                        <lsx-ul emoji="✅">
                                            <li>
                                                Steigerung der Performance durch Caching häufig angefragter Daten
                                            </li>
                                            <li>
                                                Implementierung von Zugangsbeschränkungen und Content Filtern
                                            </li>
                                            <li>
                                                <u>Clientseitige</u> Lastverteilung
                                            </li>
                                        </lsx-ul>
                                    </lsx-card>
                                </lsx-col>
                            </lsx-row>
                        </lsx-grid-fluid>
                    </lsx-tab-page>
                </lsx-tab-pages>
            </div>
        </article>
    </section>
</section>

<section data-title="Anforderungen an verteilte Systeme">
    <section data-title="Allgemeine Anforderungen" class="centered-content">
        <lsx-grid-fluid class="limited-width2 p-0">
            <lsx-row>
                <lsx-col size="md" class="mb-3 mb-md-0">
                    <lsx-card bold img="02-architektur/anforderung-ressourcennutzung.jpg">
                        <h4>Optimale Ressourcennutzung</h4>
                        <p>
                            Das System muss effizient mit den Ressourcen umgehen und möglichst viele Ressourcen
                            für die eigentliche Anwendung zur Verfügung stellen. Die Anwendung muss ebenfalls
                            intelligent damit umgehen und sie gut nutzen.
                        </p>
                    </lsx-card>
                </lsx-col>
                <lsx-col size="md">
                    <lsx-card bold img="02-architektur/anforderung-stabilitaet.jpg">
                        <h4>Stabilität und Fehlertoleranz</h4>
                        <p>
                            Programmabstürze und unvorhersehbares Verhalten sind unbedingt zu vermeiden.
                            Beim Programmieren muss man daher neben den fachlichen Fehlern auch die Fehler
                            berücksichtigen, die sich aus der Verteilung ergeben.
                        </p>
                    </lsx-card>
                </lsx-col>
            </lsx-row>
            <lsx-row>
                <lsx-col size="md" class="mb-3 mb-md-0">
                    <lsx-card bold img="02-architektur/anforderung-skalierbarkeit.jpg">
                        <h4>Einfache Skalierbarkeit</h4>
                        <p>
                            Es muss einfach möglich sein, die Leistung des Systems zu erhöhen oder diese zu reduzieren,
                            wenn sie nicht mehr benötigt wird. Dies kann je nach System automatisch oder manuell erfolgen.
                        </p>
                    </lsx-card>
                </lsx-col>
                <lsx-col size="md">
                    <lsx-card bold img="02-architektur/anforderung-transparenz.jpg">
                        <h4>Einfache Nutzung (Transparenz)</h4>
                        <p>
                            Zumindest für den Anwender sollte die inheränte Komplexität des Systems verborgen bleiben.
                            Entwickler und Administratoren freuen sich aber auch, wenn sie sich nicht um jede Kleinigkeit
                            kümmern müssen.
                        </p>
                    </lsx-card>
                </lsx-col>
            </lsx-row>
            <lsx-row>
                <lsx-col size="md" class="mb-3 mb-md-0">
                    <lsx-card bold img="02-architektur/anforderung-erweiterbarkeit.jpg">
                        <h4>Einfache Erweiterbarkeit</h4>
                        <p>
                            Die Architektur muss flexibel genug sein, um einzelne Teile jederzeit austauschen oder
                            verbessern zu können.
                        </p>
                    </lsx-card>
                </lsx-col>
                <lsx-col size="md">
                    <lsx-card bold img="02-architektur/anforderung-sicherheit.jpg">
                        <h4>Sicherheit</h4>
                        <p>
                            Die Vertraulichkeit, Integrität und Authentizität des Systems und seiner Daten muss
                            gewährleistet bleiben.
                        </p>
                    </lsx-card>
                </lsx-col>
            </lsx-row>
            <lsx-row>
                <lsx-col size="md">
                    <small>
                        <small>
                            Bildnachweise:
                            <a href="https://pixabay.com/en/wallet-tape-measure-economical-levy-2383496/" target="_blank">Pixabay: Myriams-Fotos</a>,
                            <a href="https://pixabay.com/en/house-of-cards-fragile-patience-763246/" target="_blank">Pixabay: wilhei</a>,
                            <a href="https://pixabay.com/en/mixer-fader-digital-console-1631398/" target="_blank">Pixabay: michaelmep</a>,
                            <a href="https://pixabay.com/en/glass-water-napkin-sky-reflection-2875091/" target="_blank">Pixabay: Michael-T</a>,
                            <a href="https://pixabay.com/en/floor-plan-blueprint-house-home-1474454/" target="_blank">Pixabay: ElasticComputerFarm</a>,
                            <a href="https://pixabay.com/en/building-cctv-door-female-ladies-1839464/" target="_blank">Pixabay: Pexels</a>
                        </small>
                    </small>
                </lsx-col>
            </lsx-row>
        </lsx-grid-fluid>
    </section>

    <section data-title="Transparenz" class="centered-content">
        <lsx-grid-fluid class="limited-width2">
            <!-- Vergleich Wirtschaft vs. Informatik -->
            <lsx-row style="margin-bottom: 0;">
                <lsx-col size="md">
                    <h3>Transparenz in der Wirtschaft</h3>
                    <img src="02-architektur/transparenz1.jpg" alt="" class="img-thumbnail" style="width: 100%" />
                    Alle Informationen liegen offen.
                </lsx-col>
                <lsx-col size="md">
                    <h3>Transparenz in der Informatik</h3>
                    <img src="02-architektur/transparenz2.jpg" alt="" class="img-thumbnail" style="width: 100%" />
                    Ich muss nichts tun. Es läuft einfach.
                </lsx-col>
            </lsx-row>
            <lsx-row style="margin-bottom: 2.5em;">
                <lsx-col size="md">
                    <small>
                        <small>
                            Bildnachweise:
                            <a href="https://pixabay.com/en/tax-paperwork-accounting-business-739107/" target="_blank">Pixabay: stevepb</a>,
                            <a href="https://pixabay.com/en/dogs-carnival-humor-pet-ernst-1190015/" target="_blank">Pixabay: Chiemsee2016</a>,
                            <a href="https://pixabay.com/en/background-christmas-3009949/" target="_blank">Pixabay: monicore</a>
                        </small>
                    </small>
                </lsx-col>
            </lsx-row>
    
            <!-- Die neun Arten der Transparenz -->
            <lsx-row>
                <lsx-col size="md">
                    <lsx-accordion>
                        <lsx-accordion-page title="Zugriffstransparenz" bold>
                            <lsx-grid-fluid class="p-0">
                                <lsx-row>
                                    <lsx-col size="md">
                                        Falls eine Anwendung zwischen lokalen (auf dem eigenen Rechner befindlichen) und
                                        entfernten Ressourcen unterscheidet, müssen beide auf dieselbe Art und Weise
                                        nutzbar sein.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-foto.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Eine Fotoverwaltung ermöglicht den Zugriff auf lokal gespeicherte Fotoalben.
                                        Einzelne Bilder oder ganze Alben können aber auch auf einem entfernten Server
                                        abgelegt sein, ohne dass sich die Bedienung hierdurch verändert.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-video.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Eine Video-Streaming-App ermöglicht es, einzelne Videos vor dem Anschauen herunterzuladen,
                                        damit diese auch bei langsamer Internetverbindung ruckelfrei abgespielt werden können.
                                        Suche und Wiedergabe der Videos verändern sich aus Benutzersicht dadurch aber nicht, da
                                        die Videos wie gewohnt aufgerufen und abgespielt werden können.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-pwa.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Progressive Web Apps sind Webanwendungen, die nach dem ersten Aufruf im Browser auch lokal installiert
                                        werden können. Sämtliche Dateien werden hierfür in einen lokalen Anwendungscache geladen, der auch offline
                                        funktioniert. Die Entscheidung, ob eine Datei vom Server oder aus dem Cache geladen werden kann, erfolgt
                                        dabei automatisch, ohne dass dies im Quellcode berücksichtigt werden muss.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md">
                                        <small>
                                            <small>
                                                Bildnachweise:
                                                <a href="https://pixabay.com/photos/retro-photo-album-memory-family-1483781/" target="_blank">Pixabay: klimkin</a>,
                                                <a href="https://pixabay.com/photos/camera-video-tv-video-realization-1598620/" target="_blank">Pixabay: JosepMonter</a>,
                                                <a href="https://pixabay.com/photos/laptop-workstation-browsing-tablet-1483974/" target="_blank">Pixabay: Monoar</a>
                                            </small>
                                        </small>
                                    </lsx-col>
                                </lsx-row>
                            </lsx-grid-fluid>
                        </lsx-accordion-page>
    
                        <lsx-accordion-page title="Ortstransparenz" bold>
                            <lsx-grid-fluid class="p-0">
                                <lsx-row>
                                    <lsx-col size="md">
                                        Dienste und Ressourcen einer Anwendung können aufgerufen werden, ohne wissen zu müssen,
                                        auf welchem Rechner sie sich befinden.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-cdn.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Um die Ladezeit einer Webseite zu optimieren, werden häufig benötigte Dateien durch
                                        Content Delivery Networks ausgeliefert. Hierfür betreiben die Content Delivery Networks
                                        weltweit gespiegelte Rechenzentren, von denen automatisch das mit der kürzesten Zugriffszeit
                                        ausgewählt wird. Auf dieselbe Weise spielen nebenbei auch Video-Streaming-Portale und andere
                                        Onlinedienste ihre Inhalte aus.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-dns.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Die Webseite der DHBW Karlsruhe ist immer unter der Domain
                                        <a href="https://karlsruhe.dhbw.de" target="_blank">karlsruhe.dhbw.de</a> erreichbar.
                                        Zwar muss die Domain zum Aufruf der Seite bekannt sein, diese enthält jedoch keine Informationen
                                        darüber, auf welchen Rechner hierfür zugegriffen werden muss. Diese Information besorgt sich der
                                        Browser stattdessen durch ein DNS-Lookup.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-drucker.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        <a href="https://en.wikipedia.org/wiki/Zero-configuration_networking" target="_blank">Zeroconf</a> ermöglicht die
                                        automatische Konfiguration von Netzwerkgeräten, wodurch unter anderem auch netzwerkfähige Drucker und Scanner
                                        vom Betriebssystem erkannt und eingerichtet werden können. Selbst wenn ein Gerät komplett ausgetauscht wird,
                                        muss die Konfiguration auf dem Anwender-PC nicht angepasst werden.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md">
                                        <small>
                                            <small>
                                                Bildnachweise:
                                                <a href="https://pixabay.com/photos/earth-planet-front-side-back-11593/" target="_blank">Pixabay: WikiImages</a>,
                                                <a href="https://pixabay.com/illustrations/webdesign-design-web-website-3411373/" target="_blank">Pixabay: kreatikar</a>,
                                                <a href="https://pixabay.com/photos/printer-desk-office-fax-scanner-790396/" target="_blank">Pixabay: stevepb</a>
                                            </small>
                                        </small>
                                    </lsx-col>
                                </lsx-row>
                            </lsx-grid-fluid>
                        </lsx-accordion-page>
    
                        <lsx-accordion-page title="Mobilitätstransparenz" bold>
                            <lsx-grid-fluid class="p-0">
                                <lsx-row>
                                    <lsx-col size="md">
                                        Die Ressourcen einer verteilten Anwendung können jederzeit auf andere Maschinen
                                        umziehen, ohne dass sich dies auf die Anwendung auswirkt.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-namensdienst.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Namensdienste wie das Domain Name System ermöglichen es, die damit verwalteten
                                        Ressourcen jederzeit umzuziehen, da die exakte Adresse einer Ressource vor jedem
                                        Zugriff darin nachgeschlagen werden muss. Aus diesem Grund kann sich zum Beispiel
                                        die IP-Adresse einer Webseite jederzeit ändern, ohne dass die meisten Besucher*innen
                                        dies merken.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-backend.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Die Datenbank einer Webanwendung wurde bisher auf derselben Maschine wie der Webserver betrieben,
                                        soll nun aber auf eigene Hardware umziehen. Die Anwendung läuft nach dem Umzug wie gewohnt weiter,
                                        da lediglich ein Eintrag in einer Konfigurationsdatei geändert werden musste. Die Entscheidung
                                        der Programmierer, die Adresse des Datenbankservers nicht hart-codiert im Quellcode zu hinterlegen,
                                        hat sich an diesem Tag als sehr weitsichtig herausgestellt.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-vm.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Der <a href="https://de.wikipedia.org/wiki/Hypervisor" target="_blank">Hypervisor</a> einer
                                        Virtualisierungslösung entscheidet, eine virtuelle Maschine auf einen leistungsfähigeren
                                        Rechenknoten umzuziehen. Hierfür wird die VM ohne Unterbrechung des laufenden Betriebs auf
                                        den neuen Host kopiert und dort weiter ausgeführt.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md">
                                        <small>
                                            <small>
                                                Bildnachweise:
                                                <a href="https://pixabay.com/photos/diary-appointment-address-pen-2080422/" target="_blank">Pixabay: jackmac34</a>,
                                                <a href="https://pixabay.com/photos/server-cloud-development-business-1235959/" target="_blank">Pixabay: ColossusCloud</a>,
                                                <a href="https://pixabay.com/illustrations/cloud-computing-network-internet-2001090/" target="_blank">Pixabay: wynpnt</a>
                                            </small>
                                        </small>
                                    </lsx-col>
                                </lsx-row>
                            </lsx-grid-fluid>
                        </lsx-accordion-page>
    
                        <lsx-accordion-page title="Persistenztransparenz" bold>
                            <lsx-grid-fluid class="p-0">
                                <lsx-row>
                                    <lsx-col size="md">
                                        Besonders benutzerfreundliche Anwendungen unterscheiden nicht zwischen gespeicherten und
                                        und nicht gespeicherten Daten. Die Speicherung erfolgt automatisch im Hintergrund.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-google.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Cloudbasierte Officepakete wie Google Docs besitzen keinen Menüeintrag zum Speichern
                                        eines Dokuments. Jede Änderung wird mit einem kleinen Zeitversatz automatisch gespeichert,
                                        so dass man nie wieder etwas verlieren kann, wenn man Abends zu schnell aus dem Büro flieht.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md">
                                        <small>
                                            <small>
                                                Bildnachweis:
                                                <a href="https://pixabay.com/illustrations/google-search-engine-browser-search-76517/" target="_blank">Pixabay: Simon</a>
                                            </small>
                                        </small>
                                    </lsx-col>
                                </lsx-row>
                            </lsx-grid-fluid>
                        </lsx-accordion-page>
    
                        <lsx-accordion-page title="Replikationstransparenz" bold>
                            <lsx-grid-fluid class="p-0">
                                <lsx-row>
                                    <lsx-col size="md">
                                        Aus Performancegründen oder zur Erhöhung der Ausfallsicherheit werden wichtige Daten auf
                                        mehrere Rechenknoten repliziert. Die Datenreplikation erfolgt vollautomatisch im Hintergrund,
                                        wobei das System bei jeder Änderung die Aktualisierung aller Kopien sicherstellt.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-weltkarte.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Weltweit genutzte Anwendungen wie die Googlesuche, Facebook oder Instagram werden in global
                                        verteilten Rechenzentren betrieben, um die Ladezeiten zu verkürzen. Die innerhalb der Anwendung
                                        anfallenden Daten werden deshalb automatisch zwischen den Rechenzentren repliziert, damit jede*r
                                        Anwender*in möglichst dieselben Daten sieht.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-datenbank.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Die meisten Datenbanken erlauben einen automatischen Cluster-Betrieb, wodurch alle Daten auf mehrere
                                        Rechenknoten gespiegelt werden. Lesende Anfragen werden dann von irgend einem gerade verfügbaren Knoten
                                        beantwortet, während ändernde Anfragen an alle Knoten weitergereicht werden.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md">
                                        <small>
                                            <small>
                                                Bildnachweise:
                                                <a href="https://www.openstreetmap.org/#map=2/18.1/-20.7&layers=C" target="_blank">OpenStreetMap</a>,
                                                <a href="https://pixabay.com/photos/info-data-disk-server-database-1641937/" target="_blank">pixabay: FreePhotosART</a>,
                                            </small>
                                        </small>
                                    </lsx-col>
                                </lsx-row>
                            </lsx-grid-fluid>
                        </lsx-accordion-page>
    
                        <lsx-accordion-page title="Fehlertransparenz" bold>
                            <lsx-grid-fluid class="p-0">
                                <lsx-row>
                                    <lsx-col size="md">
                                        Fehlersituationen werden nicht als Ausnahme sondern als Normalfall betrachtet.
                                        Eine Anwendung sollte daher immer so entworfen werden, dass sie möglichst viele
                                        Fehlersituationen abfangen und automatisch korrigieren kann. Keinesfalls darf
                                        eine Anwendung einfach abstürzen, wenn ein Weiterbetrieb prinzipiell möglich ist.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-email.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Eine E-Mail kann nicht sofort zugestellt werden, da das Postfach des Empfängers
                                        voll ist. Der Mailserver des Senders teilt deshalb mit, die Zustellung innerhalb
                                        der nächsten Tage zu wiederholen. Nur, wenn die Nachricht nach fünf Tagen immer
                                        noch nicht zugestellt wurde, wird der Absender über das endgültige Scheitern
                                        informiert.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-wetterstation.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Eine Wetterstation sammelt kontinuierlich Daten und sendet diese via UMTS an einen zentralen
                                        Server. Bei schlechtem Wetter besteht allerdings nur eine unzuverlässige Internetverbindung,
                                        so dass die Daten nicht immer sofort verschickt werden können. Sämtliche Daten werden daher
                                        in einem internen Ringbuffer gesammelt und so lange an den Server geschickt, bis dieser den
                                        Empfang bestätigt.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-apollo11.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Bereits bei den Apollo-Mondmissionen waren alle Computersysteme mehrfach redundant ausgelegt,
                                        so dass bei Versagen eines Teilsystems dieses vollautomatisch ersetzt werden konnte. Der
                                        <a href="https://en.wikipedia.org/wiki/Saturn_Launch_Vehicle_Digital_Computer" target="_blank">Saturn
                                        Launch Vehicle Digial Computer</a> führte sogar jede Berechnung dreifach redundant aus und
                                        arbeitete stets mit dem Mehrheitsergebnis weiter, um katastrophale Folgen aufgrund von
                                        Hardwarefehlern zu vermeiden.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md">
                                        <small>
                                            <small>
                                                Bildnachweise:
                                                <a href="https://unsplash.com/photos/oeDH20DVb2A" target="_blank">Unsplash: Liam Truong</a>,
                                                <a href="https://pixabay.com/photos/anemometer-weather-station-3977718/" target="_blank">Pixabay: RitaE</a>,
                                                <a href="https://de.wikipedia.org/wiki/Datei:Apollo_11_rollout.jpg" target="_blank">Wikipedia: NASA</a>
                                            </small>
                                        </small>
                                    </lsx-col>
                                </lsx-row>
                            </lsx-grid-fluid>
                        </lsx-accordion-page>
    
                        <lsx-accordion-page title="Nebenläufigkeitstransparenz" bold>
                            <lsx-grid-fluid class="p-0">
                                <lsx-row>
                                    <lsx-col size="md">
                                        Eine verteilte Anwendung sollte immer so entworfen werden, dass sie von vielen Benutzern
                                        gleichzeitig genutzt werden kann. Hierfür notwendige Sperren und Synchronisationsmechanismen
                                        sollten dabei vor den Anwender*innen verborgen im Hintergrund ablaufen.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-wikipedia.svg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Wikipedia verarbeitet pro Sekunde zwischen 25.000 und 60.000 Seitenzugriffe. Da die meisten
                                        Zugriffe nur lesend erfolgen, kann jeder Artikel auch dann gelesen werden, wenn er gerade von
                                        jemand anderem bearbeitet wird. Bearbeiten zwei Personen gleichzeitig denselben Artikel, wird
                                        beim Speichern ein Bearbeitungskonflikt angezeigt, der manuell aufgelöst werden muss.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-etherpad.png" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Kollaborative Anwendungen wie Etherpad erlauben es mehreren Personen, gleichzeitig am selben
                                        Dokument zu arbeiten. Jede Person sieht dabei in Echtzeit die von den anderen vorgenommenen
                                        Änderungen, weshalb auch niemand ein Dokument exklusiv sperren kann.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-couchdb.svg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        CouchDB kennt keine Datenbanksperren, um gleichzeitige Änderungen an einem Datensatz zu vermeiden.
                                        Tritt ein Konflikt auf, legt die Datenbank einfach zwei Versionen desselben Datensatzes an. Es obliegt
                                        dem Anwendungscode die Versionen bei Bedarf wieder zusammenzuführen.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md">
                                        <small>
                                            <small>
                                                Bildnachweise:
                                                <a href="https://commons.wikimedia.org/wiki/File:Wikipedia-logo-v2.svg" target="_blank">Wikimedia: Nohat</a>,
                                                <a href="https://etherpad.org/" target="_blank">etherpad.org</a>,
                                                <a href="https://commons.wikimedia.org/wiki/File:CouchDB.svg" target="_blank">Wikimedia: Apache Software Foundation</a>
                                            </small>
                                        </small>
                                    </lsx-col>
                                </lsx-row>
                            </lsx-grid-fluid>
                        </lsx-accordion-page>
    
                        <lsx-accordion-page title="Skalierbarkeitstransparenz" bold>
                            <lsx-grid-fluid class="p-0">
                                <lsx-row>
                                    <lsx-col size="md">
                                        Verteilte Systeme und Anwendungen sollten immer skalierbar sein. Im Idealfall könnnen im
                                        laufenden Betrieb Ressourcen hinzugefügt oder entfernt werden, um die Leistung anzupassen.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-linux.svg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Unter Linux bildet der
                                        <a href="https://de.wikipedia.org/wiki/Logical_Volume_Manager" target="_blank">Logical Volume Manager</a>
                                        eine Abstraktionsschicht zwsichen den tatsächlich auf einem Datenträger vorhandenen Partitionen und den
                                        für das Betriebssystem sichtbaren Dateisystemen. Dadurch wird es möglich, ein Dateisystem jederzeit durch
                                        Hinzufügen weiterer Datenträger zu vergrößern.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-lastverteilung.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Im einfachsten Fall befinden sich die Dateien einer Webseite auf einem zentralen Webserver, von
                                        dem sie abgerufen werden können. Sollen jedoch sehr viele Anfragen gleichzeitig behandelt werden,
                                        können diese über eine vorgeschaltete Lastverteilung auf mehrere Server verteilt werden. Die
                                        Leistungsfähigkeit kann dabei jederzeit durch Starten und Stoppen weiterer Server angepasst werden.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md">
                                        <small>
                                            <small>
                                                Bildnachweise:
                                                <a href="https://pixabay.com/vectors/avatar-beak-black-cute-emotion-1295404/" target="_blank">Pixabay: OpenClipart-Vectors</a>,
                                                <a href="https://pixabay.com/illustrations/vpn-server-router-virtual-firewall-3406770/" target="_blank">Pixabay: kreatikar</a>
                                            </small>
                                        </small>
                                    </lsx-col>
                                </lsx-row>
                            </lsx-grid-fluid>
                        </lsx-accordion-page>
    
                        <lsx-accordion-page title="Leistungstransparenz" bold>
                            <lsx-grid-fluid class="p-0">
                                <lsx-row>
                                    <lsx-col size="md">
                                        Die Leistung eines verteilten Systems sollte nur von den verfügbaren Ressourcen begrenzt
                                        sein. Innerhalb der gegebenen Grenzen sorgt das System dann selbstständig und ohne manuelle
                                        Eingriffe dafür, die vorhandene Kapazität bedarfsgerecht anzupassen.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-cloud.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Cloudangebote unterscheiden sich vom traditionallen Hosting insbesondere durch die automatische
                                        Skalierbarkeit und nutzungsabhängige Abrechnung aller Dienste. Die meisten Anbieter erlauben daher,
                                        Regeln zu definieren, bei welcher Auslastung weitere Kapazitäten hinzugefügt oder wieder entfernt
                                        werden sollen. Einrichtung, Start und Stopp der notwendigen Rechenknoten laufen hierfür komplett
                                        automatisiert.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-3dfilm.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Nicht nur in Forschung und Wissenschaft sondern auch in der Filmwirtschaft werden Clustersysteme
                                        zur Bewerkstelligung der anfallenden Rechenaufgaben eingesetzt. Diese besitzen einen Job Scheduler
                                        zum Einspiesen abzuarbeitender Aufgaben. Die zur Verfügung stehende Rechenleistung teilt der Scheduler
                                        automatisch auf alle aktiven Jobs auf. Sind zu einem Zeitpunkt nur wenige Jobs aktiv, laufen diese daher
                                        schneller durch, als wenn viele Jobs gleichzeitig laufen sollen.
                                    </lsx-col>
                                </lsx-row>
                                <div class="row">
                                    <div class="col">
                                        <small>
                                            <small>
                                                Bildnachweise:
                                                <a href="https://pixabay.com/photos/field-clouds-sky-agriculture-533541/" target="_blank">Pixabay: pcdazero</a>,
                                                <a href="https://pixabay.com/illustrations/super-woman-flying-3d-figure-female-1885016/" target="_blank">Pixabay: perianjs</a>
                                            </small>
                                        </small>
                                    </div>
                                </div>
                            </lsx-grid-fluid>
                        </lsx-accordion-page>
                    </lsx-accordion>
                </lsx-col>
            </lsx-row>
        </lsx-grid-fluid>
    </section>

    <section data-title="Skalierbarkeit">
        <!-- 1. Skalierungsarten, 2. Busbeispiel, 3. Render Farm -->
        <article class="centered-content">
            <div class="limited-width2">
                <div class="d-md-flex flex-wrap gap-3 align-items-center mb-5">
                    <img src="02-architektur/skalierung.png" class="d-block w-100" style="flex: 1;">
                    <div class="markdown" style="flex: 2;">
                        Ein typischer Anwendungsfall für verteilte Systeme ist die Skalierung einer Anwendung,
                        die auf einem einzelnen Rechner ausgeführt zu lange laufen würde. Zwar kann man den
                        Rechner zunächst versuchen, **vertikal zu skalieren**, indem man mehr Ressourcen hinzugefügt
                        (z.B. eine stärkere CPU), dies stößt aber schnell an seine Grenzen. Mit **horizontaler Skalierung**
                        können hingegen beliebig viele, weitere Rechnerknoten hinzugefügt werden, um die Leistung
                        unbegrenzt zu erhöhen.
                    </div>
                </div>

                <div class="centered-content flex-row flex-wrap gap-3">
                    <!-- Fallbeispiel: Omnibus -->
                    <lsx-modal>
                        <lsx-thumbnail style="height: 14em;" class="mw-100">
                            <img src="02-architektur/omnibus3.jpg" class="d-block h-100 mw-100 dhbw-thumbnail"/>
                        </lsx-thumbnail>
                        <lsx-content>
                            <lsx-card title="Fallbeispiel: Omnibus" bold class="mh-100 mw-100">
                                <lsx-card-body class="overflow-scroll">
                                    <lsx-ul class="lead">
                                        <li>In der realen Welt kennen wir Gelenkbusse und Doppeldeckerbusse.</li>
                                        <li>Doch mehr wie zwei Gelenke und zwei Decks sind praktisch nicht handhabbar.</li>
                                        <li>Dreistöckige Busse gibt es daher nur bei Harry Potter und KI-generierten Bildern.</li>
                                        <li>Mehrere Busse zu betreiben ist hoch vorteilhaft bei (un)geplanten Ausfällen wegen Wartung, Unfall, …</li>
                                    </lsx-ul>

                                    <div class="d-flex flex-wrap justify-content-center align-items-center gap-3">
                                        <img src="02-architektur/omnibus1.jpg" class="img-thumbnail d-block h-100" style="max-height: 40vh;"/>
                                        <img src="02-architektur/omnibus2.jpg" class="img-thumbnail d-block h-100" style="max-height: 40vh;"/>
                                        <img src="02-architektur/omnibus3.jpg" class="img-thumbnail d-block h-100" style="max-height: 40vh;"/>
                                    </div>
                                    <p>
                                        <small>
                                            <small>
                                                Bildnachweise:
                                                Bing Image Creator,
                                                Bing Image Creator,
                                                <a href="https://commons.wikimedia.org/wiki/File:2012-08-08_Doppelgelenkbus_Hamburger_Hochbahn.jpg" targegt="_blank">Wikipedia: Wo st 01</a>
                                            </small>
                                        </small>
                                    </p>
                                </lsx-card-body>
                            </lsx-card>
                        </lsx-content>
                    </lsx-modal>
    
                    <!-- Fallbeispiel: Render Farm -->
                    <lsx-modal>
                        <lsx-thumbnail style="height: 14em;" class="mw-100">
                            <img src="02-architektur/renderfarm1.jpg" class="d-block h-100 mw-100 dhbw-thumbnail"/>
                        </lsx-thumbnail>
                        <lsx-content>
                            <lsx-card title="Fallbeispiel: Render Farm" bold class="mh-100 mw-100">
                                <lsx-card-body class="overflow-scroll">
                                    <div class="lead">
                                        <p>
                                            Abendfüllende 3D-Animationsfilme zu rendern ist eine monumentale Aufgabe
                                        </p>
                                        <h5>Gedankenexperiment</h5>
                                        <lsx-ul class="mb-4">
                                            <li>25 Bilder/Sekunde ✕ 60 Sekunden ✕ 120 Minuten = 180.000 Einzelbilder</li>
                                            <li>Typische 8k-Auflösung im Kino: 8192 ✕ 4320 Pixel = 35.389.440 Pixel je Einzelbild</li>
                                            <li><a href="https://de.wikipedia.org/wiki/Raytracing" target="_blank">Raytracing</a> mit ca. 120 Rekursionen je Pixel: 4.246.732.800 tatsächlich zu berechnende Pixel</li>
                                            <li>Frage: Wie lange dauert es im Schnitt, einen typischen Film zu rendern?</li>
                                        </lsx-ul>
                                        <p>
                                            Bild rechts: Renderfarm bei Pixar im Jahr 1995. Auf einer solchen Render Farm wurde Toy Story gerechnet.
                                        </p>
                                    </div>
                                    <div class="d-flex flex-wrap justify-content-center align-items-center gap-3">
                                        <img src="02-architektur/renderfarm1.jpg" class="img-thumbnail d-block h-100" style="max-height: 30vh;"/>
                                        <img src="02-architektur/renderfarm2.jpg" class="img-thumbnail d-block h-100" style="max-height: 30vh;"/>
                                    </div>
                                    <p>
                                        <small>
                                            <small>
                                                Bildnachweise:
                                                <a href="http://nullisland.blot.im/pixar-render-farm-1995" target="_blank">nullisland.blot.im</a>,
                                                <a href="https://pixabay.com/photos/screw-thread-technology-mother-1924219/" target="_blank">Pixabay: PIRO4D</a>
                                            </small>
                                        </small>
                                    </p>
                                </lsx-card-body>
                            </lsx-card>
                        </lsx-content>
                    </lsx-modal>
    
                    <!-- Fallbeispiel: Supercomputer -->
                    <lsx-modal>
                        <lsx-thumbnail style="height: 14em;" class="mw-100">
                            <img src="02-architektur/supercomputer2.jpg" class="d-block h-100 mw-100 dhbw-thumbnail"/>
                        </lsx-thumbnail>
                        <lsx-content>
                            <lsx-card title="Fallbeispiel: Supercomputer" bold class="mh-100 mw-100">
                                <lsx-card-body class="overflow-scroll">
                                    <p class="lead" style="text-align: justify;">
                                        Hochleistungsrechner, wie sie in der Forschung und Wissenschaft oder von großen Internetkonzernen
                                        genutzt werden, bestehen aus einem reisigen Cluster kleiner Computer mit eigenem Hauptspeicher und
                                        in der Regel auch eigenem Massenspeicher. Die Einzelcomputer werden dabei in Storage Nodes zur
                                        Speicherung von Daten und in Compute Nodes zur Bereitstellung von Rechenleistung unterschieden. 
                                    </p>
                                    </lsx-ul>
                                    <div class="d-flex flex-wrap justify-content-center align-items-center gap-3">
                                        <img src="02-architektur/supercomputer1.svg" class="img-thumbnail d-block h-100" style="max-height: 30vh;"/>
                                        <img src="02-architektur/supercomputer2.jpg" class="img-thumbnail d-block h-100" style="max-height: 30vh;"/>
                                    </div>
                                    <p>
                                        <small>
                                            <small>
                                                Bildnachweis (Foto):
                                                <a href="https://de.wikipedia.org/wiki/Blue_Gene#/media/File:IBM_Blue_Gene_P_supercomputer.jpg" target="_blank">Wikimedia Commons: Argonne National Laboratory</a>
                                            </small>
                                        </small>
                                    </p>
                                </lsx-card-body>
                            </lsx-card>
                        </lsx-content>
                    </lsx-modal>
                </div>
            </div>
        </article>
    </section>

    <section data-title="Resilienz">
        <article class="centered-content">
            <div class="limited-width">
                <div class="markdown mb-4">
                    Verteilte Systeme können darüber hinaus helfen, die Resilienz einer Anwendung zu erhöhen,
                    indem **Single Point of Failure** vermieden werden (durch horizontale Skalierung) und
                    Redundanzen geschaffen werden, so dass bei Ausfall eines Knotens, ein anderer Knoten
                    übernehmen kann (bspw. als **Hot-Standby**).
                </div>

                <lsx-info-box type="warning" class="mb-4">
                    Neben der Rechenleistung muss auch die Plattenkapazität redundant ausgelegt werden, um
                    Datenverluste zu vermeiden, wodurch wiederum das Problem anfällt, die Datenbestände
                    synchron zu halten.
                </lsx-info-box>

                <lsx-accordion>
                    <lsx-accordion-page title="Single Poirnt of Failure" bold>
                        <img src="02-architektur/resilienz1.png" class="d-block w-100"/>
                    </lsx-accordion-page>
                    <lsx-accordion-page title="Vollständig redundante Architektur" bold>
                        <img src="02-architektur/resilienz2.png" class="d-block w-100"/>
                    </lsx-accordion-page>
                </lsx-accordion>
            </div>
        </article>
    </section>

    <section data-title="Beispiel: Cloud-Betrieb">
        <article>
            <lsx-grid-fluid class="p-0">
                <lsx-row>
                    <lsx-col size="md-9" class="mb-3">
                        <img src="02-architektur/cloud-betriebsmodell.png" class="d-block w-100" />
                    </lsx-col>
                    <lsx-col size="md" class="d-flex flex-column gap-3">
                        <lsx-card title="Automatisierung" bold class="small">
                            Die Grundidee der Cloud ist, die Bereitstellung und den Betrieb verteilter
                            Anwendungen so weit wie möglich zu automatisieren. Eine Cloudumgebung besteht
                            daher aus einem großen Rechencluster, dessen Ressourcen auf viele Anwendungen
                            aufgeteilt werden. Manuelle Installationsschritte sollen vermieden werden.
                        </lsx-card>
        
                        <lsx-card title="Skalierung und Elastizität" bold class="small">
                            Über eine Cloud-Umgebung bereitgestellte Anwendungen können, zumindest bei den größeren
                            Anbietern, vollkommen elastisch skaliert werden. Hierfür überwacht die Cloud-Plattform
                            regelmäßig vorab definierte Kennzahlen einer Anwendung und fährt bei Bedarf weitere
                            Service-Instanzen hoch oder runter.
                        </lsx-card>
                    </lsx-col>
                </lsx-row>
            </lsx-grid-fluid>
        </article>
    </section>
</section>

<section data-title="Typische Herausforderungen">
    <section data-title="Verfügbarkeit und Leistung">
        <article>
            <lsx-grid-fluid>
                <lsx-row>
                    <lsx-col size="lg-7">
                        <div style="height: 100%; display: flex; align-items: center;">
                            <div class="markdown">
                                #### Die acht Irrtümer verteilter Systeme

                                1. Das Netzwerk ist immer verfügbar.
                                1. Es gibt keine Latenzzeiten.
                                1. Der Datendurchsatz ist unendlich schnell.
                                1. Die Kommunikation ist automatisch sicher.
                                1. Die Netzwerktopologie ist unveränderlich.
                                1. Es gibt nur einen Administrator.
                                1. Datentransfer kostet nichts.
                                1. Das Netzwerk ist homogen.
                            </div>
                        </div>
                    </lsx-col>
                    <lsx-col size="lg">
                        <img src="02-architektur/dilbert-1997-01-28.gif" class="d-block w-100 mb-3" />
                        <img src="02-architektur/dilbert-1997-01-29.gif" class="d-block w-100 mb-3" />
                        <img src="02-architektur/dilbert-2018-03-22.gif" class="d-block w-100 mb-3" />
        
                        <small>
                            <small>
                                Bildnachweise:
                                <a href="https://dilbert.com/strip/1997-01-28" target="_blank">Dilbert vom 28.01.1997</a>,
                                <a href="https://dilbert.com/strip/1997-01-29" target="_blank">Dilbert vom 29.01.1997</a>,
                                <a href="https://dilbert.com/strip/2018-03-22" target="_blank">Dilbert vom 22.03.2018</a>
                            </small>
                        </small>
                    </lsx-col>
                </lsx-row>
            </lsx-grid-fluid>
        </article>
    </section>

    <section data-title="Verteilte Transaktionen">
        <article class="centered-content">
            <div class="limited-width2">
                <lsx-tab-pages>
                    <lsx-tab-page title="Problemstellung">
                        <lsx-grid-fluid class="p-0">
                            <lsx-row>
                                <lsx-col size="md-8">
                                    <p>
                                        Von nicht-verteilten Systemen bzw. der klassischen Datenbankprogrammierung kennen wir die
                                        ACID-Kriterien für datenändernde Transaktionen:
                                    </p>
                                    <lsx-ul class="dhbw-list-spacious">
                                        <li>
                                            <b>Atomicity:</b> Eine Transaktion wird ganz oder gar nicht ausgeführt.
                                        </li>
                                        <li>
                                            <b>Consistency:</b> Vor und nach der Transaktion sind die Daten zu 100% konsistent.
                                        </li>
                                        <li>
                                            <b>Isolation:</b> Jede Transaktion läuft isoliert. Ihre Änderungen werden erst nachträglich sichtbar.
                                        </li>
                                        <li>
                                            <b>Durability:</b>Einmal bestätigte Änderungen bleiben ohne manuelles Zutun dauerhaft erhalten.
                                        </li>
                                    </lsx-ul>
                                    <p>
                                        Grundsätzlich gibt es keinen Grund, warum dies nicht auch für verteilte Transaktionen, bei denen
                                        zusammengehörige Daten auf unterschiedlichen Rechnerknoten geändert werden, erwünscht sein sollte.
                                        Die Frage ist nur:
                                    </p>
                                    <lsx-info-box>
                                        Lassen sich ACID-Transaktionen in verteilten Systemen überhaupt realisieren?
                                    </lsx-info-box>
                                </lsx-col>

                                <lsx-col size="md">
                                    <img src="02-architektur/acid-transaction.jpg" alt="" class="img-thumbnail d-block w-100">
                                    <p class="fs-6">
                                        ACID-Transaktionen auf <a href="https://de.wikipedia.org/wiki/Klingonische_Sprache" target="_blank">klingonisch</a>.
                                        Abstrakte Konzepte und Schriftzeichen funktionieren mit KI-Bildgeneratoren aktuell noch nicht gut.
                                    </p>
                                </lsx-col>
                            </lsx-row>
                        </lsx-grid-fluid>
                    </lsx-tab-page>

                    <lsx-tab-page title="Zwei-Phasen-Commit">
                        <div class="markdown dhbw-text-columns mb-4" detail-content>
                            Das Zwei-Phasen-Commit-Protokoll ist ein früher Versuch, die ACID-Kriterien auf verteilte
                            Transaktionen anzulegen. Die Transaktionen werden hierfür durch einen zusätzlichen Knoten,
                            der „Koordinator” genannt wird, gesteuert. Er steuert den gesamten Ablauf, sorgt darfür,
                            dass alle beteiligten Ressourcen exklusiv gesperrt werden (sog. pessimistisches Verhalten)
                            und trfft die finale Entscheidung über den Status der Transaktion. Die finale Entscheidung
                            über Bestätigung oder Ablehnung wird dabei in zwei Phasen getroffen:

                            <lsx-ul>
                                <li><b>Phase 1:</b> Vote (Abstimmung)</li>
                                <li><b>Phase 2:</b> Commit (Bestätigung)</li>
                            </lsx-ul>
                        </div>
                        
                        <img src="02-architektur/2-phase-commit-ablauf.png" class="img-thumbnail d-block mw-100 m-auto" style="width: 30em;"/>

                        <p>
                            <small>
                                <small>
                                    Bildnachweise: Bing Image Creator und
                                    <a href="https://pixabay.com/vectors/crown-golden-royal-shining-shiny-312734/" target="_blank">Pixabay: Clker-Free-Vector-Images</a>
                                </small>
                            </small>
                        </p>
                    </lsx-tab-page>

                    <lsx-tab-page title="Mögliche Probleme">
                        <div class="markdown dhbw-text-columns mb-4" detail-content>
                            Der Zwei-Phasen-Commit soll die ACID-Kriterien für verteilte Transaktionen sicherstellen.
                            Jedoch lässt sich dies mit diesem Protokoll nicht 100%ig erzielen, da insbesondere der
                            Ausfall einer der beteiligten Knoten zu inkonsistenten Ständen führt, die oft nur durch
                            manuelles Eingreifen behebbar sind.

                            Schauen wir uns zum Verständis eine Transaktion mit dem Zwei-Phasen-Commit-Protokoll
                            aus der realen Welt an und überlegen, was bei Ausfall einer der Beteiligten passieren kann.
                        </div>

                        <lsx-grid-fluid class="p-0">
                            <lsx-row>
                                <lsx-col size="md">
                                    <img src="02-architektur/2-phase-commit-1.jpg" class="img-thumbnail d-block w-100 mb-2"/>
                                    <lsx-info-box>
                                        Der Standesbeamte fällt vorzeitig aus
                                    </lsx-info-box>
                                </lsx-col>

                                <lsx-col size="md">
                                    <img src="02-architektur/2-phase-commit-2.jpg" class="img-thumbnail d-block w-100 mb-2"/>
                                    <lsx-info-box>
                                        Die Braut wird in letzter Sekunde ohnmächtig
                                    </lsx-info-box>
                                </lsx-col>
                            </lsx-row>
                        </lsx-grid-fluid>

                        <div class="markdown dhbw-text-columns mb-4" detail-content>
                            Im ersten Fall hängt die Transaktion, und das Paar ist verheiratet aber auch nicht verheiretet.
                            Da der „Koodinator“, wie man den Standesbeamten beim Zwei-Phasen-Commit nennen würde, ausgefallen
                            ist, bleibt die Transaktion bis auf unbestimmte Zeit hängen. Im zweiten Fall kann der Koordinator
                            immerhin einen Timeout feststellen und die Zeremonie zu einem späteren Zeitpunkt wiederholen.
                        </div>
                    </lsx-tab-page>
    
                    <lsx-tab-page title="Das CAP-Theorem">
                        <div class="dhbw-text-columns mb-4" detail-content>
                            Das CAP-Theorem nach Eric Brewer (2000) belegt, dass eine verteilte Anwendung immer nur zwei der
                            folgenden Kriterien vollständig erfüllen kann. Zwar wird die dritte Bedingung nicht vollständig
                            aufgegeben, muss aber zumindest in Teilen aufgeweicht werden. Frühe Protokolle wie der
                            Zwei-Phasen-Commit entsprechen beispielsweise einem Versuch, an verteilte Systeme dieselben
                            ACID-Transaktionsbedingungen wie an nicht verteilte Systeme anzulegen. Dies ist möglich. Wie wir
                            aber eben gesehen haben, geht dies nicht ohne Kompromisse bei der Partitionstoleranz.
                        </div>

                        <lsx-grid-fluid>
                            <lsx-row>
                                <lsx-col size="md-5">
                                    <img src="02-architektur/cap-theorem.png" alt="Visualisierung des CAP-Theorems" style="width: 100%;" />
                                </lsx-col>
                                <lsx-col size="md" class="d-flex flex-column justify-content-center gap-3">
                                    <lsx-card title="Consistency (Konsistenz)" bold>
                                        Alle Knoten sehen immer exakt dieselben, konsistenten Daten. Bei replizierten Datenbeständen
                                        werden die Änderungen daher erst sichtbar, wenn sie in allen Repliken nachgezogen wurden.
                                    </lsx-card>

                                    <lsx-card title="Availability (Verfügbarkeit)" bold>
                                        Das System ist jederzeit erreichbar und überschreitet niemals die maximal zulässige
                                        Antwortzeit.
                                    </lsx-card>
                                    
                                    <lsx-card title="Partition Tolerance (Partitionstoleranz)" bold>
                                        Die Anwendung funktioniert auch dann noch, wenn einzelne Teile ausgefallen sind.
                                    </lsx-card>
                                </lsx-col>
                            </lsx-row>
                        </lsx-grid-fluid>

                        <div class="markdown dhbw-text-columns" detail-content>
                            In der praktischen Umsetzung lassen sich Fehler, die zu einer Partitionierung des Netzwerks bzw.
                            Nichterreichbarkeit einzelner Dienste, führen, oft nicht vermeiden. Dies triff vor allem bei
                            internet-basierten, verteilten Systemen zu. Häufig entscheidet man sich deshalb zu einer
                            aufgeweichten "quasi-konsistenz", bei der kurzzeitige Inkonsistenzen zu Gunsten einer erhöhten
                            Verfügbarkeit in Kauf genommen werden. Hierzu ein Beispiel und ein Gegenbeispiel:

                            * __Quasi-Konsistenz (Verfügbarkeit vor Konsistenz):__ In weltweit genutzten, sozialen Netzwerken
                            wie Youtube oder Facebook kann es sicher vorkommen, dass ein Like oder Kommentar nicht sofort für
                            alle Seitenbesucher*innen sichtbar wird, da dieser erst in die geografisch verteilten Datenbanken
                            repliziert werden muss. Nach einer kurzen Weile ist der Like oder Kommentar jedoch weltweit sichtbar.

                            * __Konsistenz vor Verfügbarkeit:__ Als Internetauktion auf eBay im Trend waren (und eBay noch
                            auf Privatverkäufe ausgelegt war), war es üblich, möglichst knapp vor Ende der Auktion zu bieten,
                            um anderen Mitbietern zuvor zu kommen. Die letzten Sekunden vor Auktionsschluss sind daher die
                            heißesten, in denen der meiste Traffic anfällt. Entsprechend länger ist die Wartezeit, bis ein
                            Gebot tatsächlich von der Plattform angenommen und bestätigt wird. Bei zu hoher Auslastung kann
                            es vorkommen, dass die Auktion aufgrund der Verzögerung zwischenzeitlich zu Ende gelaufen ist.
                            Das ist ärgerlich, aber der einzig richtige Weg, um ungewünschte Datenprobleme, wie zwei identische
                            von der Plattform bestätigte Höchstgebote, zu vermeiden.
                        </div>
                    </lsx-tab-page>
                </lsx-tab-pages>
            </div>
        </article>
    </section>

    <section data-title="Fallbeispiel: Coffee Shop" class="centered-content">
        <div class="limited-width markdown" detail-content>
            Dieser Artikel beschreibt für verteilte Systeme wichtige Begriffe wie Synchronizität, Interaktionsmuster (engl. „Conversation Pattern“),
            oder Transaktionsverhalten. Als anschauliches Beispiel wird eine typische Bestellung in einem Coffe Shop betrachtet. Alternative Beispiele
            des Alltags, auf die sich die Beobachtungen übertragen lassen und die inzwischen sogar weitgehend digital ablaufen, sind die Abläufe in
            einem Fast-Food-Restaurant oder eine Bestellung in einem Onlineshop.
        </div>
        <div>
            <a href="https://ieeexplore.ieee.org/document/1407829" target="_blank">IEEE Software, Volume: 22, Issue: 2, Pages 64–66</a>
            <div class="d-flex gap-3">
                <img src="02-architektur/coffeeshop1.png" class="img-thumbnail d-block w-100"/>
                <img src="02-architektur/coffeeshop2.png" class="img-thumbnail d-block w-100" />
                <img src="02-architektur/coffeeshop3.png" class="img-thumbnail d-block w-100" />
            </div>
        </div>
    </section>

    <section data-title="Strategien zur Fehlerbehandlung" class="centered-content">
        <lsx-grid-fluid class="limited-width2 p-0">
            <lsx-row>
                <lsx-col size="md-4" class="mb-3 mb-md-0">
                    <lsx-card bold img="02-architektur/fehler-vermeiden.jpg">
                        <h4>Fehler vermeiden</h4>
                        <p>
                            Zum Beispiel durch Eingabehilfen oder einen sauberen Programmierstil
                        </p>
                    </lsx-card>
                </lsx-col>
                <lsx-col size="md-4" class="mb-3 mb-md-0">
                    <lsx-card bold img="02-architektur/fehler-erkennen.jpg">
                        <h4>Fehler erkennen</h4>
                        <p>
                            Zum Beispiel durch Checksummen, Plausiprüfungen oder Monitoring
                        </p>
                    </lsx-card>
                </lsx-col>
                <lsx-col size="md">
                    <lsx-card bold img="02-architektur/fehler-maskieren.jpg">
                        <h4>Fehler maskieren</h4>
                        <p>
                            Zum Beispiel durch spätere Wiederholung des Vorgangs
                        </p>
                    </lsx-card>
                </lsx-col>
            </lsx-row>
            <lsx-row>
                <lsx-col size="md-4" class="mb-3 mb-md-0">
                    <lsx-card bold img="02-architektur/fehler-tolerieren.jpg">
                        <h4>Fehler tolerieren</h4>
                        <p>
                            Zum Beispiel durch Speichern beider Versionen bei Schreibkonflikten
                        </p>
                    </lsx-card>
                </lsx-col>
                <lsx-col size="md-4" class="mb-3 mb-md-0">
                    <lsx-card bold img="02-architektur/fehler-beheben.jpg">
                        <h4>Fehler beheben</h4>
                        <p>
                            Zum Beispiel durch automatisches Umschalten auf ein Hot-Standby
                        </p>
                    </lsx-card>
                </lsx-col>
                <lsx-col size="md">
                    <!-- Leer -->
                </lsx-col>
            </lsx-row>
            <lsx-row>
                <lsx-col size="md">
                    <small>
                        <small>
                            Bildnachweise:
                            <a href="https://pixabay.com/en/rappelling-rope-safety-security-755400/" target="_blank">Pixabay: cegoh</a>,
                            <a href="https://pixabay.com/en/equipment-hospital-ecg-3089883/" target="_blank">Pixabay: hioahelsefag</a>,
                            <a href="https://pixabay.com/en/redirect-shield-tree-attention-2257746/" target="_blank">Pixabay: Digitalpfade</a>,
                            <a href="https://pixabay.com/en/home-single-family-home-on-the-head-2308799/" target="_blank">Pixabay: ulleo</a>,
                            <a href="https://pixabay.com/en/first-aid-frog-medic-nurse-funny-1732708/" target="_blank">Pixabay: Alexas_Fotos</a>
                        </small>
                    </small>
                </lsx-col>
            </lsx-row>
        </lsx-grid-fluid>
    </section>

    <section data-title="Grundregel verteilter Systeme" class="centered-content">
        <div class="limited-width2">
            <lsx-grid-fluid class="p-0">
                <lsx-row>
                    <lsx-col size="md">
                        <img src="02-architektur/grundregel1.jpg" class="img-thumbnail d-block w-100" alt="First rule of distributed systems: Don't do it!">
                    </lsx-col>
                    <lsx-col size="md">
                        <img src="02-architektur/grundregel2.jpg" class="img-thumbnail d-block w-100">
                    </lsx-col>
                </lsx-row>
            </lsx-grid-fluid>
            <p>
                <small>
                    <small>
                        Bildnachweise: OpenAI DALL-E, Prompt: First rule of distributed systems: Don't do it
                    </small>
                </small>
            </p>
    
            <p>
                Warum diese merkwürdig anmutende Regel? Weil Verteilte Systeme nicht die Lösung für alle Probleme sind
                („mit dem Hammer in der Hand …”), jedoch ihre ganz eigenen Probleme mitbringen, die nicht immer leicht
                zu lösen sind.
            </p>
    
            <lsx-ul emoji="⁉️">
                <li>Aufteilung der Anwendungslogik in unabhängige Teilkomponenten</li>
                <li>Definition passender Schnittstellen zwischen den Komponenten</li>
                <li>Zuverlässiger Datenaustausch über ein unzuverlässiges Netzwerk</li>
                <li>Sicherstellen der Datenkonsistenz in verteilten Transaktionen</li>
                <li>Partitionierung, Replikation und Verfügbarkeit von Daten</li>
                <li>Koordination vieler verschiedener Knoten (wer ist der Chef?)</li>
                <li>Und viele mehr</li>
            </lsx-ul>
    
            <p>Natürlich gibt es dennoch viele sinnvolle Einsatzgebiete. Sonst würde es diese Vorlesung ja gar nicht geben. 😵‍💫</p>
        </div>
    </section>
</section>

<!-- TODO: Weitere Aufgaben, Kahoots in Micheals Moodleräumen für weitere Quiz-Fragen -->
<section data-title="Übungsaufgaben" data-background-color="rgb(231, 221, 141)">
    <section data-title="Aufgabe 1: Ein kleines Architekturmuster-Quiz">
        <article>
            <lsx-tab-pages>
                <lsx-tab-page title="Aufgabe 1.1">
                    <lsx-quiz>
                        <lsx-exercise title="Clients, Server und Peers">
                            <lsx-question
                                type = "single-choice"
                                text = "a) Welche der folgenden Definitionen beschreibt einen Server?"
                            >
                                <lsx-answer class="dhbw-fontsize-small">
                                    Ein Programm, das einen Dienst anbietet und sich hierfür mit anderen,
                                    gleichartigen Programmen verbindet.
                                </lsx-answer>
                                <lsx-answer correct class="dhbw-fontsize-small">
                                    Ein Programm, das einen Dienst anbietet und hierfür wartet, bis sich
                                    ein Nutzer mit ihm verbindet.
                                </lsx-answer>
                                <lsx-answer class="dhbw-fontsize-small">
                                    Ein Programm, das temporär gestartet wird, um einen Dienst zu nutzen.
                                </lsx-answer>
                            </lsx-question>
                            <lsx-question
                                type = "single-choice"
                                text = "b) TCP/IP-Verbindungen werden immer vom Server initiiert, der sich hierfür mit dem Client verbindet."
                            >
                                <lsx-answer class="dhbw-fontsize-small">
                                    Wahr
                                </lsx-answer>
                                <lsx-answer correct class="dhbw-fontsize-small">
                                    Falsch
                                </lsx-answer>
                            </lsx-question>
                            <lsx-question
                                type = "multiple-choice"
                                text = "c) Welche der folgenden Aussagen sind korrekt?"
                            >
                                <lsx-answer correct class="dhbw-fontsize-small">
                                    Die Peers in einem Peer-to-Peer-Netzwerk sind sowohl Client als auch Server.
                                </lsx-answer>
                                <lsx-answer class="dhbw-fontsize-small">
                                    Peer-to-Peer-Netzwerke besitzen einen zentralen Master-Server für die gesamte Kommunikation.
                                </lsx-answer>
                                <lsx-answer correct class="dhbw-fontsize-small">
                                    Jeder Peer verbindet sich als Client mit anderen anderen Peers, die gleichzeitig als Server fungieren.
                                </lsx-answer>
                            </lsx-question>
                        </lsx-exercise>
                    </lsx-quiz>
                </lsx-tab-page>
    
                <lsx-tab-page title="Aufgabe 1.2">
                    <lsx-quiz>
                        <lsx-exercise title="Proxyserver">
                            <lsx-question
                                type = "single-choice"
                                text = "a) Welche der folgenden Definitionen entspricht der eines Proxyservers?"
                            >
                                <lsx-answer class="dhbw-fontsize-small">
                                    Ein Proxyserver verbindet sich mit vielen anderen Proxyservern zu einem virtuellen Gesamtsystem.
                                </lsx-answer>
                                <lsx-answer class="dhbw-fontsize-small">
                                    Ein Proxyserver dient der Zusammenführung mehrerer Microservices in einer Weboberfläche.
                                </lsx-answer>
                                <lsx-answer correct class="dhbw-fontsize-small">
                                    Ein Proxyserver kopiert die Schnittstelle eines anderen Servers und vertritt diesen gegenüber seinen Clients.
                                </lsx-answer>
                            </lsx-question>
                            <lsx-question
                                type = "single-choice"
                                text = "b) Welche der folgenden Aufgaben gehören nicht zu denen eines Proxyservers?"
                            >
                                <lsx-answer class="dhbw-fontsize-small">
                                    Chachen häufig angefragter Inhalte
                                </lsx-answer>
                                <lsx-answer correct class="dhbw-fontsize-small">
                                    Vereinheitlichung unterschiedlicher Serverprotokolle
                                </lsx-answer>
                                <lsx-answer class="dhbw-fontsize-small">
                                    Content Filter, Upload Filter, Paywalls
                                </lsx-answer>
                                <lsx-answer class="dhbw-fontsize-small">
                                    Lastverteilung über mehrere Serverinstanzen
                                </lsx-answer>
                                <lsx-answer class="dhbw-fontsize-small">
                                    Sicherstellen einer zentralen Authentifizierung
                                </lsx-answer>
                            </lsx-question>
                        </lsx-exercise>
                    </lsx-quiz>
                </lsx-tab-page>
    
                <lsx-tab-page title="Aufgabe 1.3">
                    <lsx-quiz>
                        <lsx-exercise title="Dreischichtenarchitektur">
                            <lsx-question
                                type = "multiple-choice"
                                text = "a) Welche der folgenden Schichten gehören zur Dreischichtenarchitektur?"
                            >
                                <lsx-answer correct class="dhbw-fontsize-small">
                                    Datenhaltungsschicht
                                </lsx-answer>
                                <lsx-answer class="dhbw-fontsize-small">
                                    Präsentationsschicht
                                </lsx-answer>
                                <lsx-answer correct class="dhbw-fontsize-small">
                                    Darstellungsschicht
                                </lsx-answer>
                                <lsx-answer class="dhbw-fontsize-small">
                                    Clientschicht
                                </lsx-answer>
                                <lsx-answer class="dhbw-fontsize-small">
                                    Spätschicht
                                </lsx-answer>
                                <lsx-answer correct class="dhbw-fontsize-small">
                                    Anwendungsschicht
                                </lsx-answer>
                            </lsx-question>
                            <lsx-question
                                type = "multiple-choice"
                                text = "b) Welche der folgenden Schichten gehören zur Vierschichtenarchitektur?"
                            >
                                <lsx-answer class="dhbw-fontsize-small">
                                    Mittelschicht
                                </lsx-answer>
                                <lsx-answer correct class="dhbw-fontsize-small">
                                    Anwendungsschicht
                                </lsx-answer>
                                <lsx-answer correct class="dhbw-fontsize-small">
                                    Präsentationsschicht
                                </lsx-answer>
                                <lsx-answer class="dhbw-fontsize-small">
                                    Peer-To-Peer-Schicht
                                </lsx-answer>
                                <lsx-answer correct class="dhbw-fontsize-small">
                                    Darstellungsschicht
                                </lsx-answer>
                                <lsx-answer correct class="dhbw-fontsize-small">
                                    Datenhaltungsschicht
                                </lsx-answer>
                            </lsx-question>
                        </lsx-exercise>
                    </lsx-quiz>
                </lsx-tab-page>
    
                <lsx-tab-page title="Aufgabe 1.4">
                    <lsx-quiz>
                        <lsx-exercise title="Microservices">
                            <lsx-question
                                type = "single-choice"
                                text = "a) Jeder Microservice entspricht einer Dreischichtenarchitektur?"
                            >
                                <lsx-answer class="dhbw-fontsize-small">
                                    Wahr
                                </lsx-answer>
                                <lsx-answer correct class="dhbw-fontsize-small">
                                    Falsch
                                </lsx-answer>
                            </lsx-question>
                            <lsx-question
                                type = "single-choice"
                                text = "b) Microservices lohnen sich in der Regel eher für …"
                            >
                                <lsx-answer correct class="dhbw-fontsize-small">
                                    Große Anwendungen in großen Unternehmen mit vielen Entwicklern
                                </lsx-answer>
                                <lsx-answer class="dhbw-fontsize-small">
                                    Große Anwendungen in kleinen Unternehmen mit wenigen Entwicklern
                                </lsx-answer>
                                <lsx-answer class="dhbw-fontsize-small">
                                    Kleine Anwendungen in großen Unternehmen mit wenigen Entwicklern
                                </lsx-answer>
                            </lsx-question>
                            <lsx-question
                                type = "multiple-choice"
                                text = "c) Welche der folgenden Techniken kommen als Schnittstelle für Microservices in Frage?"
                            >
                                <lsx-answer correct class="dhbw-fontsize-small">
                                    Entfernte Prozedur-/Methodenaufrufe
                                </lsx-answer>
                                <lsx-answer correct class="dhbw-fontsize-small">
                                    Webservices
                                </lsx-answer>
                                <lsx-answer class="dhbw-fontsize-small">
                                    Weboberflächen im Browser
                                </lsx-answer>
                                <lsx-answer correct class="dhbw-fontsize-small">
                                    Message Broker
                                </lsx-answer>
                                <lsx-answer class="dhbw-fontsize-small">
                                    Mobile Apps
                                </lsx-answer>
                            </lsx-question>
                            <lsx-question
                                type = "single-choice"
                                text = "d) Die Microservices einer großen Anwendung besitzen alle dieselbe Versionsnummer"
                            >
                                <lsx-answer class="dhbw-fontsize-small">
                                    Wahr
                                </lsx-answer>
                                <lsx-answer correct class="dhbw-fontsize-small">
                                    Falsch
                                </lsx-answer>
                            </lsx-question>
                        </lsx-exercise>
                    </lsx-quiz>
                </lsx-tab-page>
    
                <lsx-tab-page title="Aufgabe 1.5">
                    <lsx-quiz>
                        <lsx-exercise title="Asynchrone Kommunikation">
                            <lsx-question
                                type = "single-choice"
                                text = "a) Beim asynchronen Modell wird zwischen Sendern und Empfängern unterschieden. Ein Sender ist dabei immer ein Client und ein Emfpänger immer ein Server."
                            >
                                <lsx-answer class="dhbw-fontsize-small">
                                    Wahr
                                </lsx-answer>
                                <lsx-answer correct class="dhbw-fontsize-small">
                                    Falsch
                                </lsx-answer>
                            </lsx-question>
                            <lsx-question
                                type = "multiple-choice"
                                text = "b) Welche der folgenden Ausagen über asynchrone Kommunikation sind korrekt?"
                            >
                                <lsx-answer correct class="dhbw-fontsize-small">
                                    Jegliche Kommunikation wird über den Message Broker abgewickelt, der die Sender und
                                    Empfänger auf diese Weise voneinander entkoppelt.
                                </lsx-answer>
                                <lsx-answer class="dhbw-fontsize-small">
                                    Die Kommunikation erfolgt immer nach einem Request/Reply-Verfahren, in dem jede Nachricht
                                    eines Senders mit einer Antwortnachricht eines Empfängers quitiert wird.
                                </lsx-answer>
                                <lsx-answer correct class="dhbw-fontsize-small">
                                    Form und Inhalt der gesendeten Nachrichten können von der Anwendung meist frei definiert werden.
                                </lsx-answer>
                                <lsx-answer correct class="dhbw-fontsize-small">
                                    Jede Nachricht wird immer an eine Warteschlange gesendwet, ohne dass der Sender weiß, ob und
                                    wie viele Empfänger diese überwachen.
                                </lsx-answer>
                            </lsx-question>
                            <lsx-question
                                type = "single-choice"
                                text = "c) Was passiert mit einer Nachricht, die an eine Broadcast-Warteschlange gesendet wird?"
                            >
                                <lsx-answer class="dhbw-fontsize-small">
                                    Aus allen Empfängern, welche die Warteschlange überwachen, wird einer ausgewählt, dem
                                    die Nachricht weitergeleitet wird. Dies beruht auf der Annahme, dass jeder Empfänger
                                    die Nachricht vollständig bearbeiten könnte und daher eine Lastverteilung umgesetzt
                                    werden kann. Die Nachrichten werden bei Bedarf in der Warteschlange zwischengespeichert,
                                    falls aktuell kein Empfänger verfügbar ist.
                                </lsx-answer>
                                <lsx-answer correct class="dhbw-fontsize-small">
                                    Die Nachricht wird an alle Empfänger weitergeleitet, die die Warteschlange zum aktuellen
                                    Zeitpunkt überwachen. Haben keine Empfänger die entsprechende Warteschlange aboniert,
                                    geht die Nachricht jedoch verloren.
                                </lsx-answer>
                            </lsx-question>
                            <lsx-question
                                type = "single-choice"
                                text = "d) Was passiert mit einer Nachricht, die an eine Point-to-Point-Warteschlange gesendet wird?"
                            >
                                <lsx-answer correct class="dhbw-fontsize-small">
                                    Aus allen Empfängern, welche die Warteschlange überwachen, wird einer ausgewählt, dem
                                    die Nachricht weitergeleitet wird. Dies beruht auf der Annahme, dass jeder Empfänger
                                    die Nachricht vollständig bearbeiten könnte und daher eine Lastverteilung umgesetzt
                                    werden kann. Die Nachrichten werden bei Bedarf in der Warteschlange zwischengespeichert,
                                    falls aktuell kein Empfänger verfügbar ist.
                                </lsx-answer>
                                <lsx-answer class="dhbw-fontsize-small">
                                    Die Nachricht wird an alle Empfänger weitergeleitet, die die Warteschlange zum aktuellen
                                    Zeitpunkt überwachen. Haben keine Empfänger die entsprechende Warteschlange aboniert,
                                    geht die Nachricht jedoch verloren.
                                </lsx-answer>
                            </lsx-question>
                        </lsx-exercise>
                    </lsx-quiz>
                </lsx-tab-page>
            </lsx-tab-pages>
        </article>
        <aside>
            <p>
                Und hier nun das große Finale! 🎪 Zum Abschluss dieser Einheit darfst du ein paar
                Fragen zu den eben gelernten Architekturmustern beantworten.
            </p>
            <img src="shared/quiz.png" class="img-fluid d-block" style="max-width: 20em;"/>
            <p>
                <small>
                    Bildnachweis:
                    <a href="https://pixabay.com/illustrations/quiz-tiles-letters-red-game-test-2058883/" target="_blank">Pixabay: 905513</a>
                </small>
            </p>
        </aside>
    </section>
    
    <!-- <section data-title="Aufgabe 2: Wir erkunden Streams und Sockets">
        ... Sprach-Server/Client auf Laptop ausführen
    </section> -->
    
    <section data-title="Aufgabe 2: Wer hat an der Uhr gedreht?">
        <article>
            <div class="markdown">
                Wichtige Anforderung an verteilte Systeme ist häufig, dass die **Kausalordnung** von Ereignissen
                erhalten bleibt, das heißt, dass die zeitliche Abfolge von Ursache und Wirkung nicht vertauscht
                wird. Doch auch ohne kausalen Zusammenhang müssen so genannte **Happened-Before**-Beziehungen
                erhalten bleiben. In beiden Fällen läuft es auf einen Vergleich von Zeitstempeln hinaus, wofür
                entweder eine **Echtzeituhr** oder eine **logische Uhr** verwendet werden kann.
            </div>

            <lsx-tab-pages>
                <lsx-tab-page title="Aufgabenstellung" class="markdown">
                    #### a) Begriffsdefinitionen {.mt-4 .dhbw-lightblue}
            
                    Recherchieren Sie folgende Begriffe und formulieren Sie eine dazu passende Definition:
            
                    * Kausalordnung
                    * Happened-Before-Relation
                    * Nebenläufigkeit
                    * Echtzeituhr
                    * Lamport-Uhr
            
                    #### b) Fallbeispiel {.mt-4 .dhbw-lightblue}
            
                    Zeigen Sie anhand eines minimalen Beispiels, wie die zeitliche Abfolge mehrerer Ereignisse anhand
                    einer logischen Uhr sichergestellt werden kann.
                    
                    #### c) Nebenläufigkeit {.mt-4 .dhbw-lightblue}
            
                    Erklären Sie, warum eine einfache Lamport-Uhr keine nebenläufigen Prozesse abbilden kann und zeigen Sie,
                    wie eine Vektoruhr dies ermöglicht.
                </lsx-tab-page>

                <lsx-tab-page title="Hinweis zur Zeitrechnung">
                    <p>
                        Egal, welche Art von Uhr zum Einsatz kommt, alle Beteiligten müssen sich über die
                        zugrunde liegenden Konventionen einig sein. Dass diese mitunter nicht immer eindeutig
                        sind (wird ein Unix-Zeitstempel in Sekunden oder in Millisekunden gezählt?) zeigt
                        folgende, nicht ganz ernste Aufzählung. 😉
                    </p>

                    <h4>Beginn der Zeitrechnung</h4>

                    <lsx-grid-fluid class="p-0">
                        <lsx-row>
                            <lsx-col size="md">
                                <img src="02-architektur/zeitproblem-beginn-wissenschaft.jpg" class="d-block img-fluid img-thumbnail" />
                                <b>Wissenschaft:</b> Mit dem Urknall
                            </lsx-col>
                            <lsx-col size="md">
                                <img src="02-architektur/zeitproblem-beginn-kirche.jpg" class="d-block img-fluid img-thumbnail" />
                                <b>Kirche:</b> Als Gott die Erde erschuf
                            </lsx-col>
                        </lsx-row>
                        <lsx-row>
                            <lsx-col size="md">
                                <img src="02-architektur/zeitproblem-beginn-sport.jpg" class="d-block img-fluid img-thumbnail" />
                                <b>Wettläufer:</b> Ab dem Startschuss
                            </lsx-col>
                            <lsx-col size="md">
                                <img src="02-architektur/zeitproblem-beginn-entwickler.jpg" class="d-block img-fluid img-thumbnail" />
                                <b>Softwareentwickler:</b> <a href="https://de.wikipedia.org/wiki/Unixzeit"
                                    target="_blank">01.01.1970 0:00 Uhr</a>
                                <br />
                                <small>
                                    <b>Youtube:</b>
                                    <a href="https://www.youtube.com/watch?v=jNQXAC9IVRw" target="_blank">23.04.2005, irgendwann mittags</a>
                                </small>
                            </lsx-col>
                        </lsx-row>
                        <lsx-row>
                            <lsx-col size="md">
                                <p>
                                    <small>
                                        <small>
                                            Bildnachweise:
                                            <a href="https://pixabay.com/illustrations/universe-space-expansion-big-bang-11636/"
                                                target="_blank">Pixabay: WikiImages</a>,
                                            <a href="https://pixabay.com/photos/genesis-mosaic-iconography-2435989/"
                                                target="_blank">Pixabay: dimitrisvetsikas1969</a>,
                                            <a href="https://pixabay.com/photos/race-finish-line-athletes-695303/"
                                                target="_blank">Pixabay: skeeze</a>,
                                            <a href="https://commons.wikimedia.org/wiki/File:Vt100-adventure.jpg"
                                                target="_blank">Wikimedia: Shieldforyoureyes</a>
                                        </small>
                                    </small>
                                </p>
                            </lsx-col>
                        </lsx-row>
                    </lsx-grid-fluid>
                </lsx-tab-page>
            </lsx-tab-pages>
            
        </article>
        <aside>
            <p>
                Diese Aufgabe ist eine Vertiefungsaufgabe zum Thema „Zeitsynchronisation in verteilten Systemen”.
                Die Antworten müssen daher selbständig recherchiert werden, wobei die deutsche Wikipedia bereits
                sehr gute Artikel 📑 zu den einzelnen Begriffen enthält.
            </p>
            <img src="shared/pocket-watch.svg" class="d-block" style="max-width: 20em;" />
            <p>
                <small>
                    Bildnachweis:
                    <a href="https://pixabay.com/vectors/pocket-watch-fob-watch-147107/" target="_blank">Pixabay: OpenClipart-Vectors</a>
                </small>
            </p>
        </aside>
    </section>
</section>

<!-- ============ -->
<!-- Vertiefungen -->
<!-- ============ -->
<section data-use-template="teilkapitel" data-titel="Vertiefungen"></section>

<section data-title="Monolith vs. Microservices">
    <section data-title="Anwendungsarchitektur früher">
        <article class="centered-content">
            <div class="limited-width2">
                <div class="markdown">
                    Frühere Anwendungsarchitekturen, bei denen sämtliche Funktionen in einer großen Codebasis
                    untergebracht waren, werden heute als Monolith bezeichnet. Zwar kann der Quellcode
                    durchaus modular aufgebaut und somit leicht um neue Funktionen erweiterbar sein. Jedoch
                    kann die Anwendung nur als Ganzes deployed und in Betrieb genommen werden.
                    
                    <img src="02-architektur/monolith.png" class="d-block limited-width m-auto mb-3" />
        
                    Verteilte Anwendungen werden daher häufig mit einer Microservice-Architektur gestaltet.
                    Für kleine Entwicklerteams kann ein Monolith dennoch die bessere Wahl sein, da nicht
                    jedes Unternehmen organisatorisch auf Microservices vorbereitet ist. Vor allem, wenn
                    die Entwicklung nicht auf mehrere Teams verteilt werden kann, sind die Voraussetzungen
                    meist nicht gegeben.
                </div>
    
                <lsx-grid-fluid class="p-0">
                    <lsx-row>
                        <lsx-col size="md">
                            <div class="card h-100">
                                <div class="card-header fw-bold">
                                    Vorteile von Monolithen
                                </div>
                                <div class="card-body markdown">
                                    * Einfache Anwendungsarchitektur mit wenigen Komponenten.
                                    * Insbesondere für kleine Entwicklerteams leicht handlebar.
                                    * Eine Programmiersprache für alle Teile der Anwendung.
                                    * Direkter Datenaustausch zwischen den Anwendungskomponenten.
                                    * Anwendungskomponenten können sich gegenseitig direkt aufrufen.
                                </div>
                            </div>
                        </lsx-col>
    
                        <lsx-col size="md">
                            <div class="card h-100">
                                <div class="card-header fw-bold">
                                    Nachteile von Monolithen
                                </div>
                                <div class="card-body markdown">
                                    * Unpraktisch für sehr große Anwendungen mit vielen Funktionen.
                                    * Die Auswirkungen einer Änderung sind oft schwer nachvollziehbar.
                                    * In großen Entwicklerteams kommt es oft zu gegenseitigen Störungen.
                                    * Kein getrenntes Deployment einzelner Anwendungsfunktionen möglich.
                                    * Vor jedem Deployment muss die ganze Anwendung getestet werden.
                                    * Fehlerkorrekturen brauchen daher lange, bis sie produktiv gehen.
                                    * Die Anwendung kann nur als Ganzes skaliert werden.
                                </div>
                            </div>
                        </lsx-col>
                    </lsx-row>
                </lsx-grid-fluid>
            </div>
        </article>
    </section>
    
    <section data-title="Probleme beim Deployment monolithischer Anwendungen">
        <article class="centered-content">
            <div class="limited-width">
                <div class="d-flex flex-column flex-md-row gap-5">
                    <img src="02-architektur/wanted-monolith.jpg" class="d-block w-100" alt="Wanted! The Monolith …">
                    <img src="02-architektur/code-freeze.jpg" class="d-block w-100" alt="It's really, really, really, really code freeze">
                </div>
            
                <small>
                    <small>
                        Bildnachweise:
                        <a href="https://turnoff.us/geek/not-wanted/" target="_blank">{turnoff.us} not wanted</a>,
                        <a href="https://geek-and-poke.com/geekandpoke/2015/3/25/code-freeze" target="_blank">Geek & Poke: Code Freeze</a>
                    </small>
                </small>
            </div>
        </article>
    </section>
    
    <section data-title="Anwendungsarchitektur heute">
        <article class="centered-content">
            <div class="limited-width2">
                <lsx-accordion>
                    <lsx-accordion-page title="Definition: Microservices" class="markdown" bold active>
                        Moderne Anwendungen werden heute oft als Microservice-Architektur ausgeführt, in welcher die
                        Teilfunktionen einer Anwendung in einzelne Serverdienste ausgelagert werden. Microservice-basierte
                        Anwendungen sind daher immer verteilte Anwendungen. Dabei bildet jeder Microservice eine getrennte
                        Einheit, die weitgehend unabhängig entwickelt, deployed und betrieben wird. Meistens besitzt jeder
                        Microservice deshalb eine eigene Datenbank, auf deren Inhalte nur über die öffentliche Schnittstelle
                        des Microservices entfernt zugegriffen werden kann. Martin Fowler definiert Microservices
                        [auf seiner Webseite](https://martinfowler.com/microservices/){target=_blank} daher wie folgt:
                    
                        * Entfernte Serverdienste als Teilkomponenten einer Anwendung
                        * Dezentralisierte Verwaltung und dezentrales Datenmanagement
                        * Entsprechen oft organisatorischer Unternehmenseinheiten
                        * Deshalb meist langfristig durch eigenständige Teams betreut
                        * Über eine öffentliche Schnittstelle entfernt aufrufbar
                        * Fehlertoleranter Entwurf mit evolutionärem Design
                        * Hoher Automatisierungsgrad für Betrieb und Weiterentwicklung
                    </lsx-accordion-page>
    
                    <lsx-accordion-page title="Beispiele" bold>
                        <lsx-tab-pages>
                           <lsx-tab-page title="Single Page App mit API-Gateway">
                               <div class="markdown">
                                   Heutige Webanwendungen trennen sehr strickt zwischen der Frontend genannten Benutzeroberfläche
                                   und der zentralen Anwendungsfunktionen im Backend. Oft handelt es sich beim Frontend um eine
                                   als Single Page App ausgeführte Webanwendung, die vollständig im Browser des Clientgeräts läuft.
                                   Aber auch mobile Anwendungen, native Desktopanwendungen oder eine Kombination aus allem sind
                                   weit verbreitet.
                                   
                                   Frontend und Backend kommunizieren daher über das Netzwerk, wobei die Verteilung des Backends
                                   hinter einem API-Gateway verborgen wird. Das API-Gateway bietet hierfür einen zentralen
                                   Zugriffspunkt, über den alle Backendservices einheitlich angebsprochen werden können, ohne
                                   die eigentlichen Backendstrukturen kennen zu müssen (oder dürfen).
                               </div>
                               <img id="microservices-bilder-1" src="02-architektur/microservices-gateway.png" class="d-block w-100 mt-4" />
                           </lsx-tab-page>
                           <lsx-tab-page title="Webanwendung mit Composite UI">
                               <div class="markdown">
                                   Ein früherer Ansatz, wie er heute unter Anderem von Amazon genutzt wird, konzentriert
                                   sich ausschließlich auf Webanwendungen. Meist handelt es sich dabei um serverseitig
                                   gerenderte Multi Page Apps ohne die eben besprochene Trennung von Frontend und Backend.
               
                                   Als Besonderheit setzt sich die Benutzeroberfläche allerdings wie bei einem Puzzle aus
                                   unterschiedlichen Teilen zusammen, die jeweils von einem anderen Microservice bereitgestellt
                                   werden. Praktisch bedeutet dies, dass es ein vorgelagerter Webserver eine mehr oder weniger
                                   leere HTML-Seite mit nur allgemeinen Dingen wie dem Seitenkopf oder einem einfachen
                                   Navigationsmenü zur Verfügung stellt. In diese werden dann von den Microservices gelieferte
                                   HTML-Fragemente (sog. Microfrontends) eingebettet, um die Ansicht zu vervollständigen.
                               </div>
                               <img id="microservices-bilder-2" src="02-architektur/microservices-compositeui.png" class="d-block w-100 mt-4" />
                           </lsx-tab-page>
                       </lsx-tab-pages>
                    </lsx-accordion-page>
    
                    <lsx-accordion-page title="Vor- und Nachteile" bold>
                        <lsx-grid-fluid class="p-0">
                             <lsx-row>
                                 <lsx-col size="md">
                                     <div class="card h-100">
                                         <div class="card-header fw-bold">
                                             Vorteile von Microservices
                                         </div>
                                         <div class="card-body markdown">
                                             * Die Services sind durch ihre Schnittstellen klar gekapselt.
                                             * Jeder Service kann einzeln deployed und skaliert werden.
                                             * Sprachen, Bibliotheken, … können passend zum Service ausgewählt werden.
                                             * Schwergewichtige Appliktionsserver und Frameworks können oft vermieden werden.
                                             * Microservices lassen sich meist leicht als Docker-Container o.ä. verpacken.
                                         </div>
                                     </div>
                                 </lsx-col>
             
                                 <lsx-col size="md">
                                     <div class="card h-100">
                                         <div class="card-header fw-bold">
                                             Nachteile von Microservices
                                         </div>
                                         <div class="card-body markdown">
                                             * Verteilte Systeme mit vielen Komponenten sind schwer zu programmieren.
                                             * Microservices müssen eventuellkonsistent und fehlertolerant programmiert werden.
                                             * Deployment, Betrieb und Überwachung bringen zusätzliche Komplexität.
                                             * Die Kommunikation zwischen Microservices ist grundsätzlich latenzbehaftet.
                                             * Kleinere und unerfahrene Teams können mit der Komplexität überfordert sein.
                                         </div>
                                     </div>
                                 </lsx-col>
                             </lsx-row>
                         </lsx-grid-fluid>
             
                         <div class="markdown">
                             Laut Martin Fowler lohnt sich eine Microservice-Architektur daher nur, wenn eine Anwendung hinreichend
                             groß ist und von mehreren Entwicklerteams betreut werden kann. Vgl.
                             [Martin Fowler: Microservice Guide](https://martinfowler.com/microservices/){target=_blank}
                         </div>
                    </lsx-accordion-page>
                </lsx-accordion>
            </div>
        </article>
    </section>
    
    <section data-title="Herausforderungen bei der Nutzung von Microservices">
        <article class="centered-content">
            <div class="limited-width2">
                <div class="d-flex flex-column flex-md-row gap-3">
                    <img src="02-architektur/valentines-day.png" class="d-block w-100" alt="Happy Valentines Day">
                    <img src="02-architektur/microservices-and-monolithic.png" class="d-block w-100" alt="Are you ready for microservices?">
                </div>
            
                <small>
                    <small>
                        Bildnachweise:
                        <a href="https://turnoff.us/geek/valentines-day/" target="_blank">{turnoff.us} valentine's day at the kernel</a>,
                        <a href="https://turnoff.us/geek/are-you-ready-for-microservices/" target="_blank">{turnoff.us} are you ready for microservices?</a>
                    </small>
                </small>
            </div>
        </article>
    </section>
    
    <section data-title="Skalierung von Microservices">
        <article class="centered-content">
            <div class="limited-width">
                <lsx-carousel class="carousel-fade">
                    <lsx-carousel-page>
                        <img src="02-architektur/skalierung-1.png" class="d-block w-100 mb-5">
                        <p>
                            Microservice-Architekturen lassen sich grundsätzlich einfacher skalieren als monolithische Anwendungen,
                            da jeder Service getrennt deployed wird. Für jeden Service kann daher eine optimale Ressourcenzuteilung
                            entsprechend dem tatsächlichen Bedarf vorgenommen werden.
                        </p>
                    </lsx-carousel-page>
                    <lsx-carousel-page>
                        <img src="02-architektur/skalierung-2.png" class="d-block w-100 mb-5">
                        <p>
                            Bei leicht ansteigender Last könnte die Laufzeitumgebung beispielsweise den laufenden Instanzen mehr
                            Leistung zur Verfügung stellen.
                        </p>
                    </lsx-carousel-page>
                    <lsx-carousel-page>
                        <img src="02-architektur/skalierung-3.png" class="d-block w-100 mb-5">
                        <p>
                            In der Regel werden so genannte Skalierungstrigger, wie die Anzahl HTTP-Anfragen je Sekunde, jedoch
                            genutzt, um weitere Serviceinstanzen zu starten. Die eingehenden Anfragen werden dann durch einen Load
                            Balancer gleichmäßig auf die Instanzen verteilt.
                        </p>
                    </lsx-carousel-page>
                    <lsx-carousel-page>
                        <img src="02-architektur/skalierung-4.png" class="d-block w-100 mb-5">
                        <p>
                            Damit diese Art der Skalierung funktioniert, dürfen die Services allerdings keine temporären Sitzungdaten
                            im Hauptspeicher ablegen. Denn es kann in der Regel nicht garantiert werden, dass zusammengehörige Anfragen
                            stets dieselbe Instanz erreichen. Außerdem können die Instanzen jederzeit neugestartet werden, wodurch die
                            im Hauptspeicher liegenden Daten ebenfalls verloren gingen.
                        </p>
                    </lsx-carousel-page>
                    <lsx-carousel-page>
                        <img src="02-architektur/skalierung-5.png" class="d-block w-100 mb-5">
                        <p>
                            Cloud-Anwendungen, welche serverseitige Sitzungsdaten verwalten, persistieren diese daher meist in einer
                            Datenbank. Oft wird hierfür dieselbe Datenbank genutzt, in der auch die originären Nutzdaten des jeweiligen
                            Microservices liegen. Genauso oft kommen allerdings auch spezialisierte Datenbanken oder Objektspeicher
                            wie Redis zum Einsatz.
                        </p>
                    </lsx-carousel-page>
                    <lsx-carousel-page>
                        <img src="02-architektur/skalierung-6.png" class="d-block w-100 mb-5">
                        <p>
                            Idealerweise benötigt eine Anwendung überhaupt keine serverseitigen Sitzungsdaten, sondern verwaltet diese
                            rein clientseitig. Dadurch werden der Server entlastet und Zeitverzögerungen aufgrund einer langsamen
                            Internetverbindung vermieden. Gemäß
                            <a href="https://martinfowler.com/articles/distributed-objects-microservices.html" target="_blank">Martin Fowler's „First Law of Distributed Objects”</a>
                            funktioniert dies am besten, wenn die Kommunikation mit dem Backend auf wenige Anfragen mit gebündelten
                            Inhalten reduziert wird.
                        </p>
                    </lsx-carousel-page>
            
                    <lsx-carousel-page>
                        <img class="active d-block w-25 m-auto" src="shared/finish.svg" />
                        <p>
                            Wird eine Anwendung nach den vorgenannten Prinzipien serverseitig möglichst zustandslos implementiert,
                            kann sie jederzeit problemlos hoch- oder runterskaliert werden.
                        </p>
                    </lsx-carousel-page>
                </lsx-carousel>
            </div>
        </article>
    </section>

    <!-- TODO: Quellcode anpassen, dann hier freischalten und Beschreibung ergänzen -->
    <!--
    <section data-title="Fallbeispiel: Adressbuch">
        <article class="centered-content">
            <div>
                <div class="mb-3">
                    <lsx-github-edit url="https://github.com/DennisSchulmeister/dhbwka-wwi-vertsys-2022-quellcodes/tree/main/Beispielanwendung%20Adressbuch"></lsx-github-edit>
                </div>
            
                <div class="d-flex flex-column flex-md-row gap-3">
                    <img src="02-architektur/beispiel-adressbuch-1.png" class="img-thumbnail d-block w-100">
                    <img src="02-architektur/beispiel-adressbuch-2.png" class="img-thumbnail d-block w-100">
                    <img src="02-architektur/beispiel-adressbuch-3.png" class="img-thumbnail d-block w-100">
                </div>
            </div>
        </article>
    </section>
    -->
</section>

<section data-title="Nicht-fachliche Services">
    <section data-title="Typische nicht-fachliche Microservices">
        <article class="centered-content">
            <div class="limited-width2 markdown">
                Je größer eine verteilte Anwendung ist oder im Laufe der Zeit wird, desto wichtiger ist es,
                dass über die funktionalen Anforderungen hinaus auch eine Vielzahl technischer Anforderungen
                abgedeckt werden, die einen zuverlässigen Betrieb überhaupt erst möglich machen. Neben einer
                zentralen Benutzer- und Berechtigungsverwaltung gehören hierzu die Überwachung des laufenden
                Betriebs und viele mehr.
    
                In traditionellen, monolithischen Anwendungen müssen derartige Funktionen entweder selbst
                entwickelt oder durch entsprechende Frameworks bzw. Applikationsserver bereitgestellt werden.
                Entsprechend groß und schwergewichtig fallen diese aus. Microservices haben hingegen den Vorteil,
                diese unterstützenden Services von anderen Microservices „out-of-process“ konsumieren zu können.
                Oft kommen dabei Drittprodukte von spezialisierten Anbietern oder die Plattformservices¹ der
                großen Cloudanbieter zum Einsatz, die hierfür lediglich über speziell hierfür bereitgestellte
                Code-Bibliotheken in die eigene Anwendung integriert werden müssen.
                
                <lsx-tab-pages>
                    <lsx-tab-page title="Beispiel-Architektur">
                        <img src="02-architektur/fallbeispiel-naas-planes.png" class="d-block w-100 mt-4" />
                    </lsx-tab-page>
                    <lsx-tab-page title="Service-Arten">
                        <img src="02-architektur/fallbeispiel-naas-services.png" class="d-block w-100 mt-4" />
                    </lsx-tab-page>
                    <lsx-tab-page title="Service Mesh">
                        <img src="02-architektur/fallbeispiel-naas-mesh.png" class="d-block w-100 mt-4" />
                    </lsx-tab-page>
                </lsx-tab-pages>
    
                Das obige Beispiel zeigt eine typische Architektur, bei welcher die nicht-funktionalen
                Anforderungen durch zusätzliche von der Plattform bereitgestellte Microservices abgedeckt werden.
    
                ¹
                <small>
                    Der Begriff „Plattform” steht sinnbildlich für alles, was für Entwicklung und Betrieb einer
                    Anwendung vorab gegeben sein muss. Plattformservices sind daher von den Cloudanbietern gegen
                    Bezahlung bereitgestellte Funktionen zur Unterstützung der in der jeweiligen Cloudumgebung
                    ausgeführten Anwendungen. Beispiele hierfür können Authentifikationsserver, Monitoring-Angebote,
                    Proxy-Server uvm. sein.
                </small>
            </div>
        </article>
    </section>
    
    <section data-title="Zwei-Faktor-Authentifizierung ja oder nein?">
        <article class="centered-content">
            <div style="max-width: 40em;">
                <img src="02-architektur/ct-schlagseite-2fa.jpg" class="d-block w-100" alt="Jeden Tag verschwindet einer …">
            
                <small>
                    <small>
                        Bildnachweis:
                        <a href="https://www.heise.de/select/ct/2022/11/2200714175714756235" target="_blank">c't 11/2022, S. 13 (Schlagseite)</a>
                    </small>
                </small>
            </div>
        </article>
    </section>
    
    <section data-title="Überwachung von Microservices">
        <article class="centered-content">
            <div>
                <div class="markdown limited-width m-auto mb-5">
                    Typische Services in der **Kontrollebene** sind jene zur Überwachung des laufenden
                    Betriebs einer verteilten Anwendung. Diese unterteilen sich typischerweise in:
            
                    * **Metriken:**: Kennzahlen wie Speicherverbrauch, Anzahl Requests je Sekunde, CPU-Auslastung, ...
                    * **Logging:** Protokollausgaben der einzelnen Services, um Fehler nachvollziehen zu können
                    * **Tracing:** Nachverfolgung von Aufrufketten, um komplexe Fehlersituationen analysieren zu können
                </div>
                <div class="d-flex align-items-stretch" style="gap: 1em;">
                    <img src="02-architektur/metriken.png" class="d-block w-100 img-thumbnail" />
                    <img src="02-architektur/logging.png" class="d-block w-100 img-thumbnail" />
                    <img src="02-architektur/tracing.png" class="d-block w-100 img-thumbnail" />
                </div>
            </div>
        </article>
    </section>

    <!-- TODO: Quellcode anpassen, dann hier freischalten und Beschreibung ergänzen -->
    <!--
    <section data-title="Fallbeispiel: Webflicks">
        <article class="centered-content">
            <div>
                <div class="mb-3">
                    <lsx-github-edit
                        url="https://github.com/DennisSchulmeister/dhbwka-wwi-vertsys-2022-quellcodes/tree/main/Beispielanwendung%20Webflicks"></lsx-github-edit>
                </div>
            
                <div class="d-flex flex-column flex-md-row gap-3">
                    <img src="02-architektur/beispiel-webflicks-1.png" class="img-thumbnail d-block w-100">
                    <img src="02-architektur/beispiel-webflicks-2.png" class="img-thumbnail d-block w-100">
                    <img src="02-architektur/beispiel-webflicks-3.png" class="img-thumbnail d-block w-100">
                </div>
            </div>
        </article>
    </section>
    -->
</section>

<section data-title="Das Cloud-Betriebsmodell">
    <section data-title="Die Cloud aus Konsumentensicht">
        <article class="centered-content">
            <div class="limited-width2">
                <img src="02-architektur/cloud-storage.png" class="d-block w-100 mb-5">
            
                <div class="d-flex flex-column flex-md-row gap-2">
                    <img src="02-architektur/cat1.jpg" class="d-block w-100 img-thumbnail">
                    <img src="02-architektur/cat2.jpg" class="d-block w-100 img-thumbnail">
                    <img src="02-architektur/cat3.jpg" class="d-block w-100 img-thumbnail">
                    <img src="02-architektur/cat4.jpg" class="d-block w-100 img-thumbnail">
                </div>
            
                <small>
                    <small>
                        Zitat gefunden auf:
                        <a href="https://docs.kraudcloud.com/technology/storage/" target="_blank">kraudcloud.com</a>, <br>
                        
                        Bildnachweise:
                        <a href="https://pixabay.com/photos/cat-pet-licking-animal-tabby-cat-323262/" target="_blank">Pixabay: TeamK</a>,
                        <a href="https://pixabay.com/photos/cat-kitten-pets-animals-housecat-2934720/" target="_blank">Pixabay: Kirgiz03</a>,
                        <a href="https://pixabay.com/photos/cat-siamese-cat-fur-kitten-2068462/" target="_blank">Pixabay: webandi</a>,
                        <a href="https://pixabay.com/photos/cat-tired-yawn-stretch-814952/" target="_blank">Pixabay: jonathansautter</a>
                    </small>
                </small>
            </div>
        </article>
    </section>
    
    <section data-title="Abgrenzung von typischen Onlinediensten">
        <article class="centered-content">
            <div class="limited-width2">
                <div class="markdown mt-3 mb-3">
                    Anwendungen zum Synchronisieren von Dateien wie Dropbox, OneDrive oder Owncloud
                    werden umgangssprachlich oft als Cloud bezeichnet. Man sagt, dass die Dateien
                    _mit der Cloud synchronisiert_ werden. Dies ist jedoch problematisch, da „Cloud”
                    hier lediglich sinnbildlich für einen irgendwie gearteten Onlinedienst steht.
                    Hinzu kommt, dass zumindest Owncloud gar keine Cloud-Anwendung ist, sondern eine
                    in PHP implementierte, traditionelle Webanwendung. Nach dieser Definition müsste
                    demnach jede Webanwendung auch eine Cloud-Anwendung sein.
                </div>
            
                <lsx-grid-fluid class="p-0">
                    <lsx-row>
                        <lsx-col size="md">
                            <img src="02-architektur/dropbox-screenshot.png" class="d-block img-thumbnail" style="height: 100%;"/>
                        </lsx-col>
                        <lsx-col size="md">
                            <img src="02-architektur/owncloud-screenshot.png" class="d-block img-thumbnail" style="height: 100%;"/>
                        </lsx-col>
                    </lsx-row><lsx-row>
                        <lsx-col size="md">
                            <img src="02-architektur/owncloud-quellcode.png" class="d-block img-thumbnail" style="height: 100%;"/>
                        </lsx-col>
                        <lsx-col size="md">
                            <img src="02-architektur/owncloud-installation.png" class="d-block img-thumbnail" style="height: 100%;"/>
                        </lsx-col>
                    </lsx-row>
                </lsx-grid-fluid>
            </div>
        </article>
    </section>
    
    <section data-title="Abgrenzung von klassischem Hosting">
        <article class="centered-content">
            <div class="limited-width2">
                <div class="markdown mt-3 mb-3">
                    Schon früher war es insbesondere für kleinere Unternehmen üblich, die Hardware zur
                    Bereitstellung eines Onlinedienstes nicht selbst zu betreiben. Dieses Modell wird
                    Hosting genannt, da der Anbieter zwar die Hardwareplattform (den Host) zur Verfügung
                    stellt, Installation und Betrieb der Anwendung aber immer noch selbst vorgenommen
                    werden müssen.
                </div>
            
                <div class="d-flex gap-3 flex-column flex-md-row">
                    <div class="card flex-grow-1 w-100">
                        <img src="02-architektur/hosting-dedicated.jpg" class="card-img-top">
                        <div class="card-header border-top fw-bold">
                            Dedicated Root Server                        
                        </div>
                        <div class="card-body markdown small">
                            Hier vermietet der Anbieter einen dedizierten Computer an den Kunden.
                            Installation und Einrichtung müssen, sofern es kein „managed” Angebot
                            mit zusätzlicher Dienstleistung ist, aus der Ferne selbst erledigt werden.
                            Im Gegenzug können jedes beliebige Betriebsystem und jede Software
                            aufgespielt werden.
                        </div>
                    </div>
            
                    <div class="card flex-grow-1 w-100">
                        <img src="02-architektur/hosting-vserver.png" class="card-img-top">
                        <div class="card-header border-top fw-bold">
                            Virtual Private Server
                        </div>
                        <div class="card-body markdown small">
                            Hier steht eine virtuelle Maschine zur Verfügung, die sich weitgehend wie
                            dedizierte Hardware nutzen lässt. Die Ressourcen können jedoch geringer
                            ausfallen, da die Hardware von vielen Kunden geteilt wird. Die Installation
                            eines eigenen Betriebssystems kann ebenfalls mit Einschränkungen verbunden sein.
                        </div>
                    </div>
            
                    <div class="card flex-grow-1 w-100">
                        <img src="02-architektur/hosting-web.png" class="card-img-top">
                        <div class="card-header border-top fw-bold">
                            Web Hosting
                        </div>
                        <div class="card-body markdown small">
                            Hier wird lediglich der Webserver virtualisiert und etwas Speicherplatz in
                            einer vorkonfigurierten Serverfarm angeboten. Die Einstellungsmöglichkeiten
                            sind sehr begrenzt und oft auf traditionelle Webanwendungen mit PHP als
                            Programmiersprache und MariaDB als Datenbank zugeschnitten.
                        </div>
                    </div>
                </div>
            
                <small>
                    <small>
                        ¹ Bildnachweis:
                        <a href="https://pixabay.com/photos/technology-servers-server-1587673/" target="_blank">Pixabay: heladodementa</a>
                    </small>
                </small>
            </div>
        </article>
    </section>
    
    <section data-title="Grundidee der Cloud">
        <article>
            <lsx-grid-fluid class="p-0">
                <lsx-row>
                    <lsx-col size="md-9" class="mb-3">
                        <img src="02-architektur/cloud-betriebsmodell.png" class="d-block w-100" />
                    </lsx-col>
                    <lsx-col size="md" class="d-flex flex-column gap-3">
                        <lsx-card title="Automatisierung" bold class="markdown small">
                            Die Grundidee der Cloud ist, die Bereitstellung und den Betrieb verteilter
                            Anwendungen so weit wie möglich zu automatisieren. Eine Cloudumgebung besteht
                            daher aus einem großen Rechencluster, dessen Ressourcen auf viele Anwendungen
                            aufgeteilt werden. Manuelle Installationsschritte sollen vermieden werden.
                            {.mb-0}
                        </lsx-card>
                        
                        <lsx-card title="Isolation" bold class="markdown small">
                            Die physischen und virtuellen Maschinen sowie Speicherressourcen einer Cloudumgebung
                            werden vollständig abstrahiert, wodurch jede Anwendung einen eigenen, **virtuellen
                            Computercluster** erhält. Häufig (aber nicht immer) wird dabei auch das Netzwerk
                            virtualisiert, wodurch interne Services in einem **privaten Netzwerk** vor öffentlichen
                            Zugriffen geschützt werden können.
                            {.mb-0}
                        </lsx-card>
                        
                        <lsx-card title="Skalierung und Elastizität" bold class="markdown small">
                            **Skalierung** beschreibt die Anpassung der zur Verfügung gestellten Ressourcen
                            entsprechend dem Leistungsbedarf einer Anwendung. Beim klassischen Hosting und
                            bei sehr einfachen Cloud-Installationen ist dies nur durch manuelles Eingreifen
                            möglich. Echte Cloud-Anwendungen sind jedoch **elastisch**, so dass der Cluster
                            die Ressourcen automatisch skalieren kann.
                            {.mb-0}
                        </lsx-card>
                        
                        <lsx-card title="Variable Kosten" bold class="markdown small">
                            Aufgrund der dynamischen Ressourcenzuteilung bieten viele Cloud-Angebote eine
                            **nutzungsabhängige Abrechnung**, die sich nach Anzahl der tatsächlich genutzten
                            Minuten zur Ausführung von Programmcode, tatsächlich belegtem Speicherplatz
                            oder Netzwerktraffic richtet. Im Vergleich zu klassischem Hosting fallen die
                            durchschnittlichen Kosten daher oft geringer aus.
                            {.mb-0}
                        </lsx-card>
                    </lsx-col>
                </lsx-row>
            </lsx-grid-fluid>
        </article>
    </section>
    
    <section data-title="Pet vs. Cattle">
        <article class="centered-content">
            <div class="limited-width2">
                <div class="d-flex gap-3 flex-column flex-md-row">
                    <div class="card flex-grow-1 w-100">
                        <img src="02-architektur/pet-vs-cattle-1.jpg" class="card-img-top">
                        <div class="card-header border-top fw-bold">
                            Hosting
                        </div>
                        <div class="card-body small">
                            Die Software wird gehegt und gepflegt wie ein Haustier.
                        </div>
                    </div>
                
                    <div class="card flex-grow-1 w-100">
                        <img src="02-architektur/pet-vs-cattle-2.jpg" class="card-img-top">
                        <div class="card-header border-top fw-bold">
                            Cloud
                        </div>
                        <div class="card-body small">
                            Die Software wird wie Vieh in der Massentierhaltung behandelt.
                        </div>
                    </div>
                </div>
            
                <small>
                    <small>
                        Bildnachweise:
                        <a href="https://pixabay.com/photos/children-dog-pet-cute-footwear-1866531/" target="_blank">Pixabay: Pexels</a>,
                        <a href="https://pixabay.com/photos/sheeps-animals-mammals-live-stock-6828766/" target="_blank">Pixabay: smoms_photography</a>
                    </small>
                </small>
            </div>
        </article>
    </section>
    
    <section data-title="Das As-a-Service-Geschäftsmodell">
        <article class="centered-content">
            <div class="limited-width2">
                <div class="markdown mt-3 mb-5">
                    Cloudangebote werden häufig mit dem Namenszusatz „as-a-Service” angeboten,
                    wie beispielsweise „Database-as-a-Service“ oder „Software-as-a-Service".
                    Damit ist gemeint, dass die jeweilige Software **nicht klassisch lizenziert,
                    sondern als Dienstleistung** vermarktet wird. Installation, Betrieb und Pflege
                    werden fallen in die Verantwortung des Anbieters, wodurch diese aus Kundensicht
                    komplett ausgelagert werden können.
                </div>
            
                <div class="d-flex gap-3 flex-column flex-md-row mb-4">
                    <div class="flex-grow-1 w-100 markdown small">
                        ### Infrastructure-as-a-Service {.mb-3}
            
                        <img src="02-architektur/modelle-iaas.png" class="w-100 mb-3">
                
                        Im einfachsten Fall stellt die Cloud virtuelle Maschinen zur manuellen Einrichtung
                        sowie dazugehörige Dienste wie Objektspeicher und Netzwerkrouting zur Verfügung.
                        Lediglich die Bereitstellung aus Sicht des Cloudanbieters wird dabei automatisiert.
                    </div>
                    <div class="flex-grow-1 w-100 markdown small">
                        ### Platform-as-a-Service {.mb-3}
            
                        <img src="02-architektur/modelle-paas.png" class="w-100 mb-3">
                
                        Auf die Entwicklung von Cloudanwendungen zugeschnittene Angebote bieten eine
                        vorkonfigurierte Laufzeitumgebung für selbstgeschriebenen Quellcode. Deployment
                        und Betrieb werden weitgehend automatisiert. Es besteht jedoch die Gefahr von
                        Vendor Lock-In aufgrund der Verwendung anbieterspezifischer Bibliotheken.
                    </div>
                    <div class="flex-grow-1 w-100 markdown small">
                        ### Software-as-a-Service {.mb-3}
            
                        <img src="02-architektur/modelle-saas.png" class="w-100 mb-3">
                
                        Am weitesten abstrahiert sind SaaS-Angebote zur Bereitstellung ganzer Anwendungspakete.
                        Als Kunde registriert man sich lediglich für eine Anwendung, die gegen eine monatliche
                        Gebühr zur Verfügung gestellt wird. Alle Kunden teilen sich meist den Quellcode, während
                        die Daten getrennt werden.
                    </div>
                </div>
            
                <div class="markdown">
                    Angebote wie **Function-as-a-Service** (auch **Serverless** genannt, da die Verwaltung von Serverinstanzen komplett
                    wegabstrahiert wird) oder **Database-as-a-Service** richten ebenfalls an Anwendungsentwickler und zählen deshalb zu
                    Platform-as-a-Service.
                    
                    Die großen Anbieter wie Amazon, Google oder Microsoft bieten grundsätzlich eine Mischung aus allen Modellen, während
                    sich kleinere Anbieter wie [Heroku](https://heroku.com/){target="_blank"}, [Render](https://render.com/){target="_blank"},
                    [Fly.io](https://fly.io/){target="_blank"} meist auf Plattformdienste beschränken.
                    [MongoDB Atlas](https://www.mongodb.com/de-de/atlas){target="_blank"}, [Auth0](https://auth0.com/){target="_blank"}
                    und viele mehr zielen hingegen auf ganz spezielle Anwendungsfälle ab.
                </div>
            </div>
        </article>
    </section>
    
    <section data-title="Vertiefende Videos" class="centered-content">
        <div class="limited-width2">
            <lsx-grid-fluid>
                <lsx-row>
                    <lsx-col size="md">
                        <lsx-youtube video="_epyprLse_4" aspect-ratio="16x9" class="w-100"></lsx-youtube>
                        <a href="https://youtu.be/_epyprLse_4" target="_blank">Link zum Video</a>
                    </lsx-col>
                    <lsx-col size="md">
                        <lsx-youtube video="Q7580888ce4" aspect-ratio="16x9" class="w-100"></lsx-youtube>
                        <a href="https://youtu.be/Q7580888ce4" target="_blank">Link zum Video</a>
                    </lsx-col>
                </lsx-row>
            </lsx-grid-fluid>
        
            <lsx-info-box type="warning" class="mt-3">
                Die Videos beziehen sich an manchen Stellen noch auf die Entwicklung mit Java und
                dem Spring-Framework. Auch wenn wir inzwischen Node.js/JavaScript in der Vorlesung
                verwenden, sind die Grundprinzipien jedoch dieselben.
            </lsx-info-box>
        </div>
    </section>
</section>

<!-- TODO: Übungsaufgaben
    - Gruppenarbeit: Größere Beispiel-Anwendung zum Laufen bringen, erst jeder auf seinem Laptop, dann verteilt
    - Gruppenarbeit: Skalierung eines Microservices (je Laptop eine Instanz)
    - Notebook as a Service als Fallbeispiele zum Laufen bringen?

    - Aufgabe: Banküberweisungen sind das klassische Beispiel für ACID-Transaktionen. Aber sind sie wirklich atomar und isloert?
      Recherchieren Sie den Begriffe Valuta bzw. Wertstellung und ziehen Sie diesen für Ihre Begründung heran.
-->
<!-- <section data-title="Übungsaufgaben">
</section> -->