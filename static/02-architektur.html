<section data-chapter="h1" data-title="Architektur verteilter Systeme" data-background-color="rgb(210,190,210)">
    <article class="markdown">
        #### Grundlagen verteilter Systeme {.dhbw-lightblue}

        <table>
            <tbody>
                <tr>
                    <td class="lernziel-art">Verstehen</td>
                    <td>Die Begriffe <i>verteiltes System</i> und <i>verteilte Anwendung</i> definieren und abgrenzen</td>
                </tr>
                <tr>
                    <td class="lernziel-art">Wissen</td>
                    <td>Typische Anforderungen wie <i>Transparenz</i>, <i>Skalierbarkeit</i> und <i>Sicherheit</i> benennen</td>
                </tr>
                <tr>
                    <td class="lernziel-art">Können</td>
                    <td>Das <i>CAP-Theorem</i> auf praktische Fallbeispiele anwenden können</td>
                </tr>
            </tbody>
        </table>

        #### Typische Architekturmuster {.dhbw-lightblue .mt-4}

        <table>
            <tbody>
                <tr>
                    <td class="lernziel-art">Wissen</td>
                    <td>Den Aufbau und die Bedeutung des TCP/IP-Protokollstapels erklären</td>
                </tr>
                <tr>
                    <td class="lernziel-art">Verstehen</td>
                    <td>Die Rolle von <i>Client</i>, <i>Server</i> und <i>Peer</i> in verteilten Architekturen abgrenzen</td>
                </tr>
                <tr>
                    <td class="lernziel-art">Verstehen</td>
                    <td>Die Besonderheiten und Vorteile einer <i>Microservice-Architektur</i> erklären</td>
                </tr>
                <tr>
                    <td class="lernziel-art">Wissen</td>
                    <td>Typische Anforderungen und die Funktionsweise eines <i>API-Gateways</i> kennen</td>
                </tr>
            </tbody>
        </table>

        <span style="font-size: 240px; color: white;" class="dhbw-text-shadow" >🏁</span>
    </article>
    <aside class="markdown">
        In einer immer stärker vernetzten Welt spielen verteilte Systeme eine zentrale Rolle.
        Ob Cloud-Dienste, soziale Netzwerke oder Online-Shops – all diese Systeme sind auf eine
        kluge Architektur angewiesen, um zuverlässig, sicher und skalierbar zu funktionieren.
        In diesem Kapitel tauchen wir deshalb in die Grundlagen und Architekturmuster verteilter
        Systeme ein, um zu verstehen, wie moderne Anwendungen aufgebaut sind und welche Herausforderungen
        sie meistern müssen.  
        
        Gleich zu Beginn klären wir die entscheidende Frage: Was unterscheidet ein verteiltes System von einer
        verteilten Anwendung? Woran erkennt man eine verteilte Architektur, und warum setzen so viele moderne
        Anwendungen auf diesen Ansatz? Dabei werden wir nicht nur die Definition betrachten, sondern auch zentrale
        Anforderungen wie *Transparenz*, *Skalierbarkeit* und *Sicherheit* verstehen. Dabei werden wir auch das
        *CAP-Theorem* betrachten und anhand praktischer Beispiele sehen, welche strategischen Entscheidungen
        Entwickler*innen treffen müssen.
        
        Nach den Grundlagen widmen wir uns typischen *Architekturmustern*. Eine verteilte Anwendung besteht aus mehreren
        Komponenten, die über Netzwerke miteinander kommunizieren. Aber wie genau funktioniert das? Ein Schlüsselkonzept
        ist der *TCP/IP-Protokollstapel*, der als Grundlage fast aller modernen Netzwerkanwendungen dient. Aber nicht nur
        die technische Kommunikation ist wichtig. Auch die Struktur der Systeme selbst ist entscheidend. Wir werden uns
        daher kurz mit verschiedenen Rollen und dann mit der *Microservice-Architektur* beschäftigen. Insbesondere werden
        wir sehen, warum sich Unternehmen zunehmend für diesen Ansatz entscheiden und welche Vorteile er gegenüber monolithischen
        Systemen hat.
        
        ##### Warum ist dieses Kapitel wichtig?

        Die Architektur eines verteilten Systems ist entscheidend für dessen Erfolg. Wer die Mechanismen dahinter versteht,
        kann leistungsfähige und robuste Anwendungen entwerfen, die auch unter hoher Last zuverlässig funktionieren. Dieses
        Kapitel gibt Ihnen das Wissen und die Werkzeuge an die Hand, um verteilte Systeme nicht nur zu verstehen, sondern auch
        aktiv mitzugestalten. 🚀
    </aside>
</section>

<!-- =================== -->
<!-- Allgemeine Konzepte -->
<!-- =================== -->
<section data-use-template="teilkapitel" data-titel="Allgemeine Konzepte"></section>

<section data-title="Verteilte Systeme und Anwendungen">
    <section data-title="Alltäglicher Sprachgebrauch" class="centered-content">
        <lsx-grid-fluid class="p-0 limited-width2">
            <lsx-row>
                <lsx-col size="md-8">
                    <lsx-youtube video="UWU14-EK9CE" aspect-ratio="16x9" class="w-100 mb-0"></lsx-youtube>

                    <small>
                        <small>
                            Quelle: Filmausschnitt aus „Star Trek der Film (1979)”
                        </small>
                    </small>
                </lsx-col>
                <lsx-col size="md" class="markdown lead centered-content align-items-start">
                    Jeden Tag sprechen wir von Systemen:

                    <lsx-ul emoji="🚀">
                        <li><i>„Du musst dich am System anmelden.”</i></li>
                        <li><i>„Das ist im System gespeichert.”</i></li>
                        <li><i>„Mein Betriebssystem hängt mal wieder.”</i></li>
                    </lsx-ul>

                    Doch was ist überhaupt ein „System“
                    <span style="color: crimson; text-shadow: 1px 1px 1px rgba(0,0,0,0.5);">⁉️</span>
                </lsx-col>
            </lsx-row>
        </lsx-grid-fluid>
    </section>

    <section data-title="Der Systembegriff allgemein" class="centered-content">
        <div class="limited-width">
            <blockquote class="blockquote fst-italic">
                <p>
                    Als System (altgriechisch sýstēma „aus mehreren Einzelteilen zusammengesetztes Ganzes“)
                    wird im Allgemeinen ein abgrenzbares, natürliches oder künstliches „Gebilde“ bezeichnet,
                    das aus verschiedenen Komponenten mit unterschiedlichen Eigenschaften besteht, die aufgrund
                    bestimmter geordneter Beziehungen untereinander als gemeinsames Ganzes betrachtet werden
                    (können).
                </p>
                <figcaption class="blockquote-footer">
                    <cite>Wikipedia zum Begriff „System”</cite>
                </figcaption>
            </blockquote>

            <h4>Wichtige Stichworte dieser Definition</h4>

            <lsx-ul emoji="☑️">
                <li>Aus mehren Einzelteilen zusammengesetztes Ganzes</li>
                <li>Abgrenzbares Gebilde aus verschienden Komponenten</li>
                <li>Geordnete Beziehungen untereinander</li>
                <li>Als gemeinsames Ganzes betrachtet</li>
            </lsx-ul>
        </div>
    </section>

    <section data-title="Definition: Verteiltes System" class="centered-content">
        <div class="limited-width2">
            <lsx-grid-fluid class="p-0 mb-5">
                <lsx-row>
                    <lsx-col size="md-5">
                        <lsx-card title="Bekannte Definitionen" bold class="h-100">
                            <blockquote class="blockquote fst-italic mb-4 fs-6">
                                <p>
                                    A distributed system stops you from getting any work done because computer crashed
                                    that you didn't even know it existed.
                                </p>
                                <figcaption class="blockquote-footer">
                                    <cite>Scherzhafte Definition nach Leslie Lamport</cite>
                                </figcaption>
                            </blockquote>
    
                            <blockquote class="blockquote fst-italic fs-6">
                                <p>
                                    A distributed system is a collection of [computers] that appears to its users as a single
                                    coherent system.
                                </p>
                                <figcaption class="blockquote-footer">
                                    <cite>Steen & Tanenbaum</cite>
                                </figcaption>
                            </blockquote>
                        </lsx-card>
                    </lsx-col>
    
                    <lsx-col size="md">
                        <lsx-card title="Merkmale verteilter Systeme" bold class="h-100">
                            <lsx-ul emoji="☑️">
                                <li>Infrastruktur bestehend aus Hardware und Software für verteiltes Rechnen.</li>
                                <li>Bestehend aus mehreren, voneinander unabhängig agierenden Computern.</li>
                                <li>Datenaustausch über ein Netzwerk ohne geteilten Hauptspeicher.</li>
                                <li>Die Knoten arbeiten zusammen, um eine übergeordnete Aufgabe zu erfüllen.</li>
                                <li>Das System stellt Ressourcen, Rechenleistung oder Dienste zur Verfügung.</li>
                                <li>Das System sorgt zusätzlich für Skalierbarkeit, Redundanz und Fehlertoleranz.</li>
                            </lsx-ul>
                        </lsx-card>
                    </lsx-col>
                </lsx-row>
            </lsx-grid-fluid>
        </div>

        <div class="limited-width">
            <img src="02-architektur/verteiltes-system.jpg" alt="" class="d-block w-100">
        </div>
    </section>

    <section data-title="Definition: Verteilte Anwendung" class="centered-content">
        <div class="limited-width2">
            <lsx-grid-fluid class="p-3 mb-4">
                <lsx-row>
                    <lsx-col size="md-7">
                        <lsx-card title="Merkmale verteilter Anwendungen" bold class="h-100">
                            <lsx-ul emoji="☑️">
                                <li>Fachspezifische Software, die auf einem verteilten System läuft.</li>
                                <li>Nutzt die Ressourcen des verteilten Systems, um ihre Funktionen bereitzustellen.</li>
                                <li>Kann hierfür prinzipiell auf mehreren Rechnern ausgeführt werden.</li>
                                <li>Die Software-Komponenten kommunizieren über den Austausch von Nachrichten.</li>
                            </lsx-ul>
                        </lsx-card>
                    </lsx-col>
                    <lsx-col size="md">
                        <lsx-card title="Zusammenfassung der Abgrenzung" bold class="h-100 markdown">
                          **Verteiltes System:** Die Infrastruktur (Hardware, Netzwerk, Software, Middleware),
                          die verteiltes Rechnen ermöglicht.
                  
                          **Verteilte Anwendung:** Eine Software, die diese Infrastruktur
                          nutzt, um über mehrere Rechner verteilt zu laufen. {.mb-0}
                        </lsx-card>
                    </lsx-col>
                </lsx-row>
            </lsx-grid-fluid>
        </div>

        <div class="limited-width">
            <img src="02-architektur/verteilte-anwendung.svg" alt="" class="d-block w-100">
        </div>
    </section>

    <section data-title="Beispiele für verteilte Systeme" class="centered-content">
        <div class="centered-content flex-row flex-wrap gap-3">
            <!-- Das Internet -->
            <lsx-modal>
                <lsx-thumbnail style="height: 18em;" class="mw-100">
                    <img src="02-architektur/arpanet.png" class="d-block h-100 mw-100 dhbw-thumbnail"/>
                </lsx-thumbnail>
                <lsx-content>
                    <lsx-card title="Das Internet" bold class="mh-100">
                        <lsx-card-body class="overflow-scroll">
                            <p class="lead mb-4" style="text-align: justify;">
                                Das größte verteilte System weltweit ist natürlich das Internet. Es ging in der heutigen
                                Form 1983 aus dem bereits seit den 1960ern entwickelten ARPANET hervor. Die Abbildung unten
                                zeigt eine zeitgenössische Karte mit allen damals an das ARPANET angeschlossenen Knoten.
                            </p>
                            <img src="02-architektur/arpanet.png" class="d-block m-auto mw-100" style="max-height: 80vh;"/>
                        </lsx-card-body>
                    </lsx-card>
                </lsx-content>
            </lsx-modal>

            <!-- Webanwendungen -->
            <lsx-modal>
                <lsx-thumbnail style="height: 18em;" class="mw-100">
                    <img src="02-architektur/webapp.png" class="d-block h-100 mw-100 dhbw-thumbnail"/>
                </lsx-thumbnail>
                <lsx-content>
                    <lsx-card title="Webanwendungen" bold class="mh-100">
                        <lsx-card-body class="overflow-scroll">
                            <p class="lead mb-4" style="text-align: justify;">
                                Webanwendungen laufen zwar wie die meisten verteilten Anwendungen über das Internet, nutzen
                                aber als Teil davon ein sehr spezielles verteiltes System bestehend aus Load Balancern,
                                Web-Servern, Datenbanken und weiteren Komponenten.
                            </p>
                            <img src="02-architektur/webapp.png" class="d-block m-auto mw-100" style="max-height: 80vh;"/>
                        </lsx-card-body>
                    </lsx-card>
                </lsx-content>
            </lsx-modal>

            <!-- Internet of Things -->
            <lsx-modal>
                <lsx-thumbnail style="height: 18em;" class="mw-100">
                    <img src="02-architektur/iot.jpg" class="d-block h-100 mw-100 dhbw-thumbnail"/>
                </lsx-thumbnail>
                <lsx-content>
                    <lsx-card title="Internet of Things" bold class="mh-100">
                        <lsx-card-body class="overflow-scroll">
                            <p class="lead mb-4" style="text-align: justify;">
                                IoT-Installationen zählen ebenfalls zu den größten verteilten Systemen (bzw. die darauf
                                laufenden Anwendungen zu den größten, verteilten Anwendungen) weltweit, da oft viele tausend
                                physische Geräte verbunden sind. Hinzu kommen meist große Server-Backends zur Überwachung und
                                Steuerung der Geräte sowie der Datensammlung und Auswertung.
                            </p>
                            <div class="d-flex flex-wrap justify-content-center align-items-center gap-3">
                                <img src="02-architektur/iot.jpg" class="d-block h-100 mw-100" style="max-height: 40vh;"/>
                                <img src="02-architektur/iot-cartoon.png" class="d-block h-100 mw-100" style="max-height: 40vh;"/>
                            </div>
                        </lsx-card-body>
                    </lsx-card>
                </lsx-content>
            </lsx-modal>

            <!-- Blockchain -->
            <lsx-modal>
                <lsx-thumbnail style="height: 18em;" class="mw-100">
                    <img src="02-architektur/blockchain1.jpg" class="d-block h-100 mw-100 dhbw-thumbnail"/>
                </lsx-thumbnail>
                <lsx-content>
                    <lsx-card title="Blockchain" bold class="mh-100">
                        <lsx-card-body class="overflow-scroll">
                            <p class="lead style="text-align: justify;">
                                Bei der Blockchain handelt es sich um eine kryptographisch abgesicherte, verteilte
                                Datenbank, an die nur neue Inhalte angehängt, aber keine enthaltenen Daten gelöscht
                                werden können. Man spricht hier auch von Transaktionen. Eine Transaktion gilt nur
                                dann als bestätigt, wenn mehr als die Hälfte aller Hauptknoten diese in ihre lokale
                                Version der Blockchain-Datenbasis aufnimmt. Die Daten werden hierfür in einem P2P-Netzwerk
                                veröffentlicht und untereinander ausgetauscht.
                            </p>
                            <p class="mb-4" style="text-align: justify;">
                                Bitcoin leicht erklärt:
                                <a href="https://www.wpvs.de/repo/publikationen/Wie%20funktioniert%20eigentlich%20Bitcoin.pdf" target="_blank">Wie funktioniert eigentlich Bitcoin?</a>
                            </p>
                            <div class="d-flex flex-wrap justify-content-center align-items-center gap-5">
                                <img src="02-architektur/blockchain1.jpg" style="height: 20em; max-height: 40vh; max-width: 100%;"/>
                                <img src="02-architektur/blockchain2.png" style="height: 20em; max-height: 40vh; max-width: 100%;"/>
                                <img src="02-architektur/blockchain3.png" style="height: 20em; max-height: 40vh; max-width: 100%;"/>
                            </div>
                        </lsx-card-body>
                    </lsx-card>
                </lsx-content>
            </lsx-modal>

            <!-- MIDI -->
            <lsx-modal>
                <lsx-thumbnail style="height: 18em;" class="mw-100">
                    <img src="02-architektur/midi.png" class="d-block h-100 mw-100 dhbw-thumbnail"/>
                </lsx-thumbnail>
                <lsx-content>
                    <lsx-card title="Musical Instrument Digital Interface" bold class="mh-100">
                        <lsx-card-body class="overflow-scroll">
                            <p class="lead mb-4" style="text-align: justify;">
                                <a href="https://de.wikipedia.org/wiki/MIDI" target="_blank">MIDI</a>
                                ist eine 1982 eingeführte Digitalschnittstelle zur Verbindung elektronischer Musikgeräte.
                                Ursprünglich zur herstellerübergreifenden Verbindung von Synthesizern und Master-Keyboards vorgesehen,
                                können damit heute alle möglichen Geräte gesteuert werden. Technisch gesehen beinhalten die Geräte
                                hierfür einen eingebetteten Mikroprozessor, um MIDI-Nachrichten senden und empfangen zu können.
                                Die Nachrichten selbst sind überwiegend drei Bytes lang und kodieren musikalische Ereignisse wie
                                das Spielen einer Note oder Drücken des Haltepedals.
                            </p>
                            <!-- <lsx-youtube class="img-thumbnail embed-responsive" video="Kpzhh9_5iqB0"></lsx-youtube> -->
                            <div class="centered-content">
                                <div class="embed-responsive ratio ratio-16x9 limited-width">
                                    <iframe class="d-block" src="https://www.youtube-nocookie.com/embed/pzhh9_5iqB0?rel=0&amp;showinfo=0" allowfullscreen></iframe>
                                </div>
                            </div>
                        </lsx-card-body>
                    </lsx-card>
                </lsx-content>
            </lsx-modal>
        </div>
    </section>

    <section data-title="Beispiele für verteilte Anwendungen" class="centered-content">
        <div class="limited-width2">
            <p class="dhbw-text-columns mb-5" detail-content>
                Auch wenn wir es inzwischen kaum noch merken, begleiten verteilte Systeme und Anwendungen
                schon seit langem unseren Alltag. Wie selbstverständlich surfen wir im Internet, teilen
                Bilder online oder verschicken Kurznachrichten mit dem Smartphone. Abends streamen wir dann
                die neuste Folge unserer Lieblingsserie und geht es nach dem Willen der Hersteller, steuern
                wir schon bald sämtliche Haushaltsgeräte ganz bequem per Sprachbefehl vom Sofa aus, optimieren
                den Straßenverkehr mit vernetzten Fahrzeugen und überwachen unsere Umwelt mit immer mehr IoT-Devices.
                Ohne Zweifel leben wir in einer vernetzten Welt, in der immer mehr Computer, Smartphones,
                Smart TVs und viele andere Gegenstände miteinander verbunden sind.
            </p>

            <lsx-grid-fluid class="p-0">
                <lsx-row>
                    <lsx-col size="md">
                        <img src="02-architektur/alltag-internet.png" class="img-thumbnail d-block" style="width: 100%" />
                        Sämtliche Internetdienste
                        <p class="dhbw-fontsize-tiny">
                            <small>
                                Bildnachweis: <a href="https://pixabay.com/illustrations/email-newsletter-marketing-online-3249062/" target="_blank">Pixabay: ribkhan</a>
                            </small>
                        </p>
                    </lsx-col>
                    <lsx-col size="md">
                        <img src="02-architektur/alltag-mobile.jpg" class="img-thumbnail d-block" style="width: 100%" />
                        Mobile Kommunikation
                        <p class="dhbw-fontsize-tiny">
                            <small>
                                Bildnachweis: <a href="https://pixabay.com/photos/communication-communicate-3095538/" target="_blank">Pixabay: Bru-nO</a>
                            </small>
                        </p>
                    </lsx-col>
                </lsx-row>
                <lsx-row>
                    <lsx-col size="md">
                        <img src="02-architektur/alltag-forschung.jpg" class="img-thumbnail d-block" style="width: 100%" />
                        Forschung und Wissenschaft
                        <p class="dhbw-fontsize-tiny">
                            <small>
                                Bildnachweis: <a href="https://pixabay.com/photos/moon-landing-apollo-11-nasa-60582/" target="_blank">Pixabay: WikiImages</a>
                            </small>
                        </p>
                    </lsx-col>
                    <lsx-col size="md">
                        <img src="02-architektur/alltag-vod.jpg" class="img-thumbnail d-block" style="width: 100%" />
                        Video-on-Demand
                        <p class="dhbw-fontsize-tiny">
                            <small>
                                Bildnachweis: <a href="https://unsplash.com/photos/ngMtsE5r9eI" target="_blank">Unsplash: jenskreuter</a>
                            </small>
                        </p>
                    </lsx-col>
                </lsx-row>
                <lsx-row>
                    <lsx-col size="md">
                        <img src="02-architektur/alltag-autonomes-fahren.jpg" class="img-thumbnail d-block" style="width: 100%" />
                        Autonomes Fahren
                    </lsx-col>
                    <lsx-col size="md">
                        <img src="02-architektur/alltag-iot.jpg" class="img-thumbnail d-block" style="width: 100%" />
                        Internet of Things
                        <p class="dhbw-fontsize-tiny">
                            <small>
                                Bildnachweis: <a href="https://pixabay.com/photos/smarthome-smart-house-smart-4447520/" target="_blank">Pixabay: haus_automation</a>
                            </small>
                        </p>
                    </lsx-col>
                </lsx-row>
            </lsx-grid-fluid>
        </div>
    </section>
</section>

<section data-title="Anforderungen an verteilte Systeme">
    <section data-title="Allgemeine Anforderungen" class="centered-content">
        <div class="limited-width2">
            <p class="mb-4" detail-content>
                Die Auswahl geeigneter Architektur-, Kommunikations- und Programmiermodelle hängt sehr stark
                von den Anforderungen des jeweiligen Systems ab bzw. wie diese gewichtet werden. Die nachfolgende
                Übersicht zeigt die wesentlichen Aspekte, die hierbei berücksichtigt werden müssen. Doch auch
                mögliche Problemsituationen müssen, wie wir gleich noch sehen werden, in Betracht gezogen werden,
                da jedes Modell wie so oft eine Verbesserung im einen und einen Kompromiss im anderen Bereich
                mit sich bringt.
            </p>

            <lsx-grid-fluid class="p-0">
                <lsx-row>
                    <lsx-col size="md" class="mb-3 mb-md-0">
                        <lsx-card bold img="02-architektur/anforderung-ressourcennutzung.jpg">
                            <h4>Optimale Ressourcennutzung</h4>
                            <p>
                                Das System muss effizient mit den Ressourcen umgehen und möglichst viele Ressourcen
                                für die eigentliche Anwendung zur Verfügung stellen. Die Anwendung muss ebenfalls
                                intelligent damit umgehen und sie gut nutzen.
                            </p>
                        </lsx-card>
                    </lsx-col>
                    <lsx-col size="md">
                        <lsx-card bold img="02-architektur/anforderung-stabilitaet.jpg">
                            <h4>Stabilität und Fehlertoleranz</h4>
                            <p>
                                Programmabstürze und unvorhersehbares Verhalten sind unbedingt zu vermeiden.
                                Beim Programmieren muss man daher neben den fachlichen Fehlern auch die Fehler
                                berücksichtigen, die sich aus der Verteilung ergeben.
                            </p>
                        </lsx-card>
                    </lsx-col>
                </lsx-row>
                <lsx-row>
                    <lsx-col size="md" class="mb-3 mb-md-0">
                        <lsx-card bold img="02-architektur/anforderung-skalierbarkeit.jpg">
                            <h4>Einfache Skalierbarkeit</h4>
                            <p>
                                Es muss einfach möglich sein, die Leistung des Systems zu erhöhen oder diese zu reduzieren,
                                wenn sie nicht mehr benötigt wird. Dies kann je nach System automatisch oder manuell erfolgen.
                            </p>
                        </lsx-card>
                    </lsx-col>
                    <lsx-col size="md">
                        <lsx-card bold img="02-architektur/anforderung-transparenz.jpg">
                            <h4>Einfache Nutzung (Transparenz)</h4>
                            <p>
                                Zumindest für den Anwender sollte die inheränte Komplexität des Systems verborgen bleiben.
                                Entwickler und Administratoren freuen sich aber auch, wenn sie sich nicht um jede Kleinigkeit
                                kümmern müssen.
                            </p>
                        </lsx-card>
                    </lsx-col>
                </lsx-row>
                <lsx-row>
                    <lsx-col size="md" class="mb-3 mb-md-0">
                        <lsx-card bold img="02-architektur/anforderung-erweiterbarkeit.jpg">
                            <h4>Einfache Erweiterbarkeit</h4>
                            <p>
                                Die Architektur muss flexibel genug sein, um einzelne Teile jederzeit austauschen oder
                                verbessern zu können.
                            </p>
                        </lsx-card>
                    </lsx-col>
                    <lsx-col size="md">
                        <lsx-card bold img="02-architektur/anforderung-sicherheit.jpg">
                            <h4>Sicherheit</h4>
                            <p>
                                Die Vertraulichkeit, Integrität und Authentizität des Systems und seiner Daten muss
                                gewährleistet bleiben.
                            </p>
                        </lsx-card>
                    </lsx-col>
                </lsx-row>
                <lsx-row>
                    <lsx-col size="md">
                        <small>
                            <small>
                                Bildnachweise:
                                <a href="https://pixabay.com/en/wallet-tape-measure-economical-levy-2383496/" target="_blank">Pixabay: Myriams-Fotos</a>,
                                <a href="https://pixabay.com/en/house-of-cards-fragile-patience-763246/" target="_blank">Pixabay: wilhei</a>,
                                <a href="https://pixabay.com/en/mixer-fader-digital-console-1631398/" target="_blank">Pixabay: michaelmep</a>,
                                <a href="https://pixabay.com/en/glass-water-napkin-sky-reflection-2875091/" target="_blank">Pixabay: Michael-T</a>,
                                <a href="https://pixabay.com/en/floor-plan-blueprint-house-home-1474454/" target="_blank">Pixabay: ElasticComputerFarm</a>,
                                <a href="https://pixabay.com/en/building-cctv-door-female-ladies-1839464/" target="_blank">Pixabay: Pexels</a>
                            </small>
                        </small>
                    </lsx-col>
                </lsx-row>
            </lsx-grid-fluid>
        </div>
    </section>

    <section data-title="Transparenz" class="centered-content">
        <lsx-grid-fluid class="limited-width2">
            <!-- Vergleich Wirtschaft vs. Informatik -->
            <lsx-row style="margin-bottom: 0;">
                <lsx-col size="md">
                    <h3>Transparenz in der Wirtschaft</h3>
                    <img src="02-architektur/transparenz1.jpg" alt="" class="img-thumbnail" style="width: 100%" />
                    Alle Informationen liegen offen.
                </lsx-col>
                <lsx-col size="md">
                    <h3>Transparenz in der Informatik</h3>
                    <img src="02-architektur/transparenz2.jpg" alt="" class="img-thumbnail" style="width: 100%" />
                    Ich muss nichts tun. Es läuft einfach.
                </lsx-col>
            </lsx-row>
            <lsx-row style="margin-bottom: 2.5em;">
                <lsx-col size="md">
                    <small>
                        <small>
                            Bildnachweise:
                            <a href="https://pixabay.com/en/tax-paperwork-accounting-business-739107/" target="_blank">Pixabay: stevepb</a>,
                            <a href="https://pixabay.com/en/dogs-carnival-humor-pet-ernst-1190015/" target="_blank">Pixabay: Chiemsee2016</a>,
                            <a href="https://pixabay.com/en/background-christmas-3009949/" target="_blank">Pixabay: monicore</a>
                        </small>
                    </small>
                </lsx-col>
            </lsx-row>

            <!-- Die neun Arten der Transparenz -->
            <lsx-row>
                <lsx-col size="md">
                    <lsx-accordion>
                        <lsx-accordion-page title="Zugriffstransparenz" bold>
                            <lsx-grid-fluid class="p-0">
                                <lsx-row>
                                    <lsx-col size="md">
                                        Falls eine Anwendung zwischen lokalen (auf dem eigenen Rechner befindlichen) und
                                        entfernten Ressourcen unterscheidet, müssen beide auf dieselbe Art und Weise
                                        nutzbar sein.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-foto.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Eine Fotoverwaltung ermöglicht den Zugriff auf lokal gespeicherte Fotoalben.
                                        Einzelne Bilder oder ganze Alben können aber auch auf einem entfernten Server
                                        abgelegt sein, ohne dass sich die Bedienung hierdurch verändert.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-video.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Eine Video-Streaming-App ermöglicht es, einzelne Videos vor dem Anschauen herunterzuladen,
                                        damit diese auch bei langsamer Internetverbindung ruckelfrei abgespielt werden können.
                                        Suche und Wiedergabe der Videos verändern sich aus Benutzersicht dadurch aber nicht, da
                                        die Videos wie gewohnt aufgerufen und abgespielt werden können.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-pwa.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Progressive Web Apps sind Webanwendungen, die nach dem ersten Aufruf im Browser auch lokal installiert
                                        werden können. Sämtliche Dateien werden hierfür in einen lokalen Anwendungscache geladen, der auch offline
                                        funktioniert. Die Entscheidung, ob eine Datei vom Server oder aus dem Cache geladen werden kann, erfolgt
                                        dabei automatisch, ohne dass dies im Quellcode berücksichtigt werden muss.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md">
                                        <small>
                                            <small>
                                                Bildnachweise:
                                                <a href="https://pixabay.com/photos/retro-photo-album-memory-family-1483781/" target="_blank">Pixabay: klimkin</a>,
                                                <a href="https://pixabay.com/photos/camera-video-tv-video-realization-1598620/" target="_blank">Pixabay: JosepMonter</a>,
                                                <a href="https://pixabay.com/photos/laptop-workstation-browsing-tablet-1483974/" target="_blank">Pixabay: Monoar</a>
                                            </small>
                                        </small>
                                    </lsx-col>
                                </lsx-row>
                            </lsx-grid-fluid>
                        </lsx-accordion-page>

                        <lsx-accordion-page title="Ortstransparenz" bold>
                            <lsx-grid-fluid class="p-0">
                                <lsx-row>
                                    <lsx-col size="md">
                                        Dienste und Ressourcen einer Anwendung können aufgerufen werden, ohne wissen zu müssen,
                                        auf welchem Rechner sie sich befinden.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-cdn.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Um die Ladezeit einer Webseite zu optimieren, werden häufig benötigte Dateien durch
                                        Content Delivery Networks ausgeliefert. Hierfür betreiben die Content Delivery Networks
                                        weltweit gespiegelte Rechenzentren, von denen automatisch das mit der kürzesten Zugriffszeit
                                        ausgewählt wird. Auf dieselbe Weise spielen nebenbei auch Video-Streaming-Portale und andere
                                        Onlinedienste ihre Inhalte aus.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-dns.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Die Webseite der DHBW Karlsruhe ist immer unter der Domain
                                        <a href="https://karlsruhe.dhbw.de" target="_blank">karlsruhe.dhbw.de</a> erreichbar.
                                        Zwar muss die Domain zum Aufruf der Seite bekannt sein, diese enthält jedoch keine Informationen
                                        darüber, auf welchen Rechner hierfür zugegriffen werden muss. Diese Information besorgt sich der
                                        Browser stattdessen durch ein DNS-Lookup.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-drucker.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        <a href="https://en.wikipedia.org/wiki/Zero-configuration_networking" target="_blank">Zeroconf</a> ermöglicht die
                                        automatische Konfiguration von Netzwerkgeräten, wodurch unter anderem auch netzwerkfähige Drucker und Scanner
                                        vom Betriebssystem erkannt und eingerichtet werden können. Selbst wenn ein Gerät komplett ausgetauscht wird,
                                        muss die Konfiguration auf dem Anwender-PC nicht angepasst werden.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md">
                                        <small>
                                            <small>
                                                Bildnachweise:
                                                <a href="https://pixabay.com/photos/earth-planet-front-side-back-11593/" target="_blank">Pixabay: WikiImages</a>,
                                                <a href="https://pixabay.com/illustrations/webdesign-design-web-website-3411373/" target="_blank">Pixabay: kreatikar</a>,
                                                <a href="https://pixabay.com/photos/printer-desk-office-fax-scanner-790396/" target="_blank">Pixabay: stevepb</a>
                                            </small>
                                        </small>
                                    </lsx-col>
                                </lsx-row>
                            </lsx-grid-fluid>
                        </lsx-accordion-page>

                        <lsx-accordion-page title="Mobilitätstransparenz" bold>
                            <lsx-grid-fluid class="p-0">
                                <lsx-row>
                                    <lsx-col size="md">
                                        Die Ressourcen einer verteilten Anwendung können jederzeit auf andere Maschinen
                                        umziehen, ohne dass sich dies auf die Anwendung auswirkt.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-namensdienst.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Namensdienste wie das Domain Name System ermöglichen es, die damit verwalteten
                                        Ressourcen jederzeit umzuziehen, da die exakte Adresse einer Ressource vor jedem
                                        Zugriff darin nachgeschlagen werden muss. Aus diesem Grund kann sich zum Beispiel
                                        die IP-Adresse einer Webseite jederzeit ändern, ohne dass die meisten Besucher*innen
                                        dies merken.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-backend.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Die Datenbank einer Webanwendung wurde bisher auf derselben Maschine wie der Webserver betrieben,
                                        soll nun aber auf eigene Hardware umziehen. Die Anwendung läuft nach dem Umzug wie gewohnt weiter,
                                        da lediglich ein Eintrag in einer Konfigurationsdatei geändert werden musste. Die Entscheidung
                                        der Programmierer, die Adresse des Datenbankservers nicht hart-codiert im Quellcode zu hinterlegen,
                                        hat sich an diesem Tag als sehr weitsichtig herausgestellt.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-vm.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Der <a href="https://de.wikipedia.org/wiki/Hypervisor" target="_blank">Hypervisor</a> einer
                                        Virtualisierungslösung entscheidet, eine virtuelle Maschine auf einen leistungsfähigeren
                                        Rechenknoten umzuziehen. Hierfür wird die VM ohne Unterbrechung des laufenden Betriebs auf
                                        den neuen Host kopiert und dort weiter ausgeführt.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md">
                                        <small>
                                            <small>
                                                Bildnachweise:
                                                <a href="https://pixabay.com/photos/diary-appointment-address-pen-2080422/" target="_blank">Pixabay: jackmac34</a>,
                                                <a href="https://pixabay.com/photos/server-cloud-development-business-1235959/" target="_blank">Pixabay: ColossusCloud</a>,
                                                <a href="https://pixabay.com/illustrations/cloud-computing-network-internet-2001090/" target="_blank">Pixabay: wynpnt</a>
                                            </small>
                                        </small>
                                    </lsx-col>
                                </lsx-row>
                            </lsx-grid-fluid>
                        </lsx-accordion-page>

                        <lsx-accordion-page title="Persistenztransparenz" bold>
                            <lsx-grid-fluid class="p-0">
                                <lsx-row>
                                    <lsx-col size="md">
                                        Besonders benutzerfreundliche Anwendungen unterscheiden nicht zwischen gespeicherten und
                                        und nicht gespeicherten Daten. Die Speicherung erfolgt automatisch im Hintergrund.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-google.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Cloudbasierte Officepakete wie Google Docs besitzen keinen Menüeintrag zum Speichern
                                        eines Dokuments. Jede Änderung wird mit einem kleinen Zeitversatz automatisch gespeichert,
                                        so dass man nie wieder etwas verlieren kann, wenn man Abends zu schnell aus dem Büro flieht.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md">
                                        <small>
                                            <small>
                                                Bildnachweis:
                                                <a href="https://pixabay.com/illustrations/google-search-engine-browser-search-76517/" target="_blank">Pixabay: Simon</a>
                                            </small>
                                        </small>
                                    </lsx-col>
                                </lsx-row>
                            </lsx-grid-fluid>
                        </lsx-accordion-page>

                        <lsx-accordion-page title="Replikationstransparenz" bold>
                            <lsx-grid-fluid class="p-0">
                                <lsx-row>
                                    <lsx-col size="md">
                                        Aus Performancegründen oder zur Erhöhung der Ausfallsicherheit werden wichtige Daten auf
                                        mehrere Rechenknoten repliziert. Die Datenreplikation erfolgt vollautomatisch im Hintergrund,
                                        wobei das System bei jeder Änderung die Aktualisierung aller Kopien sicherstellt.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-weltkarte.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Weltweit genutzte Anwendungen wie die Googlesuche, Facebook oder Instagram werden in global
                                        verteilten Rechenzentren betrieben, um die Ladezeiten zu verkürzen. Die innerhalb der Anwendung
                                        anfallenden Daten werden deshalb automatisch zwischen den Rechenzentren repliziert, damit jede*r
                                        Anwender*in möglichst dieselben Daten sieht.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-datenbank.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Die meisten Datenbanken erlauben einen automatischen Cluster-Betrieb, wodurch alle Daten auf mehrere
                                        Rechenknoten gespiegelt werden. Lesende Anfragen werden dann von irgend einem gerade verfügbaren Knoten
                                        beantwortet, während ändernde Anfragen an alle Knoten weitergereicht werden.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md">
                                        <small>
                                            <small>
                                                Bildnachweise:
                                                <a href="https://www.openstreetmap.org/#map=2/18.1/-20.7&layers=C" target="_blank">OpenStreetMap</a>,
                                                <a href="https://pixabay.com/photos/info-data-disk-server-database-1641937/" target="_blank">pixabay: FreePhotosART</a>,
                                            </small>
                                        </small>
                                    </lsx-col>
                                </lsx-row>
                            </lsx-grid-fluid>
                        </lsx-accordion-page>

                        <lsx-accordion-page title="Fehlertransparenz" bold>
                            <lsx-grid-fluid class="p-0">
                                <lsx-row>
                                    <lsx-col size="md">
                                        Fehlersituationen werden nicht als Ausnahme sondern als Normalfall betrachtet.
                                        Eine Anwendung sollte daher immer so entworfen werden, dass sie möglichst viele
                                        Fehlersituationen abfangen und automatisch korrigieren kann. Keinesfalls darf
                                        eine Anwendung einfach abstürzen, wenn ein Weiterbetrieb prinzipiell möglich ist.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-email.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Eine E-Mail kann nicht sofort zugestellt werden, da das Postfach des Empfängers
                                        voll ist. Der Mailserver des Senders teilt deshalb mit, die Zustellung innerhalb
                                        der nächsten Tage zu wiederholen. Nur, wenn die Nachricht nach fünf Tagen immer
                                        noch nicht zugestellt wurde, wird der Absender über das endgültige Scheitern
                                        informiert.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-wetterstation.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Eine Wetterstation sammelt kontinuierlich Daten und sendet diese via UMTS an einen zentralen
                                        Server. Bei schlechtem Wetter besteht allerdings nur eine unzuverlässige Internetverbindung,
                                        so dass die Daten nicht immer sofort verschickt werden können. Sämtliche Daten werden daher
                                        in einem internen Ringbuffer gesammelt und so lange an den Server geschickt, bis dieser den
                                        Empfang bestätigt.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-apollo11.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Bereits bei den Apollo-Mondmissionen waren alle Computersysteme mehrfach redundant ausgelegt,
                                        so dass bei Versagen eines Teilsystems dieses vollautomatisch ersetzt werden konnte. Der
                                        <a href="https://en.wikipedia.org/wiki/Saturn_Launch_Vehicle_Digital_Computer" target="_blank">Saturn
                                        Launch Vehicle Digial Computer</a> führte sogar jede Berechnung dreifach redundant aus und
                                        arbeitete stets mit dem Mehrheitsergebnis weiter, um katastrophale Folgen aufgrund von
                                        Hardwarefehlern zu vermeiden.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md">
                                        <small>
                                            <small>
                                                Bildnachweise:
                                                <a href="https://unsplash.com/photos/oeDH20DVb2A" target="_blank">Unsplash: Liam Truong</a>,
                                                <a href="https://pixabay.com/photos/anemometer-weather-station-3977718/" target="_blank">Pixabay: RitaE</a>,
                                                <a href="https://de.wikipedia.org/wiki/Datei:Apollo_11_rollout.jpg" target="_blank">Wikipedia: NASA</a>
                                            </small>
                                        </small>
                                    </lsx-col>
                                </lsx-row>
                            </lsx-grid-fluid>
                        </lsx-accordion-page>

                        <lsx-accordion-page title="Nebenläufigkeitstransparenz" bold>
                            <lsx-grid-fluid class="p-0">
                                <lsx-row>
                                    <lsx-col size="md">
                                        Eine verteilte Anwendung sollte immer so entworfen werden, dass sie von vielen Benutzern
                                        gleichzeitig genutzt werden kann. Hierfür notwendige Sperren und Synchronisationsmechanismen
                                        sollten dabei vor den Anwender*innen verborgen im Hintergrund ablaufen.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-wikipedia.svg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Wikipedia verarbeitet pro Sekunde zwischen 25.000 und 60.000 Seitenzugriffe. Da die meisten
                                        Zugriffe nur lesend erfolgen, kann jeder Artikel auch dann gelesen werden, wenn er gerade von
                                        jemand anderem bearbeitet wird. Bearbeiten zwei Personen gleichzeitig denselben Artikel, wird
                                        beim Speichern ein Bearbeitungskonflikt angezeigt, der manuell aufgelöst werden muss.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-etherpad.png" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Kollaborative Anwendungen wie Etherpad erlauben es mehreren Personen, gleichzeitig am selben
                                        Dokument zu arbeiten. Jede Person sieht dabei in Echtzeit die von den anderen vorgenommenen
                                        Änderungen, weshalb auch niemand ein Dokument exklusiv sperren kann.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-couchdb.svg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        CouchDB kennt keine Datenbanksperren, um gleichzeitige Änderungen an einem Datensatz zu vermeiden.
                                        Tritt ein Konflikt auf, legt die Datenbank einfach zwei Versionen desselben Datensatzes an. Es obliegt
                                        dem Anwendungscode die Versionen bei Bedarf wieder zusammenzuführen.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md">
                                        <small>
                                            <small>
                                                Bildnachweise:
                                                <a href="https://commons.wikimedia.org/wiki/File:Wikipedia-logo-v2.svg" target="_blank">Wikimedia: Nohat</a>,
                                                <a href="https://etherpad.org/" target="_blank">etherpad.org</a>,
                                                <a href="https://commons.wikimedia.org/wiki/File:CouchDB.svg" target="_blank">Wikimedia: Apache Software Foundation</a>
                                            </small>
                                        </small>
                                    </lsx-col>
                                </lsx-row>
                            </lsx-grid-fluid>
                        </lsx-accordion-page>

                        <lsx-accordion-page title="Skalierbarkeitstransparenz" bold>
                            <lsx-grid-fluid class="p-0">
                                <lsx-row>
                                    <lsx-col size="md">
                                        Verteilte Systeme und Anwendungen sollten immer skalierbar sein. Im Idealfall könnnen im
                                        laufenden Betrieb Ressourcen hinzugefügt oder entfernt werden, um die Leistung anzupassen.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-linux.svg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Unter Linux bildet der
                                        <a href="https://de.wikipedia.org/wiki/Logical_Volume_Manager" target="_blank">Logical Volume Manager</a>
                                        eine Abstraktionsschicht zwsichen den tatsächlich auf einem Datenträger vorhandenen Partitionen und den
                                        für das Betriebssystem sichtbaren Dateisystemen. Dadurch wird es möglich, ein Dateisystem jederzeit durch
                                        Hinzufügen weiterer Datenträger zu vergrößern.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-lastverteilung.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Im einfachsten Fall befinden sich die Dateien einer Webseite auf einem zentralen Webserver, von
                                        dem sie abgerufen werden können. Sollen jedoch sehr viele Anfragen gleichzeitig behandelt werden,
                                        können diese über eine vorgeschaltete Lastverteilung auf mehrere Server verteilt werden. Die
                                        Leistungsfähigkeit kann dabei jederzeit durch Starten und Stoppen weiterer Server angepasst werden.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md">
                                        <small>
                                            <small>
                                                Bildnachweise:
                                                <a href="https://pixabay.com/vectors/avatar-beak-black-cute-emotion-1295404/" target="_blank">Pixabay: OpenClipart-Vectors</a>,
                                                <a href="https://pixabay.com/illustrations/vpn-server-router-virtual-firewall-3406770/" target="_blank">Pixabay: kreatikar</a>
                                            </small>
                                        </small>
                                    </lsx-col>
                                </lsx-row>
                            </lsx-grid-fluid>
                        </lsx-accordion-page>

                        <lsx-accordion-page title="Leistungstransparenz" bold>
                            <lsx-grid-fluid class="p-0">
                                <lsx-row>
                                    <lsx-col size="md">
                                        Die Leistung eines verteilten Systems sollte nur von den verfügbaren Ressourcen begrenzt
                                        sein. Innerhalb der gegebenen Grenzen sorgt das System dann selbstständig und ohne manuelle
                                        Eingriffe dafür, die vorhandene Kapazität bedarfsgerecht anzupassen.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-cloud.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Cloudangebote unterscheiden sich vom traditionallen Hosting insbesondere durch die automatische
                                        Skalierbarkeit und nutzungsabhängige Abrechnung aller Dienste. Die meisten Anbieter erlauben daher,
                                        Regeln zu definieren, bei welcher Auslastung weitere Kapazitäten hinzugefügt oder wieder entfernt
                                        werden sollen. Einrichtung, Start und Stopp der notwendigen Rechenknoten laufen hierfür komplett
                                        automatisiert.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md-2">
                                        <img src="02-architektur/transparenz-3dfilm.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Nicht nur in Forschung und Wissenschaft sondern auch in der Filmwirtschaft werden Clustersysteme
                                        zur Bewerkstelligung der anfallenden Rechenaufgaben eingesetzt. Diese besitzen einen Job Scheduler
                                        zum Einspiesen abzuarbeitender Aufgaben. Die zur Verfügung stehende Rechenleistung teilt der Scheduler
                                        automatisch auf alle aktiven Jobs auf. Sind zu einem Zeitpunkt nur wenige Jobs aktiv, laufen diese daher
                                        schneller durch, als wenn viele Jobs gleichzeitig laufen sollen.
                                    </lsx-col>
                                </lsx-row>
                                <div class="row">
                                    <div class="col">
                                        <small>
                                            <small>
                                                Bildnachweise:
                                                <a href="https://pixabay.com/photos/field-clouds-sky-agriculture-533541/" target="_blank">Pixabay: pcdazero</a>,
                                                <a href="https://pixabay.com/illustrations/super-woman-flying-3d-figure-female-1885016/" target="_blank">Pixabay: perianjs</a>
                                            </small>
                                        </small>
                                    </div>
                                </div>
                            </lsx-grid-fluid>
                        </lsx-accordion-page>
                    </lsx-accordion>
                </lsx-col>
            </lsx-row>
        </lsx-grid-fluid>
    </section>

    <section data-title="Skalierbarkeit">
        <!-- 1. Skalierungsarten, 2. Busbeispiel, 3. Render Farm -->
        <article class="centered-content">
            <div class="limited-width2">
                <div class="d-md-flex flex-wrap gap-3 align-items-center mb-5">
                    <img src="02-architektur/skalierung.png" class="d-block w-100" style="flex: 1;">
                    <div class="markdown" style="flex: 2;">
                        Ein typischer Anwendungsfall für verteilte Systeme ist die Skalierung einer Anwendung,
                        die auf einem einzelnen Rechner ausgeführt zu lange laufen würde. Zwar kann man den
                        Rechner zunächst versuchen, **vertikal zu skalieren**, indem man mehr Ressourcen hinzugefügt
                        (z.B. eine stärkere CPU), dies stößt aber schnell an seine Grenzen. Mit **horizontaler Skalierung**
                        können hingegen beliebig viele, weitere Rechnerknoten hinzugefügt werden, um die Leistung
                        unbegrenzt zu erhöhen.
                    </div>
                </div>

                <div class="centered-content flex-row flex-wrap gap-3">
                    <!-- Fallbeispiel: Omnibus -->
                    <lsx-modal>
                        <lsx-thumbnail style="height: 14em;" class="mw-100">
                            <img src="02-architektur/omnibus3.jpg" class="d-block h-100 mw-100 dhbw-thumbnail"/>
                        </lsx-thumbnail>
                        <lsx-content>
                            <lsx-card title="Fallbeispiel: Omnibus" bold class="mh-100 mw-100">
                                <lsx-card-body class="overflow-scroll">
                                    <lsx-ul class="lead">
                                        <li>In der realen Welt kennen wir Gelenkbusse und Doppeldeckerbusse.</li>
                                        <li>Doch mehr wie zwei Gelenke und zwei Decks sind praktisch nicht handhabbar.</li>
                                        <li>Dreistöckige Busse gibt es daher nur bei Harry Potter und KI-generierten Bildern.</li>
                                        <li>Mehrere Busse zu betreiben ist hoch vorteilhaft bei (un)geplanten Ausfällen wegen Wartung, Unfall, …</li>
                                    </lsx-ul>

                                    <div class="d-flex flex-wrap justify-content-center align-items-center gap-3">
                                        <img src="02-architektur/omnibus1.jpg" class="img-thumbnail d-block h-100" style="max-height: 40vh;"/>
                                        <img src="02-architektur/omnibus2.jpg" class="img-thumbnail d-block h-100" style="max-height: 40vh;"/>
                                        <img src="02-architektur/omnibus3.jpg" class="img-thumbnail d-block h-100" style="max-height: 40vh;"/>
                                    </div>
                                    <p>
                                        <small>
                                            <small>
                                                Bildnachweise:
                                                Bing Image Creator,
                                                Bing Image Creator,
                                                <a href="https://commons.wikimedia.org/wiki/File:2012-08-08_Doppelgelenkbus_Hamburger_Hochbahn.jpg" targegt="_blank">Wikipedia: Wo st 01</a>
                                            </small>
                                        </small>
                                    </p>
                                </lsx-card-body>
                            </lsx-card>
                        </lsx-content>
                    </lsx-modal>

                    <!-- Fallbeispiel: Render Farm -->
                    <lsx-modal>
                        <lsx-thumbnail style="height: 14em;" class="mw-100">
                            <img src="02-architektur/renderfarm1.jpg" class="d-block h-100 mw-100 dhbw-thumbnail"/>
                        </lsx-thumbnail>
                        <lsx-content>
                            <lsx-card title="Fallbeispiel: Render Farm" bold class="mh-100 mw-100">
                                <lsx-card-body class="overflow-scroll">
                                    <div class="lead">
                                        <p>
                                            Abendfüllende 3D-Animationsfilme zu rendern ist eine monumentale Aufgabe
                                        </p>
                                        <h5>Gedankenexperiment</h5>
                                        <lsx-ul class="mb-4">
                                            <li>25 Bilder/Sekunde ✕ 60 Sekunden ✕ 120 Minuten = 180.000 Einzelbilder</li>
                                            <li>Typische 8k-Auflösung im Kino: 8192 ✕ 4320 Pixel = 35.389.440 Pixel je Einzelbild</li>
                                            <li><a href="https://de.wikipedia.org/wiki/Raytracing" target="_blank">Raytracing</a> mit ca. 120 Rekursionen je Pixel: 4.246.732.800 tatsächlich zu berechnende Pixel</li>
                                            <li>Frage: Wie lange dauert es im Schnitt, einen typischen Film zu rendern?</li>
                                        </lsx-ul>
                                        <p>
                                            Bild rechts: Renderfarm bei Pixar im Jahr 1995. Auf einer solchen Render Farm wurde Toy Story gerechnet.
                                        </p>
                                    </div>
                                    <div class="d-flex flex-wrap justify-content-center align-items-center gap-3">
                                        <img src="02-architektur/renderfarm1.jpg" class="img-thumbnail d-block h-100" style="max-height: 30vh;"/>
                                        <img src="02-architektur/renderfarm2.jpg" class="img-thumbnail d-block h-100" style="max-height: 30vh;"/>
                                    </div>
                                    <p>
                                        <small>
                                            <small>
                                                Bildnachweise:
                                                <a href="http://nullisland.blot.im/pixar-render-farm-1995" target="_blank">nullisland.blot.im</a>,
                                                <a href="https://pixabay.com/photos/screw-thread-technology-mother-1924219/" target="_blank">Pixabay: PIRO4D</a>
                                            </small>
                                        </small>
                                    </p>
                                </lsx-card-body>
                            </lsx-card>
                        </lsx-content>
                    </lsx-modal>

                    <!-- Fallbeispiel: Supercomputer -->
                    <lsx-modal>
                        <lsx-thumbnail style="height: 14em;" class="mw-100">
                            <img src="02-architektur/supercomputer2.jpg" class="d-block h-100 mw-100 dhbw-thumbnail"/>
                        </lsx-thumbnail>
                        <lsx-content>
                            <lsx-card title="Fallbeispiel: Supercomputer" bold class="mh-100 mw-100">
                                <lsx-card-body class="overflow-scroll">
                                    <p class="lead" style="text-align: justify;">
                                        Hochleistungsrechner, wie sie in der Forschung und Wissenschaft oder von großen Internetkonzernen
                                        genutzt werden, bestehen aus einem reisigen Cluster kleiner Computer mit eigenem Hauptspeicher und
                                        in der Regel auch eigenem Massenspeicher. Die Einzelcomputer werden dabei in Storage Nodes zur
                                        Speicherung von Daten und in Compute Nodes zur Bereitstellung von Rechenleistung unterschieden.
                                    </p>
                                    </lsx-ul>
                                    <div class="d-flex flex-wrap justify-content-center align-items-center gap-3">
                                        <img src="02-architektur/supercomputer1.svg" class="img-thumbnail d-block h-100" style="max-height: 30vh;"/>
                                        <img src="02-architektur/supercomputer2.jpg" class="img-thumbnail d-block h-100" style="max-height: 30vh;"/>
                                    </div>
                                    <p>
                                        <small>
                                            <small>
                                                Bildnachweis (Foto):
                                                <a href="https://de.wikipedia.org/wiki/Blue_Gene#/media/File:IBM_Blue_Gene_P_supercomputer.jpg" target="_blank">Wikimedia Commons: Argonne National Laboratory</a>
                                            </small>
                                        </small>
                                    </p>
                                </lsx-card-body>
                            </lsx-card>
                        </lsx-content>
                    </lsx-modal>
                </div>
            </div>
        </article>
    </section>

    <section data-title="Resilienz">
        <article class="centered-content">
            <div class="limited-width">
                <div class="markdown mb-4">
                    Verteilte Systeme können darüber hinaus helfen, die Resilienz einer Anwendung zu erhöhen,
                    indem **Single Point of Failure** vermieden werden (durch horizontale Skalierung) und
                    Redundanzen geschaffen werden, so dass bei Ausfall eines Knotens, ein anderer Knoten
                    übernehmen kann (bspw. als **Hot-Standby**).
                </div>

                <lsx-info-box type="warning" class="mb-4">
                    Neben der Rechenleistung muss auch die Plattenkapazität redundant ausgelegt werden, um
                    Datenverluste zu vermeiden, wodurch wiederum das Problem anfällt, die Datenbestände
                    synchron zu halten.
                </lsx-info-box>

                <lsx-accordion>
                    <lsx-accordion-page title="Single Point of Failure" bold>
                        <img src="02-architektur/resilienz1.png" class="d-block w-100"/>
                    </lsx-accordion-page>
                    <lsx-accordion-page title="Vollständig redundante Architektur" bold>
                        <img src="02-architektur/resilienz2.png" class="d-block w-100"/>
                    </lsx-accordion-page>
                </lsx-accordion>
            </div>
        </article>
    </section>

    <section data-title="Beispiel: Cloud-Betrieb">
        <article>
            <lsx-grid-fluid class="p-0">
                <lsx-row>
                    <lsx-col size="md-9" class="mb-3">
                        <img src="02-architektur/cloud-betriebsmodell.png" class="d-block w-100" />
                    </lsx-col>
                    <lsx-col size="md" class="d-flex flex-column gap-3">
                        <lsx-card title="Automatisierung" bold class="small">
                            Die Grundidee der Cloud ist, die Bereitstellung und den Betrieb verteilter
                            Anwendungen so weit wie möglich zu automatisieren. Eine Cloudumgebung besteht
                            daher aus einem großen Rechencluster, dessen Ressourcen auf viele Anwendungen
                            aufgeteilt werden. Manuelle Installationsschritte sollen vermieden werden.
                        </lsx-card>

                        <lsx-card title="Skalierung und Elastizität" bold class="small">
                            Über eine Cloud-Umgebung bereitgestellte Anwendungen können, zumindest bei den größeren
                            Anbietern, vollkommen elastisch skaliert werden. Hierfür überwacht die Cloud-Plattform
                            regelmäßig vorab definierte Kennzahlen einer Anwendung und fährt bei Bedarf weitere
                            Service-Instanzen hoch oder runter.
                        </lsx-card>
                    </lsx-col>
                </lsx-row>
            </lsx-grid-fluid>
        </article>
    </section>
</section>

<section data-title="Umgang mit Fehlersituationen">
    <section data-title="Verfügbarkeit und Leistung">
        <article>
            <lsx-grid-fluid>
                <lsx-row>
                    <lsx-col size="lg-7">
                        <div style="height: 100%; display: flex; align-items: center;">
                            <div class="markdown">
                                #### Die acht Irrtümer verteilter Systeme

                                1. Das Netzwerk ist immer verfügbar.
                                1. Es gibt keine Latenzzeiten.
                                1. Der Datendurchsatz ist unendlich schnell.
                                1. Die Kommunikation ist automatisch sicher.
                                1. Die Netzwerktopologie ist unveränderlich.
                                1. Es gibt nur einen Administrator.
                                1. Datentransfer kostet nichts.
                                1. Das Netzwerk ist homogen.
                            </div>
                        </div>
                    </lsx-col>
                    <lsx-col size="lg">
                        <img src="02-architektur/dilbert-1997-01-28.gif" class="d-block w-100 mb-3" />
                        <img src="02-architektur/dilbert-1997-01-29.gif" class="d-block w-100 mb-3" />
                        <img src="02-architektur/dilbert-2018-03-22.gif" class="d-block w-100 mb-3" />

                        <small>
                            <small>
                                Bildnachweise:
                                <a href="https://dilbert.com/strip/1997-01-28" target="_blank">Dilbert vom 28.01.1997</a>,
                                <a href="https://dilbert.com/strip/1997-01-29" target="_blank">Dilbert vom 29.01.1997</a>,
                                <a href="https://dilbert.com/strip/2018-03-22" target="_blank">Dilbert vom 22.03.2018</a>
                            </small>
                        </small>
                    </lsx-col>
                </lsx-row>
            </lsx-grid-fluid>
        </article>
    </section>

    <section data-title="Strategien zur Fehlerbehandlung" class="centered-content">
        <lsx-grid-fluid class="limited-width2 p-0">
            <lsx-row>
                <lsx-col size="md-4" class="mb-3 mb-md-0">
                    <lsx-card bold img="02-architektur/fehler-vermeiden.jpg">
                        <h4>Fehler vermeiden</h4>
                        <p>
                            Zum Beispiel durch Eingabehilfen oder einen sauberen Programmierstil
                        </p>
                    </lsx-card>
                </lsx-col>
                <lsx-col size="md-4" class="mb-3 mb-md-0">
                    <lsx-card bold img="02-architektur/fehler-erkennen.jpg">
                        <h4>Fehler erkennen</h4>
                        <p>
                            Zum Beispiel durch Checksummen, Plausiprüfungen oder Monitoring
                        </p>
                    </lsx-card>
                </lsx-col>
                <lsx-col size="md">
                    <lsx-card bold img="02-architektur/fehler-maskieren.jpg">
                        <h4>Fehler maskieren</h4>
                        <p>
                            Zum Beispiel durch spätere Wiederholung des Vorgangs
                        </p>
                    </lsx-card>
                </lsx-col>
            </lsx-row>
            <lsx-row>
                <lsx-col size="md-4" class="mb-3 mb-md-0">
                    <lsx-card bold img="02-architektur/fehler-tolerieren.jpg">
                        <h4>Fehler tolerieren</h4>
                        <p>
                            Zum Beispiel durch Speichern beider Versionen bei Schreibkonflikten
                        </p>
                    </lsx-card>
                </lsx-col>
                <lsx-col size="md-4" class="mb-3 mb-md-0">
                    <lsx-card bold img="02-architektur/fehler-beheben.jpg">
                        <h4>Fehler beheben</h4>
                        <p>
                            Zum Beispiel durch automatisches Umschalten auf ein Hot-Standby
                        </p>
                    </lsx-card>
                </lsx-col>
                <lsx-col size="md">
                    <!-- Leer -->
                </lsx-col>
            </lsx-row>
            <lsx-row>
                <lsx-col size="md">
                    <small>
                        <small>
                            Bildnachweise:
                            <a href="https://pixabay.com/en/rappelling-rope-safety-security-755400/" target="_blank">Pixabay: cegoh</a>,
                            <a href="https://pixabay.com/en/equipment-hospital-ecg-3089883/" target="_blank">Pixabay: hioahelsefag</a>,
                            <a href="https://pixabay.com/en/redirect-shield-tree-attention-2257746/" target="_blank">Pixabay: Digitalpfade</a>,
                            <a href="https://pixabay.com/en/home-single-family-home-on-the-head-2308799/" target="_blank">Pixabay: ulleo</a>,
                            <a href="https://pixabay.com/en/first-aid-frog-medic-nurse-funny-1732708/" target="_blank">Pixabay: Alexas_Fotos</a>
                        </small>
                    </small>
                </lsx-col>
            </lsx-row>
        </lsx-grid-fluid>
    </section>
    
    <section data-title="Das CAP-Theorem" class="centered-content">
        <div class="limited-width2">
            <div class="dhbw-text-columns mb-4" detail-content>
                Das CAP-Theorem nach Eric Brewer (2000) belegt, dass eine verteilte Anwendung immer nur zwei der
                folgenden Kriterien vollständig erfüllen kann. Zwar wird die dritte Bedingung nicht vollständig
                aufgegeben, muss aber zumindest in Teilen aufgeweicht werden. Frühe Protokolle wie der
                Zwei-Phasen-Commit entsprechen beispielsweise einem Versuch, an verteilte Systeme dieselben
                ACID-Transaktionsbedingungen wie an nicht verteilte Systeme anzulegen. Dies ist möglich. Wie wir
                aber eben gesehen haben, geht dies nicht ohne Kompromisse bei der Partitionstoleranz.
            </div>

            <lsx-tab-pages>
                <lsx-tab-page title="Übersicht">
                    <lsx-grid-fluid>
                        <lsx-row>
                            <lsx-col size="md-5">
                                <img src="02-architektur/cap-theorem.png" alt="Visualisierung des CAP-Theorems" style="width: 100%;" />
                            </lsx-col>
                            <lsx-col size="md" class="d-flex flex-column justify-content-center gap-3">
                                <lsx-card title="Consistency (Konsistenz)" bold>
                                    Alle Knoten sehen immer exakt dieselben, konsistenten Daten. Bei replizierten Datenbeständen
                                    werden die Änderungen daher erst sichtbar, wenn sie in allen Repliken nachgezogen wurden.
                                </lsx-card>
            
                                <lsx-card title="Availability (Verfügbarkeit)" bold>
                                    Das System ist jederzeit erreichbar und überschreitet niemals die maximal zulässige
                                    Antwortzeit.
                                </lsx-card>
            
                                <lsx-card title="Partition Tolerance (Partitionstoleranz)" bold>
                                    Die Anwendung funktioniert auch dann noch, wenn einzelne Teile ausgefallen sind.
                                </lsx-card>
                            </lsx-col>
                        </lsx-row>
                    </lsx-grid-fluid>
                </lsx-tab-page>

                <lsx-tab-page title="Erklärung">
                    <div class="markdown dhbw-text-columns" detail-content>
                        In der praktischen Umsetzung lassen sich Fehler, die zu einer Partitionierung des Netzwerks bzw.
                        Nichterreichbarkeit einzelner Dienste, führen, oft nicht vermeiden. Dies triff vor allem bei
                        internet-basierten, verteilten Systemen zu. Häufig entscheidet man sich deshalb zu einer
                        aufgeweichten "quasi-konsistenz", bei der kurzzeitige Inkonsistenzen zu Gunsten einer erhöhten
                        Verfügbarkeit in Kauf genommen werden. Hierzu ein Beispiel und ein Gegenbeispiel:
            
                        * __Quasi-Konsistenz (Verfügbarkeit vor Konsistenz):__ In weltweit genutzten, sozialen Netzwerken
                        wie Youtube oder Facebook kann es sicher vorkommen, dass ein Like oder Kommentar nicht sofort für
                        alle Seitenbesucher*innen sichtbar wird, da dieser erst in die geografisch verteilten Datenbanken
                        repliziert werden muss. Nach einer kurzen Weile ist der Like oder Kommentar jedoch weltweit sichtbar.
            
                        * __Konsistenz vor Verfügbarkeit:__ Als Internetauktion auf eBay im Trend waren (und eBay noch
                        auf Privatverkäufe ausgelegt war), war es üblich, möglichst knapp vor Ende der Auktion zu bieten,
                        um anderen Mitbietern zuvor zu kommen. Die letzten Sekunden vor Auktionsschluss sind daher die
                        heißesten, in denen der meiste Traffic anfällt. Entsprechend länger ist die Wartezeit, bis ein
                        Gebot tatsächlich von der Plattform angenommen und bestätigt wird. Bei zu hoher Auslastung kann
                        es vorkommen, dass die Auktion aufgrund der Verzögerung zwischenzeitlich zu Ende gelaufen ist.
                        Das ist ärgerlich, aber der einzig richtige Weg, um ungewünschte Datenprobleme, wie zwei identische
                        von der Plattform bestätigte Höchstgebote, zu vermeiden.
                    </div>
                </lsx-tab-page>
            </lsx-tab-pages>
        </div>
    </section>
</section>

<section data-title="Verteilte Transaktionen">
    <section data-title="Klassische Transaktionsalgorithmen" class="centered-content">
        <div class="limited-width2">
            <lsx-tab-pages>
                <lsx-tab-page title="Problemstellung">
                    <lsx-grid-fluid class="p-0">
                        <lsx-row>
                            <lsx-col size="md-8">
                                <p>
                                    Von nicht-verteilten Systemen bzw. der klassischen Datenbankprogrammierung kennen wir die
                                    ACID-Kriterien für datenändernde Transaktionen:
                                </p>
                                <lsx-ul class="dhbw-list-spacious">
                                    <li>
                                        <b>Atomicity:</b> Eine Transaktion wird ganz oder gar nicht ausgeführt.
                                    </li>
                                    <li>
                                        <b>Consistency:</b> Vor und nach der Transaktion sind die Daten zu 100% konsistent.
                                    </li>
                                    <li>
                                        <b>Isolation:</b> Jede Transaktion läuft isoliert. Ihre Änderungen werden erst nachträglich sichtbar.
                                    </li>
                                    <li>
                                        <b>Durability:</b>Einmal bestätigte Änderungen bleiben ohne manuelles Zutun dauerhaft erhalten.
                                    </li>
                                </lsx-ul>
                                <p>
                                    Grundsätzlich gibt es keinen Grund, warum dies nicht auch für verteilte Transaktionen, bei denen
                                    zusammengehörige Daten auf unterschiedlichen Rechnerknoten geändert werden, erwünscht sein sollte.
                                    Die Frage ist nur:
                                </p>
                                <lsx-info-box>
                                    Lassen sich ACID-Transaktionen in verteilten Systemen überhaupt realisieren?
                                </lsx-info-box>
                            </lsx-col>

                            <lsx-col size="md">
                                <img src="02-architektur/acid-transaction.jpg" alt="" class="img-thumbnail d-block w-100">
                                <p class="fs-6">
                                    ACID-Transaktionen auf <a href="https://de.wikipedia.org/wiki/Klingonische_Sprache" target="_blank">klingonisch</a>.
                                    Abstrakte Konzepte und Schriftzeichen funktionieren mit KI-Bildgeneratoren aktuell noch nicht gut.
                                </p>
                            </lsx-col>
                        </lsx-row>
                    </lsx-grid-fluid>
                </lsx-tab-page>

                <lsx-tab-page title="Zwei-Phasen-Commit">
                    <div class="markdown dhbw-text-columns mb-4" detail-content>
                        Das Zwei-Phasen-Commit-Protokoll ist ein früher Versuch, die ACID-Kriterien auf verteilte
                        Transaktionen anzulegen. Die Transaktionen werden hierfür durch einen zusätzlichen Knoten,
                        der „Koordinator” genannt wird, gesteuert. Er steuert den gesamten Ablauf, sorgt darfür,
                        dass alle beteiligten Ressourcen exklusiv gesperrt werden (sog. pessimistisches Verhalten)
                        und trfft die finale Entscheidung über den Status der Transaktion. Die finale Entscheidung
                        über Bestätigung oder Ablehnung wird dabei in zwei Phasen getroffen:

                        <lsx-ul>
                            <li><b>Phase 1:</b> Vote (Abstimmung)</li>
                            <li><b>Phase 2:</b> Commit (Bestätigung)</li>
                        </lsx-ul>
                    </div>

                    <img src="02-architektur/2-phase-commit-ablauf.png" class="img-thumbnail d-block mw-100 m-auto" style="width: 30em;"/>

                    <p>
                        <small>
                            <small>
                                Bildnachweise: Bing Image Creator und
                                <a href="https://pixabay.com/vectors/crown-golden-royal-shining-shiny-312734/" target="_blank">Pixabay: Clker-Free-Vector-Images</a>
                            </small>
                        </small>
                    </p>
                </lsx-tab-page>

                <lsx-tab-page title="Mögliche Probleme">
                    <div class="markdown dhbw-text-columns mb-4" detail-content>
                        Der Zwei-Phasen-Commit soll die ACID-Kriterien für verteilte Transaktionen sicherstellen.
                        Jedoch lässt sich dies mit diesem Protokoll nicht 100%ig erzielen, da insbesondere der
                        Ausfall einer der beteiligten Knoten zu inkonsistenten Ständen führt, die oft nur durch
                        manuelles Eingreifen behebbar sind.

                        Schauen wir uns zum Verständis eine Transaktion mit dem Zwei-Phasen-Commit-Protokoll
                        aus der realen Welt an und überlegen, was bei Ausfall einer der Beteiligten passieren kann.
                    </div>

                    <lsx-grid-fluid class="p-0">
                        <lsx-row>
                            <lsx-col size="md">
                                <img src="02-architektur/2-phase-commit-1.jpg" class="img-thumbnail d-block w-100 mb-2"/>
                                <lsx-info-box>
                                    Der Standesbeamte fällt vorzeitig aus
                                </lsx-info-box>
                            </lsx-col>

                            <lsx-col size="md">
                                <img src="02-architektur/2-phase-commit-2.jpg" class="img-thumbnail d-block w-100 mb-2"/>
                                <lsx-info-box>
                                    Die Braut wird in letzter Sekunde ohnmächtig
                                </lsx-info-box>
                            </lsx-col>
                        </lsx-row>
                    </lsx-grid-fluid>

                    <div class="markdown dhbw-text-columns mb-4" detail-content>
                        Im ersten Fall hängt die Transaktion, und das Paar ist verheiratet aber auch nicht verheiretet.
                        Da der „Koodinator“, wie man den Standesbeamten beim Zwei-Phasen-Commit nennen würde, ausgefallen
                        ist, bleibt die Transaktion bis auf unbestimmte Zeit hängen. Im zweiten Fall kann der Koordinator
                        immerhin einen Timeout feststellen und die Zeremonie zu einem späteren Zeitpunkt wiederholen.
                    </div>
                </lsx-tab-page>
            </lsx-tab-pages>
        </div>
    </section>

    <section data-title="Fallbeispiel: Coffee Shop" class="centered-content">
        <div class="limited-width markdown" detail-content>
            Dieser Artikel beschreibt für verteilte Systeme wichtige Begriffe wie Synchronizität, Interaktionsmuster (engl. „Conversation Pattern“),
            oder Transaktionsverhalten. Als anschauliches Beispiel wird eine typische Bestellung in einem Coffe Shop betrachtet. Alternative Beispiele
            des Alltags, auf die sich die Beobachtungen übertragen lassen und die inzwischen sogar weitgehend digital ablaufen, sind die Abläufe in
            einem Fast-Food-Restaurant oder eine Bestellung in einem Onlineshop.
        </div>
        <div>
            <a href="https://ieeexplore.ieee.org/document/1407829" target="_blank">IEEE Software, Volume: 22, Issue: 2, Pages 64–66</a>
            <div class="d-flex gap-3">
                <img src="02-architektur/coffeeshop1.png" class="img-thumbnail d-block w-100"/>
                <img src="02-architektur/coffeeshop2.png" class="img-thumbnail d-block w-100" />
                <img src="02-architektur/coffeeshop3.png" class="img-thumbnail d-block w-100" />
            </div>
        </div>
    </section>

    <section data-title="Grundregel verteilter Systeme" class="centered-content">
        <div class="limited-width2">
            <lsx-grid-fluid class="p-0">
                <lsx-row>
                    <lsx-col size="md">
                        <img src="02-architektur/grundregel1.jpg" class="img-thumbnail d-block w-100" alt="First rule of distributed systems: Don't do it!">
                    </lsx-col>
                    <lsx-col size="md">
                        <img src="02-architektur/grundregel2.jpg" class="img-thumbnail d-block w-100">
                    </lsx-col>
                </lsx-row>
            </lsx-grid-fluid>
            <p>
                <small>
                    <small>
                        Bildnachweise: OpenAI DALL-E, Prompt: First rule of distributed systems: Don't do it
                    </small>
                </small>
            </p>

            <p>
                Warum diese merkwürdig anmutende Regel? Weil Verteilte Systeme nicht die Lösung für alle Probleme sind
                („mit dem Hammer in der Hand …”), jedoch ihre ganz eigenen Probleme mitbringen, die nicht immer leicht
                zu lösen sind.
            </p>

            <lsx-ul emoji="⁉️">
                <li>Aufteilung der Anwendungslogik in unabhängige Teilkomponenten</li>
                <li>Definition passender Schnittstellen zwischen den Komponenten</li>
                <li>Zuverlässiger Datenaustausch über ein unzuverlässiges Netzwerk</li>
                <li>Sicherstellen der Datenkonsistenz in verteilten Transaktionen</li>
                <li>Partitionierung, Replikation und Verfügbarkeit von Daten</li>
                <li>Koordination vieler verschiedener Knoten (wer ist der Chef?)</li>
                <li>Und viele mehr</li>
            </lsx-ul>

            <p>Natürlich gibt es dennoch viele sinnvolle Einsatzgebiete. Sonst würde es diese Vorlesung ja gar nicht geben. 😵‍💫</p>
        </div>
    </section>
</section>

<section data-title="Übungsaufgaben" data-background-color="rgb(231, 221, 141)">
    <section data-title="Aufgabe 1: Ein kleines Verteilte-Systeme-Quiz">
        <article>
            <lsx-tab-pages>
                <lsx-tab-page title="Aufgabe 1.1">
                    <lsx-quiz>
                        <lsx-exercise title="Definition verteilter Systeme">
                            <lsx-question
                                type = "gap-text"
                                text = "a) Vervollständigen Sie die folgende Definition verteilter Systeme nach Andrew Tanenbaum."
                            >
                                <lsx-hint>
                                    <div class="mb-4">
                                        <p>
                                            Folgende Begriffe stehen Ihnen zur Verfügung. Achten Sie auf die richtige Schreibweise:
                                        </p>
                                        <div class="d-flex flex-wrap gap-3 fw-bold">
                                            <span>System</span>
                                            <span>Computer</span>
                                            <span>Hardware</span>
                                            <span>Software</span>
                                            <span>Nachrichten</span>
                                            <span>Austausch</span>
                                            <span>Methoden</span>
                                            <span>unabhängiger</span>
                                            <span>kommunzieren</span>
                                            <span>verteiltes</span>
                                            <span>Komponenten</span>
                                            <span>unabhängigen</span>
                                            <span>gemeinsame</span>
                                            <span>Anwendung</span>
                                            <span>Aufgaben</span>
                                        </div>
                                    </div>
                                </lsx-hint>
                                <lsx-question-line>
                                    Ein <lsx-gap answer="verteiltes"></lsx-gap> System ist ein <lsx-gap answer="System"></lsx-gap>, in dem sich
                                    <lsx-gap answer="Hardware"></lsx-gap>- und Sofware-<lsx-gap answer="Komponenten"></lsx-gap> auf mehreren,
                                    voneinenader <lsx-gap answer="unabhängigen"></lsx-gap> Computern befinden können,
                                    und nur über den Austausch von <lsx-gap answer="Nachrichten"></lsx-gap> kommunizieren,
                                    um eine gemeinsame  Aufgabe zu bearbeiten.

                                    Aus Anwendersicht verhalten Sie sich wie ein einzelner, großer <lsx-gap answer="Computer"></lsx-gap>.
                                </lsx-question-line>
                            </lsx-question>

                            <lsx-question
                                    type = "single-choice"
                                    text = "b) Nur eine der folgenden Aussagen ist richtig. Welche?"
                                >
                                    <lsx-answer>
                                        Heutige Multicore-Computer sind eigentlich immer verteilte Systeme.
                                    </lsx-answer>
                                    <lsx-answer correct>
                                        Wesentlicher Anwendungsfall für verteilte Systeme ist die Parallelisierung komplexer Aufgaben.
                                    </lsx-answer>
                                    <lsx-answer>
                                        Verteilte Anwendungen bestehen aus mindestens einem Programm auf einem Computer.
                                    </lsx-answer>
                                </lsx-question>

                                <lsx-question
                                    type = "multiple-choice"
                                    text = "c) Welche der folgenden Beispiele sind verteilte Anwendungen im Sinne dieser Vorlesung?"
                                >
                                    <lsx-answer correct>
                                        Typische Supercomputer mit vielen Rechen- und Speicherknoten.
                                    </lsx-answer>
                                    <lsx-answer correct>
                                        Eine Webseite, deren Inhalte über einen Webserver abgerufen werden.
                                    </lsx-answer>
                                    <lsx-answer>
                                        Nebenläufige Programme mit mehreren Threads und ggf. sogar Prozessen.
                                    </lsx-answer>
                                    <lsx-answer correct>
                                        Computerspiele, bei denen mehrere Spieler über das Internet gegeneinander antreten können.
                                    </lsx-answer>
                                </lsx-question>

                                <lsx-question
                                    type = "single-choice"
                                    text = "d) Welches ist kein verteiltes System?"
                                >
                                    <lsx-hint>
                                        <div>
                                            <img src="02-architektur/quiz-ufo.jpg" class="img-thumbnail mw-100" style="height: 25em;">
                                            <img src="02-architektur/quiz-feuer.jpg" class="img-thumbnail mw-100" style="height: 25em;">
                                        </div>
                                        <p>
                                            <small>
                                                <small>
                                                    Bildnachweise:
                                                    <a href="https://pixabay.com/photos/ufo-abduction-fantasy-bicycle-1673929/" target="_blank">Pixabay: 51581</a>,
                                                    <a href="https://pixabay.com/photos/firemen-smoke-ladder-equipment-5242315/" target="_blank">Pixabay: Mathias_Groeneveld</a>
                                                </small>
                                            </small>
                                        </p>
                                    </lsx-hint>

                                    <lsx-answer>
                                        <a href="https://de.wikipedia.org/wiki/SETI@home" target="_blank">Seti@Home:</a>
                                        Viele Computer bieten ihre inaktive Rechenzeit einem virtuellen Cluster
                                        für verteiltes Rechnen an.
                                    </lsx-answer>
                                    <lsx-answer>
                                        Das Internet mit all seinen Routern, Gateways, Hosts, Clients, Servern usw.
                                    </lsx-answer>
                                    <lsx-answer correct>
                                        Cloud Computing: Durch einen Kurzschluss im Netzwerkkabel geht ein Computer in Rauch auf.
                                        Vor lauter Nebel ist aber nicht klar, welcher.
                                    </lsx-answer>
                                </lsx-question>
                        </lsx-exercise>
                    </lsx-quiz>
                </lsx-tab-page>

                <lsx-tab-page title="Aufgabe 1.2">
                    <lsx-quiz>
                        <lsx-exercise title="Internetkommunikation">
                            <lsx-question
                                type = "assignment"
                                text = "a) Ordnen Sie die folgenden Protokolle der richigen Sicht zu."
                            >
                                <lsx-assignment answer="Anwendungsschicht">HTTP</lsx-assignment>
                                <lsx-assignment answer="Vermittlungsschicht">IP</lsx-assignment>
                                <lsx-assignment answer="Transportschicht">TCP</lsx-assignment>
                                <lsx-assignment answer="Transportschicht">UDP</lsx-assignment>
                                <lsx-assignment answer="Netzwerkschicht">Ethernet</lsx-assignment>
                            </lsx-question>

                            <lsx-question
                                type = "single-choice"
                                text = "b) Auf welcher Schicht finden Routing und Paket Switching statt?"
                            >
                                <lsx-answer>Netzwerkschicht</lsx-answer>
                                <lsx-answer correct>Vermittlungsschicht</lsx-answer>
                                <lsx-answer>Transportschicht</lsx-answer>
                                <lsx-answer>Anwendungsschicht</lsx-answer>
                            </lsx-question>

                            <lsx-question
                                type = "single-choice"
                                text = "c) Welches Protokoll stellt eine zuverlässige Datenübertragung sicher?"
                            >
                                <lsx-question-line>
                                    <lsx-answer>UDP</lsx-answer>
                                    <lsx-answer correct>TCP</lsx-answer>
                                </lsx-question-line>
                            </lsx-question>

                            <lsx-question
                                type = "single-choice"
                                text = "d) Bei horizontaler Skalierung können mehrere Server auf demselben Rechner am selben Port lauschen."
                            >
                                <lsx-question-line>
                                    <lsx-answer>Wahr</lsx-answer>
                                    <lsx-answer correct>Falsch</lsx-answer>
                                </lsx-question-line>
                            </lsx-question>

                            <lsx-question
                                type = "single-choice"
                                text = "e) Welches ist die maximale Portnummer bei TCP?"
                            >
                                <lsx-question-line>
                                    <lsx-answer>255</lsx-answer>
                                    <lsx-answer>1023</lsx-answer>
                                    <lsx-answer>32764</lsx-answer>
                                    <lsx-answer>65535</lsx-answer>
                                    <lsx-answer>4294967295</lsx-answer>
                                </lsx-question-line>
                            </lsx-question>

                            <lsx-question
                                type = "single-choice"
                                text = "f) Ein Programm, das auf einem TCP-Port lauscht, kann nur mit Admin-Rechten gestartet werden."
                            >
                                <lsx-question-line>
                                    <lsx-answer>Wahr</lsx-answer>
                                    <lsx-answer correct>Falsch</lsx-answer>
                                </lsx-question-line>
                            </lsx-question>
                        </lsx-exercise>

                    </lsx-quiz>
                </lsx-tab-page>

                <lsx-tab-page title="Aufgabe 1.3">
                    <lsx-quiz>
                        <lsx-exercise title="Anforderungen an verteilte Systeme">
                            <lsx-question
                                type = "single-choice"
                                text = "a) Transparenz in der Wirtschaft bedeutet, dass alle Informationen frei zugänglich sind."
                            >
                                <lsx-question-line>
                                    <lsx-answer correct>Wahr</lsx-answer>
                                    <lsx-answer>Falsch</lsx-answer>
                                </lsx-question-line>
                            </lsx-question>

                            <lsx-question
                                type = "single-choice"
                                text = "b) In der Informatik arbeiten wir mit demselben Transparenzbegriff wie Politk und Wirtschaft."
                            >
                                <lsx-question-line>
                                    <lsx-answer>Wahr</lsx-answer>
                                    <lsx-answer correct>Falsch</lsx-answer>
                                </lsx-question-line>
                            </lsx-question>

                            <lsx-question
                                type            = "assignment"
                                text            = "c) Ordnen Sie die nachfolgenden Anforderungen die richtigen Namen zu."
                                label-length    = "100%"
                                select-position = "below"
                                select-style    = "background: rgb(228, 229, 230);"
                            >
                                <lsx-assignment answer="Horizontale Skalierung">
                                    Um die Leistung eines verteilten Systems zu steigern, werden einfach weitere Computer
                                    hinzugefügt. An den bereits vorhandenen Computern sowie den darauf laufenden Programmen
                                    müssen hierfür keine nennenswerten Änderungen vorgenommen werden.
                                </lsx-assignment>

                                <lsx-assignment answer="Zugriffstransparenz">
                                    Egal ob man als Anwender oder als Entwickler auf eine Ressource zugreift, es sollte
                                    keinen Unterschied machen, ob diese sich auf dem eigenen oder einem anderen Computer
                                    befindet. Der Zugriff erfolgt immer auf dieselbe Weise.
                                </lsx-assignment>

                                <lsx-assignment answer="Erweiterbarkeit">
                                    Sowohl die Systemarchitektur als auch die Softwarearchitektur sind flexibel genug,
                                    um jederzeit weitere Funktionen hinzufügen zu können, ohne gleich alles auseinander
                                    nehmen zu müssen. Denn nichts ist so beständig wie der Wandel.
                                </lsx-assignment>

                                <lsx-assignment answer="Fehler vermeiden">
                                    Beim Programmieren darf man auf keinen Fall am falschen Ende sparen. Lieber investiert
                                    man etwas mehr Arbeit und bietet dafür zum Beispiel eine komfortable, selbsterklärende
                                    Benutzeroberfläche oder achtet darauf, selbst die eher unwahrscheinlichen Ausnahmen
                                    sauber zu behandeln als einen Programmabsturz zu riskieren.
                                </lsx-assignment>

                                <lsx-assignment answer="CAP-Theorem">
                                    Wie schön wäre eine Welt, in der jede verteilte Anwendung stets mit konsistenten Daten arbeiten
                                    könnte, hochverfügbar wäre und selbst der Ausfall einzelner Komponenten keine wirkliche Störung
                                    wäre. Doch leider kann eine Anwendung maximal zwei dieser Kriterien vollständig erfüllen.
                                </lsx-assignment>

                                <lsx-assignment answer="Ortstransparenz">
                                    <i><a href="https://www.youtube.com/watch?v=MWF7HTOT8BU" target="_blank">Heute hier, morgen dort</a>,
                                    bin kaum da, muss ich fort. So vergeht Jahr um Jahr, und es ist mir längst klar, dass nichts bleibt
                                    wie es war.</i> Dieser Songtext von Hannes Wader beschreibt auch eine wichtige Anforderung an
                                    verteilte Anwendungen.
                                </lsx-assignment>

                                <lsx-assignment answer="Fehler maskieren">
                                    Geht mal was schief ist das oft eigentlich gar nicht so schlimm. Nicht jeder Fehler erfordert gleich
                                    die volle Aufmerksamkeit des Anwenders. Oft kann das System die fehlgeschlagene Aktion einfach nochmal
                                    versuchen oder sonst wie um das Problem herum arbeiten.
                                </lsx-assignment>

                                <lsx-assignment answer="Resilienz">
                                    Nicht alles auf eine Karte setzen, sondern möglichst alle Komponenten redundant und mit
                                    Failover-Systemen ausstatten. Fällt eine der beteiligten Komponenten aus, sollte das System
                                    mit reduzierter Leistung dennoch weiter laufen, bis die Störung beseitigt wurde.
                                </lsx-assignment>
                            </lsx-question>
                        </lsx-exercise>
                    </lsx-quiz>
                </lsx-tab-page>

                <lsx-tab-page title="Aufgabe 1.4">
                    <lsx-quiz>
                        <lsx-exercise title="Weitere Verständnisfragen">
                            <lsx-question
                                type         = "assignment"
                                text         = "a) Handelt es sich bei den folgenden Beispielen um synchrone oder asynchrone Kommunikation?"
                                label-length = "15em"
                                select-style = "background: rgb(228, 229, 230);"
                            >
                                <lsx-assignment answer="Synchrone Kommunikation">
                                    Telefongespräch
                                </lsx-assignment>
                                <lsx-assignment answer="Asynchrone Kommunikation">
                                    Whatsapp-Gruppe
                                </lsx-assignment>
                                <lsx-assignment answer="Asynchrone Kommunikation">
                                    E-Mailnachricht
                                </lsx-assignment>
                                <lsx-assignment answer="Synchrone Kommunikation">
                                    Besuch einer Webseite
                                </lsx-assignment>
                                <lsx-assignment answer="Asynchrone Kommunikation">
                                    Wöchentliche Werbeprospekte
                                </lsx-assignment>
                                <lsx-assignment answer="Synchrone Kommunikation">
                                    Einkauf am Kaffeeautomaten
                                </lsx-assignment>
                            </lsx-question>

                            <lsx-question
                                type         = "assignment"
                                text         = "b) Welche der folgenden Aussagen treffen horizontale und vertikale Skalierung zu?"
                                label-length = "15em"
                                select-style = "background: rgb(228, 229, 230);"
                            >
                                <lsx-assignment answer="Hinzufügen weiterer Instanzen, auf welche sich die Arbeit verteilt">
                                    Horizontale Skalierung
                                </lsx-assignment>
                                <lsx-assignment answer="Den vorhandenen Instanzen mehr Leistung zur Verfügung stellen">
                                    Vertikale Skalierung
                                </lsx-assignment>
                            </lsx-question>

                            <lsx-question
                                type = "single-choice"
                                text = "c) Welches ist ein Protokoll für verteilte Transaktionen?"
                            >
                                <lsx-question-line>
                                    <lsx-answer>Doppel-Commit</lsx-answer>
                                    <lsx-answer correct>Zwei-Phasen-Commit</lsx-answer>
                                    <lsx-answer>Zwei-Phasen-Rollback</lsx-answer>
                                    <lsx-answer>Drei-Phasen-Drehstrom</lsx-answer>
                                </lsx-question-line>
                            </lsx-question>

                            <lsx-question
                                type = "single-choice"
                                text = "d) Was passiert, wenn beim zuvor gefragten Protokoll der Koordinatior ausfällt?"
                            >
                                <lsx-answer correct>Die Transaktion hängt und muss manuell zurückgesetzt werden.</lsx-answer>
                                <lsx-answer>Das System schließt die Transaktion nach Ablauf des Timeouts trotzdem ab.</lsx-answer>
                                <lsx-answer>Das System erkennt die Situation und rollt die Transaktion zurück.</lsx-answer>
                            </lsx-question>

                            <lsx-question
                                type = "free-text"
                                text = "e) Banküberweisungen sind das klassische Beispiel für ACID-Transaktionen. Aber sind sie wirklich atomar und isoliert? Recherchieren Sie den Begriffe Valuta bzw. Wertstellung und ziehen Sie diesen für Ihre Begründung heran."
                            >
                                <lsx-free-text editor="text">
                                    <lsx-initial-answer>
                                        Hier bitte Ihre Antwort eingeben.
                                    </lsx-initial-answer>
                                    <lsx-sample-answer>
                                        <p>
                                            Die Valuta bzw. Wertstellung (beide Begriffe bedeuten dasselbe) ist das Datum, an dem eine
                                            Kontobewegung wirksam wird. Dem steht das Buchungsdatum entgegen, wann die Kontobewegung
                                            bei der Bank registriert wurde. In vielen Fällen sind beide Daten identisch. Bei
                                            Auslandsüberweisungen, Bezahlung mit Kreditkarte usw. können sie aber voneinander abweichen,
                                            wobei die Valuta immer nach dem Buchungsdatum liegt.
                                        </p>
                                        <p>
                                            Damit eine zeitverzögerte Buchung nicht wegen mangelnder Deckung des Kontos rückabgewickelt
                                            werden muss, reduzieren die Banken den Kontostand bereits bei Buchungseingang vorläufig,
                                            wobei in diesem Fall auch zwei Kontostände ausgewiesen werden.
                                        </p>
                                    </lsx-sample-answer>
                                </lsx-free-text>
                            </lsx-question>
                        </lsx-exercise>
                    </lsx-quiz>
                </lsx-tab-page>
            </lsx-tab-pages>
        </article>
        <aside>
            <p>
                Hier eine kleine Aufwärmübung zu den Grundlagen verteilter Systeme, bevor wir uns
                gleich auf die praktische Anwendung und die inhaltlichen Vertiefungen stürzen.
            </p>
            <img src="shared/quiz.png" class="img-fluid d-block" style="max-width: 20em;"/>
            <p>
                <small>
                    Bildnachweis:
                    <a href="https://pixabay.com/illustrations/quiz-tiles-letters-red-game-test-2058883/" target="_blank">Pixabay: 905513</a>
                </small>
            </p>
        </aside>
    </section>

    <section data-title="Aufgabe 2: Wir erkunden Streams und Sockets">
        <article>
            <div class="mb-4">
                <lsx-github-edit url="Beispiele/Socket-Sprachserver"></lsx-github-edit>
            </div>

            <div class="d-flex flex-column flex-md-row gap-3 mb-4">
                <img src="02-architektur/socket-server.png" class="img-thumbnail d-block w-100" alt="Serverprogramm">
                <img src="02-architektur/socket-client.png" class="img-thumbnail d-block w-100" alt="Clientprogramm">
            </div>

            <lsx-tab-pages>
                <lsx-tab-page title="a) Server starten">
                    <ol class="dhbw-list-spacious mb-4">
                        <li>
                            Laden Sie den Quellcode herunter und entpacken Sie ihn auf Ihrem Rechner.
                        </li>
                        <li>
                            Öffnen Sie das Verzeichnis <tt>Speach-Server</tt> in einem Terminal-Fenster.¹
                        </li>
                        <li>
                            Geben Sie den Befehl <code>npm install</code> ein, um die benötigten Node.js-Pakete
                            zu installieren.
                        </li>
                        <li>
                            Starten Sie den Server durch Eingabe des Befehls <code>npm start</code>.
                        </li>
                        <li>
                            Lassen Sie den Server für die folgenden Aufgaben im Hintergrund weiter laufen.²
                        </li>
                    </ol>

                    <div>
                        ¹
                        <small>
                            Unter Windows können Sie hierfür das Verzeichnis im Explorer öffnen und den Befehl
                            <src-code>CMD</src-code> in die Adresszeile eingeben.
                        </small>
                    </div>
                    <div>
                        ²
                        <small>
                            Später können Sie den Server durch Eingabe von <kbd>Strg</kbd>+<kbd>C</kbd> beenden.
                        </small>
                    </div>
                </lsx-tab-page>

                <lsx-tab-page title="b) Client starten">
                    <ol class="dhbw-list-spacious">
                        <li>
                            Öffnen Sie das Verzeichnis <tt>Speach-Client</tt> in einem weiteren Terminal-Fenster.
                        </li>
                        <li>
                            Geben Sie den Befehl <code>npm install</code> ein, um die benötigten Node.js-Pakete
                            zu installieren.
                        </li>
                        <li>
                            Starten Sie den Client durch Eingabe des Befehls <code>npm start</code>.
                        </li>
                        <li>
                            Lassen Sie den Server ein paar sehr lange Sätze sprechen.
                        </li>
                        <li>
                            Fragen Sie mit dem Client die Warteschlange der noch zu sprechende Sätze ab.
                        </li>
                        <li>
                            Trennen Sie die Verbindung zum Server.
                        </li>
                    </ol>
                </lsx-tab-page>

                <lsx-tab-page title="c) Direkte Socketverbindung">
                    <p>
                        Für diesen Teil benötigten Sie ein Programm wie <a href="https://nmap.org/ncat/" target="_blank">Netcat</a>,
                        mit dem eine direkte Socketverbindung zu einem entfernten Server hergestellt werden kann. Auf der verlinkten
                        Seite können Sie eine portable EXE-Datei für Windows herunterladen. Unter Mac oder Linux ist es häufig unter
                        dem Namen <code>nc</code> oder <code>netcat</code> bereits vorinstalliert.
                    </p>

                    <img src="02-architektur/socket-netcat.png" class="img-thumbnail d-block mw-100 mb-4 m-auto" style="width: 50em;" alt="Netcat">

                    <ol class="dhbw-list-spacious mb-4">
                        <li>
                            Öffnen Sie ein Terminal-Fenster und geben den Befehl <code>nc localhost 7000</code> ein.¹
                        </li>
                        <li>
                            Geben Sie die Zeichenfolge <code>HELLO</code> ein und drücken anschließend <kbd>Enter</kbd>.
                        </li>
                        <li>
                            Geben Sie <code>SAY: Hello, Server. Are you listening?</code> ein und drücken <kbd>Enter</kbd>.
                        </li>
                        <li>
                            Verabschieden Sie sich mit <code>BYE</code> und trennen die Verbindung mit
                            <kbd>Strg</kbd>+<kbd>C</kbd>.
                        </li>
                    </ol>
                </lsx-col>

                <p>
                    Wenn alles klappt, sollte der erste Befehl eine Socketverbindung zum Server herstellen.
                    Ihre Eingaben werden unverändert an den Server übertragen, der diese auswertet und mit einer
                    eigenen Zeichenfolge antwortet. Diese wird ihnen unmittelbar nach Ihrer eigenen Einage im
                    Konsolenfenster angezeigt. Der obige Screenshot zeigt eine Beispiel-Session, bei der die
                    Ein- und Ausgaben zur Unterscheidung nachträglich eingefärbt wurden.
                </p>

                <div>
                    ¹
                    <small>
                        Wenn dies nicht funktioniert, versuchen Sie <code>netcat</code> anstelle von <code>nc</code>,
                        Alternativ können Sie behelfsweise auch <code>telnet</code> verwenden, das unter Windows aber
                        ebenfalls nachinstalliert werden muss.
                    </small>
                </div>
                </lsx-tab-page>
            </lsx-tab-pages>
        </article>
        <aside>
            <p>
                In Zusammenhang mit dem TCP/IP-Protokollstapel wurde ein kleiner Sprachserver als Beispiel
                vorgestellt. In dieser Aufgabe sollen Sie versuchen, diesen auf Ihrem Computer zum Laufen
                zu bringen und sich mit der ebenfalls vorgestellten Clientanwendung damit zu verbinden.
            </p>
            <img src="shared/github_atom.png" class="img-fluid d-block"/>
            <p>
                <small>
                    Bildnachweis:
                    <a href="https://atom.io/" target="_blank">Atom Webseite</a>
                </small>
            </p>
        </aside>
    </section>

    <section data-title="Aufgabe 3: Ein kleines Architekturmuster-Quiz">
        <article>
            <lsx-tab-pages>
                <lsx-tab-page title="Aufgabe 3.1">
                    <lsx-quiz>
                        <lsx-exercise title="Clients, Server und Peers">
                            <lsx-question
                                type = "single-choice"
                                text = "a) Welche der folgenden Definitionen beschreibt einen Server?"
                            >
                                <lsx-answer>
                                    Ein Programm, das einen Dienst anbietet und sich hierfür mit anderen,
                                    gleichartigen Programmen verbindet.
                                </lsx-answer>
                                <lsx-answer correct>
                                    Ein Programm, das einen Dienst anbietet und hierfür wartet, bis sich
                                    ein Nutzer mit ihm verbindet.
                                </lsx-answer>
                                <lsx-answer>
                                    Ein Programm, das temporär gestartet wird, um einen Dienst zu nutzen.
                                </lsx-answer>
                            </lsx-question>

                            <lsx-question
                                type = "single-choice"
                                text = "b) TCP/IP-Verbindungen werden immer vom Server initiiert, der sich hierfür mit dem Client verbindet."
                            >
                                <lsx-question-line>
                                    <lsx-answer>Wahr</lsx-answer>
                                    <lsx-answer correct>Falsch</lsx-answer>
                                </lsx-question-line>
                            </lsx-question>

                            <lsx-question
                                type = "multiple-choice"
                                text = "c) Welche der folgenden Aussagen sind korrekt?"
                            >
                                <lsx-answer correct>
                                    Die Peers in einem Peer-to-Peer-Netzwerk sind sowohl Client als auch Server.
                                </lsx-answer>
                                <lsx-answer>
                                    Peer-to-Peer-Netzwerke besitzen einen zentralen Master-Server für die gesamte Kommunikation.
                                </lsx-answer>
                                <lsx-answer correct>
                                    Jeder Peer verbindet sich als Client mit anderen anderen Peers, die gleichzeitig als Server fungieren.
                                </lsx-answer>
                            </lsx-question>
                        </lsx-exercise>
                    </lsx-quiz>
                </lsx-tab-page>

                <lsx-tab-page title="Aufgabe 3.2">
                    <lsx-quiz>
                        <lsx-exercise title="Proxyserver">
                            <lsx-question
                                type = "single-choice"
                                text = "a) Welche der folgenden Definitionen entspricht der eines Proxyservers?"
                            >
                                <lsx-answer>
                                    Ein Proxyserver verbindet sich mit vielen anderen Proxyservern zu einem virtuellen Gesamtsystem.
                                </lsx-answer>
                                <lsx-answer>
                                    Ein Proxyserver dient der Zusammenführung mehrerer Microservices in einer Weboberfläche.
                                </lsx-answer>
                                <lsx-answer correct>
                                    Ein Proxyserver kopiert die Schnittstelle eines anderen Servers und vertritt diesen gegenüber seinen Clients.
                                </lsx-answer>
                            </lsx-question>

                            <lsx-question
                                type = "single-choice"
                                text = "b) Welche der folgenden Aufgaben gehören nicht zu denen eines Proxyservers?"
                            >
                                <lsx-answer>
                                    Chachen häufig angefragter Inhalte
                                </lsx-answer>
                                <lsx-answer correct>
                                    Vereinheitlichung unterschiedlicher Serverprotokolle
                                </lsx-answer>
                                <lsx-answer>
                                    Content Filter, Upload Filter, Paywalls
                                </lsx-answer>
                                <lsx-answer>
                                    Lastverteilung über mehrere Serverinstanzen
                                </lsx-answer>
                                <lsx-answer>
                                    Sicherstellen einer zentralen Authentifizierung
                                </lsx-answer>
                            </lsx-question>
                        </lsx-exercise>
                    </lsx-quiz>
                </lsx-tab-page>

                <lsx-tab-page title="Aufgabe 3.3">
                    <lsx-quiz>
                        <lsx-exercise title="Dreischichtenarchitektur">
                            <lsx-question
                                type = "multiple-choice"
                                text = "a) Welche der folgenden Schichten gehören zur Dreischichtenarchitektur?"
                            >
                                <lsx-answer correct>
                                    Datenhaltungsschicht
                                </lsx-answer>
                                <lsx-answer>
                                    Präsentationsschicht
                                </lsx-answer>
                                <lsx-answer correct>
                                    Darstellungsschicht
                                </lsx-answer>
                                <lsx-answer>
                                    Clientschicht
                                </lsx-answer>
                                <lsx-answer>
                                    Spätschicht
                                </lsx-answer>
                                <lsx-answer correct>
                                    Anwendungsschicht
                                </lsx-answer>
                            </lsx-question>

                            <lsx-question
                                type = "multiple-choice"
                                text = "b) Welche der folgenden Schichten gehören zur Vierschichtenarchitektur?"
                            >
                                <lsx-answer>
                                    Mittelschicht
                                </lsx-answer>
                                <lsx-answer correct>
                                    Anwendungsschicht
                                </lsx-answer>
                                <lsx-answer correct>
                                    Präsentationsschicht
                                </lsx-answer>
                                <lsx-answer>
                                    Peer-To-Peer-Schicht
                                </lsx-answer>
                                <lsx-answer correct>
                                    Darstellungsschicht
                                </lsx-answer>
                                <lsx-answer correct>
                                    Datenhaltungsschicht
                                </lsx-answer>
                            </lsx-question>
                        </lsx-exercise>
                    </lsx-quiz>
                </lsx-tab-page>

                <lsx-tab-page title="Aufgabe 3.4">
                    <lsx-quiz>
                        <lsx-exercise title="Microservices">
                            <lsx-question
                                type = "single-choice"
                                text = "a) Jeder Microservice entspricht einer Dreischichtenarchitektur?"
                            >
                                <lsx-question-line>
                                    <lsx-answer>Wahr</lsx-answer>
                                    <lsx-answer correct>Falsch</lsx-answer>
                                </lsx-question-line>
                            </lsx-question>

                            <lsx-question
                                type = "single-choice"
                                text = "b) Microservices lohnen sich laut <a href='https://martinfowler.com/articles/microservices.html' target='_blank'>Martin Fowler</a> eher für …"
                            >
                                <lsx-answer correct>
                                    Große Anwendungen in großen Unternehmen mit vielen Entwicklern
                                </lsx-answer>
                                <lsx-answer>
                                    Große Anwendungen in kleinen Unternehmen mit wenigen Entwicklern
                                </lsx-answer>
                                <lsx-answer>
                                    Kleine Anwendungen in großen Unternehmen mit wenigen Entwicklern
                                </lsx-answer>
                            </lsx-question>

                            <lsx-question
                                type = "multiple-choice"
                                text = "c) Welche der folgenden Techniken kommen als Schnittstelle für Microservices in Frage?"
                            >
                                <lsx-answer correct>
                                    Entfernte Prozedur-/Methodenaufrufe
                                </lsx-answer>
                                <lsx-answer correct>
                                    Webservices
                                </lsx-answer>
                                <lsx-answer>
                                    Weboberflächen im Browser
                                </lsx-answer>
                                <lsx-answer correct>
                                    Message Broker
                                </lsx-answer>
                                <lsx-answer>
                                    Mobile Apps
                                </lsx-answer>
                            </lsx-question>

                            <lsx-question
                                type = "single-choice"
                                text = "d) Die Microservices einer großen Anwendung besitzen alle dieselbe Versionsnummer"
                            >
                                <lsx-question-line>
                                    <lsx-answer>Wahr</lsx-answer>
                                    <lsx-answer correct>Falsch</lsx-answer>
                                </lsx-question-line>
                            </lsx-question>

                            <lsx-question
                                type = "single-choice"
                                text = "e) Die Microservices einer verteilten Anwendung können an unterschiedlichen Tagen deployed werden."
                            >
                                <lsx-question-line>
                                    <lsx-answer correct>Wahr</lsx-answer>
                                    <lsx-answer>Falsch</lsx-answer>
                                </lsx-question-line>
                            </lsx-question>
                        </lsx-exercise>
                    </lsx-quiz>
                </lsx-tab-page>
            </lsx-tab-pages>
        </article>
        <aside>
            <p>
                Hier haben wir kleines Quiz über die verschiedenen Architekturmuster. Wenn Sie diese
                Fragen richtig beantworten, kennen Sie sich mit verteilten Systemen doch schon ganz
                gut aus.
            </p>
            <img src="shared/quiz.png" class="img-fluid d-block" style="max-width: 20em;"/>
            <p>
                <small>
                    Bildnachweis:
                    <a href="https://pixabay.com/illustrations/quiz-tiles-letters-red-game-test-2058883/" target="_blank">Pixabay: 905513</a>
                </small>
            </p>
        </aside>
    </section>

    <section data-title="Aufgabe 4: Wer hat an der Uhr gedreht?">
        <article>
            <div class="markdown">
                Wichtige Anforderung an verteilte Systeme ist häufig, dass die **Kausalordnung** von Ereignissen
                erhalten bleibt, das heißt, dass die zeitliche Abfolge von Ursache und Wirkung nicht vertauscht
                wird. Doch auch ohne kausalen Zusammenhang müssen so genannte **Happened-Before**-Beziehungen
                erhalten bleiben. In beiden Fällen läuft es auf einen Vergleich von Zeitstempeln hinaus, wofür
                entweder eine **Echtzeituhr** oder eine **logische Uhr** verwendet werden kann.
            </div>

            <lsx-tab-pages>
                <lsx-tab-page title="Aufgabenstellung" class="markdown">
                    #### a) Begriffsdefinitionen {.mt-4 .dhbw-lightblue}

                    Recherchieren Sie folgende Begriffe und formulieren Sie eine dazu passende Definition:

                    * Kausalordnung
                    * Happened-Before-Relation
                    * Nebenläufigkeit
                    * Echtzeituhr
                    * Lamport-Uhr

                    #### b) Fallbeispiel {.mt-4 .dhbw-lightblue}

                    Zeigen Sie anhand eines minimalen Beispiels, wie die zeitliche Abfolge mehrerer Ereignisse anhand
                    einer logischen Uhr sichergestellt werden kann.

                    #### c) Nebenläufigkeit {.mt-4 .dhbw-lightblue}

                    Erklären Sie, warum eine einfache Lamport-Uhr keine nebenläufigen Prozesse abbilden kann und zeigen Sie,
                    wie eine Vektoruhr dies ermöglicht.
                </lsx-tab-page>

                <lsx-tab-page title="Hinweis zur Zeitrechnung">
                    <p>
                        Egal, welche Art von Uhr zum Einsatz kommt, alle Beteiligten müssen sich über die
                        zugrunde liegenden Konventionen einig sein. Dass diese mitunter nicht immer eindeutig
                        sind (wird ein Unix-Zeitstempel in Sekunden oder in Millisekunden gezählt?) zeigt
                        folgende, nicht ganz ernste Aufzählung. 😉
                    </p>

                    <h4>Beginn der Zeitrechnung</h4>

                    <lsx-grid-fluid class="p-0">
                        <lsx-row>
                            <lsx-col size="md">
                                <img src="02-architektur/zeitproblem-beginn-wissenschaft.jpg" class="d-block img-fluid img-thumbnail" />
                                <b>Wissenschaft:</b> Mit dem Urknall
                            </lsx-col>
                            <lsx-col size="md">
                                <img src="02-architektur/zeitproblem-beginn-kirche.jpg" class="d-block img-fluid img-thumbnail" />
                                <b>Kirche:</b> Als Gott die Erde erschuf
                            </lsx-col>
                        </lsx-row>
                        <lsx-row>
                            <lsx-col size="md">
                                <img src="02-architektur/zeitproblem-beginn-sport.jpg" class="d-block img-fluid img-thumbnail" />
                                <b>Wettläufer:</b> Ab dem Startschuss
                            </lsx-col>
                            <lsx-col size="md">
                                <img src="02-architektur/zeitproblem-beginn-entwickler.jpg" class="d-block img-fluid img-thumbnail" />
                                <b>Softwareentwickler:</b> <a href="https://de.wikipedia.org/wiki/Unixzeit"
                                    target="_blank">01.01.1970 0:00 Uhr</a>
                                <br />
                                <small>
                                    <b>Youtube:</b>
                                    <a href="https://www.youtube.com/watch?v=jNQXAC9IVRw" target="_blank">23.04.2005, irgendwann mittags</a>
                                </small>
                            </lsx-col>
                        </lsx-row>
                        <lsx-row>
                            <lsx-col size="md">
                                <p>
                                    <small>
                                        <small>
                                            Bildnachweise:
                                            <a href="https://pixabay.com/illustrations/universe-space-expansion-big-bang-11636/"
                                                target="_blank">Pixabay: WikiImages</a>,
                                            <a href="https://pixabay.com/photos/genesis-mosaic-iconography-2435989/"
                                                target="_blank">Pixabay: dimitrisvetsikas1969</a>,
                                            <a href="https://pixabay.com/photos/race-finish-line-athletes-695303/"
                                                target="_blank">Pixabay: skeeze</a>,
                                            <a href="https://commons.wikimedia.org/wiki/File:Vt100-adventure.jpg"
                                                target="_blank">Wikimedia: Shieldforyoureyes</a>
                                        </small>
                                    </small>
                                </p>
                            </lsx-col>
                        </lsx-row>
                    </lsx-grid-fluid>
                </lsx-tab-page>
            </lsx-tab-pages>

        </article>
        <aside>
            <p>
                Diese Aufgabe ist eine Vertiefungsaufgabe zum Thema „Zeitsynchronisation in verteilten Systemen”.
                Die Antworten müssen daher selbständig recherchiert werden, wobei die deutsche Wikipedia bereits
                sehr gute Artikel 📑 zu den einzelnen Begriffen enthält.
            </p>
            <img src="shared/pocket-watch.svg" class="d-block" style="max-width: 20em;" />
            <p>
                <small>
                    Bildnachweis:
                    <a href="https://pixabay.com/vectors/pocket-watch-fob-watch-147107/" target="_blank">Pixabay: OpenClipart-Vectors</a>
                </small>
            </p>
        </aside>
    </section>
</section>

<!-- ========================== -->
<!-- Typische Architekturmuster -->
<!-- ========================== -->
<section data-use-template="teilkapitel" data-titel="Grundlegende Architekturmodelle"></section>

<section data-title="Der TCP/IP-Protokollstapel">
    <section data-title="Beteiligte Komponenten">
        <article class="centered-content">
            <div class="limited-width">
                <div class="markdown mb-4" detail-content>
                    Die überwiegende Mehrheit der verteilten Anwendungen laufen heute über das Internet oder nutzen zumindest
                    den TCP/IP-Protokollstapel. Das verteilte System besteht in diesem Fall aus einer beliebigen Anzahl von
                    Rechnerknoten mit einem netzwerkfähigen Betriebssystem, die über untereinander Nachrichten austauschen können.
                    Die auf den Rechnern laufenden Programmkomponenten bilden in ihrer Gesamtheit die eigentliche verteilte
                    Anwendung.
                </div>

                <div class="card mb-4">
                    <div class="card-header">
                        <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" role="switch" id="tcpip-details-switch">
                            <label class="form-check-label" for="tcpip-details-switch">Details anzeigen</label>
                        </div>
                    </div>
                    <div class="card-body">
                        <img src="02-architektur/tcpip-stack1.png" id="tcpip-stack1" class="d-block w-100" alt="Vereinfachter schematischer Aufbau eines verteilten Systems">
                        <img src="02-architektur/tcpip-stack2.png" id="tcpip-stack2" class="d-block w-100 hidden" alt="Vereinfachter schematischer Aufbau eines verteilten Systems">
                    </div>
                </div>

                <div id="tcpip-stack3" class="markdown hidden" detail-content>
                    Der Netzwerk-Stack des Betriebssystems wird grob wie folgt unterteilt:

                    * **Netzwerkschicht:** Dient der Anbindung an das physikalische Netzwerk, z.B. Ethernet oder WiFi.

                    * **Vermittlungsschicht:** Dient der Adressierung der Rechnerknoten und dem Routing von Datenpaketen
                      über lokale Netzwerkgrenzen hinweg. Auf dieser Ebene läuft das
                      [Internet Protocol (IP)](https://de.wikipedia.org/wiki/Internet_Protocol){target=_blank}, das jedem
                      Rechner eine (global) eindeutige IP-Adresse zuweist.

                    * **Transportschicht:** Dient der Adressierung mehrerer Dienste auf einem Rechner und der optionalen
                      Sicherstellung eine zuverlässigen Datenaustauschs. Auf dieser Ebene laufen das
                      [Transport Control Protocol (TCP)](https://de.wikipedia.org/wiki/Transmission_Control_Protocol){target=_blank}
                      und das [User Datagram Protocol (UDP)](https://de.wikipedia.org/wiki/User_Datagram_Protocol){target=_blank},
                      welche die Portnummern verwalten.

                    * **Anwendungsschicht:** Die eigentlichen auf dem Rechnerknoten laufenden Anwendungsprogramme.
                      Im einfachsten Fall nutzen diese die unteren Schichten direkt, um untereinander Daten auszutauschen.
                      Die meisten Betriebssysteme bzw. Programmiersprachen stellen hierfür
                      [Streams und Sockets](https://de.wikipedia.org/wiki/Socket_%28Software%29){target=_blank}
                      als Programmierschnittstelle bereit.

                      In größeren Anwendungen kommen jedoch spezialisierte Anwendungsprotokolle zum Einsatz, die
                      losgelöst vom fachlichen Anwendungscode entwickelt werden.
                </div>

                <script>
                    window.toggle_tcpip_details = function() {
                        let checkbox = document.querySelector("#tcpip-details-switch");
                        let image1   = document.querySelector("#tcpip-stack1");
                        let image2   = document.querySelector("#tcpip-stack2");
                        let details  = document.querySelector("#tcpip-stack3");

                        image1.classList.remove("hidden");
                        image2.classList.remove("hidden");
                        details.classList.remove("hidden");

                        if (checkbox.checked) {
                            image1.classList.add("hidden");
                        } else {
                            image2.classList.add("hidden");
                            details.classList.add("hidden");
                        }
                    }

                    window.addEventListener("ls-slide-changed", () => {
                        window.setTimeout(function() {
                            let checkbox = document.querySelector("#tcpip-details-switch");
                            if (!checkbox) return;

                            checkbox.addEventListener("change", toggle_tcpip_details);
                        }, 1000);
                    });
                </script>
            </div>
        </article>
    </section>

    <section data-title="Von Clients, Servern und Peers">
        <article class="centered-content">
            <div class="limited-width2">
                <p class="mb-4" detail-content>
                    Im Zusammenhang mit verteilten Netzwerkanwendungen haben sich bereits früh folgende Rollenbezeichnungen,
                    etabliert. Die Begriffe haben dabei eine klar definierte Bedeutung, werden im Alltag aber leider oft sehr
                    frei ausgelegt.
                </p>

                <lsx-grid-fluid class="p-0 mb-5">
                    <lsx-row>
                        <lsx-col size="md-8">
                            <table class="w-100">
                                <tr>
                                    <td style="padding-right: 0.5em;">
                                        💿
                                    </td>
                                    <td style="padding-right: 0.5em;">
                                        <b>Server</b>
                                    </td>
                                    <td>
                                        Langlaufendes Programm, das einen Dienst zur Verfügung stellt.
                                    </td>
                                </tr>
                                <tr>
                                    <td style="padding-right: 0.33em;">
                                        💿
                                    </td>
                                    <td style="padding-right: 0.5em;">
                                        <b>Client</b>
                                    </td>
                                    <td>
                                        Kurzlebiges Programm, das den Dienst nutzt.
                                    </td>
                                </tr>
                                <tr>
                                    <td style="padding-right: 0.5em; padding-bottom: 1em;">
                                        💿
                                    </td>
                                    <td style="padding-right: 0.5em; padding-bottom: 1em;">
                                        <b>Peer</b>
                                    </td>
                                    <td style="padding-bottom: 1em;">
                                        Spezielles Programm, das sowohl Client als auch Server für denselben Dienst ist.
                                    </td>
                                </tr>
                                <tr style="border: 0px dashed grey; border-top-width: 1px;">
                                    <td style="padding-top: 1em; padding-right: 0.5em;">
                                        🖥
                                    </td>
                                    <td style="padding-top: 1em; padding-right: 0.5em;">
                                        <b>Host</b>
                                    </td>
                                    <td style="padding-top: 1em;">
                                        Der Rechner, auf dem eines der obigen Programme läuft.
                                    </td>
                                </tr>
                            </table>
                        </lsx-col>
                        
                        <lsx-col size="md">
                            <lsx-info-box title="Merke">
                                Ein Server erbringt einen Dienst, den Service.
                            </lsx-info-box>
                        </lsx-col>
                    </lsx-row>
                </lsx-grid-fluid>


                <div class="d-flex gap-3 justify-content-center">
                    <lsx-card title="Client/Server-Architektur" bold>
                        <img src="02-architektur/client-server.svg" alt="Skizze mit vielen Clients und einem Server in der Mitte" class="d-block w-100" />
                    </lsx-card>
                    <lsx-card title="Peer-to-Peer-Architektur" bold>
                        <img src="02-architektur/peer-to-peer.svg" alt="Skizze mit vielen untereinander verbundenen Peers" class="d-block w-100" />
                    </lsx-card>
                </div>
            </div>
        </article>
    </section>

    <section data-title="Fallbeispiel: Sockets in Node.js">
        <article class="centered-content">
            <div class="limited-width2 mb-4">
                <div class="markdown dhbw-text-columns mb-4" detail-content>
                    Das nachfolgende Beispiel zeigt eine kleine Client/Server-Anwendung mit Node.js und JavaScript.
                    Client und Server setzen auf dem eben gezeigten TCP/IP-Protokollstapel auf und nutzen die Klassen
                    [`net.Server`](https://nodejs.org/docs/latest/api/net.html#class-netserver){target=_blank} bzw.
                    [`net.Socket`](https://nodejs.org/docs/latest/api/net.html#class-netsocket){target=_blank} für
                    den Datenaustausch. Es handelt sich dabei um die niedrigste Ebene, auf der Netzwerkanwendungen
                    mit [Node.js](https://nodejs.org/en){target=_blank} programmiert werden können.
                </div>

                <div class="d-flex flex-column gap-3 mb-4 fs-6">
                    <div class="d-flex gap-3 align-items-center">
                        <lsx-github-edit url="Beispiele/Socket-Minimalbeispiel"></lsx-github-edit>
                        <div>Minimalbeispiel</div>
                    </div>
                    <div class="d-flex gap-3 align-items-center">
                        <lsx-github-edit url="Beispiele/Socket-Sprachserver"></lsx-github-edit>
                        <div>Sprachserver</div>
                    </div>
                </div>

                <lsx-accordion class="mb-4">
                    <lsx-accordion-page title="Grundgerüst der Serveranwendung" bold>
                        <div class="markdown" detail-text>
                            Innerhalb der Serveranwendung muss ein Server-Objekt erzeugt und dessen
                            <src-code language="javascript">listen()</src-code>-Methode aufgerufen werden,
                            um TCP/IP-Verbindungsanfragen behandeln zu können. Für jeden neuen Client wird
                            eine Rückruffunktion zur Abwicklung des Datenaustauschs aufgerufen. Diese bekommt
                            ein <code>Socket</code>-Objekt zum Senden und Empfangen der Daten übergeben.
                        </div>

                        <lsx-tab-pages>
                            <lsx-tab-page title="Schritte">
                                <lsx-ul>
                                    <li>
                                        <code>Server</code>-Objekt erzeugen mit <src-code language="javascript">net.createServer()</src-code>
                                    </li>
                                    <li>
                                        <src-code language="javascript">listen()</src-code>-Methode aufrufen, um auf
                                        Clientverbindungen zu warten
                                    </li>
                                    <li>
                                        Callback-Funktion zur Abwicklung der Kommunikation mit einem Client übergeben
                                    </li>
                                    <li>
                                       Innerhalb der Client-Funktionen die <code>Socket</code>-Events und Metoden verwenden
                                    </li>
                                </lsx-ul>
                            </lsx-tab-page>

                            <lsx-tab-page title="Quellcode">
                                <source-code language="javascript">
                                    import net from "net";

                                    // Socket-Server starten
                                    let server = net.createServer(socket => {
                                        // Verbindung mit neuem Client hergestellt
                                        log(socket, "Client verbunden");

                                        socket.setEncoding("utf-8");
                                        socket.setNoDelay();
                                        socket.write("Hallo! Ich bin der Server.\n");

                                        socket.on("error", err => log(socket, err));
                                        socket.on("close", () => log(socket, "Client getrennt"));

                                        socket.on("data", data => {
                                            log(socket, "Empfangene Daten:", data);
                                            socket.write(data);
                                        });
                                    });

                                    server.listen("7000", "localhost");
                                </source-code>
                            </lsx-tab-page>
                        </lsx-tab-pages>
                    </lsx-accordion-page>

                    <lsx-accordion-page title="Grundgerüst der Clientanwendung" bold>
                        <div class="markdown" detail-text>
                            Die Programmierung der Clientseite erfolgt grundsätzlich gleich, nur dass hier die Methode
                            <src-code language="javascript">net.createConnection()</src-code> verwendet werden muss, um
                            eine Verbindung zum Server herzustellen. Analog zum Serverbeispiel erwartet diese eine
                            Callback-Funktion innerhalb derer ein <code>Socket</code>-Objekt zur Abwicklung des
                            Datenaustauschs verwendet werden kann. Was den hier gezeigten Quellcode allerdings komplexer
                            als die Serverseite macht, ist dass hier mit Hilfe der Klasse <code>EventEmitter</code>
                            eine Synchronisation zwische den vielen Event Handlern hergestellt werden muss, um die
                            Reihenfolge aus Anfrage und Antwort korrekt einhalten zu können.
                        </div>

                        <lsx-tab-pages>
                            <lsx-tab-page title="Schritte">
                                <lsx-ul>
                                    <li>
                                        <code>Socket</code>-Objekt erzeugen mit <src-code language="javascript">net.createConnection()</src-code>
                                    </li>
                                    <li>
                                        Callback-Funktion zur Abwicklung der Kommunikation mit einem Server übergeben
                                    </li>
                                    <li>
                                        Innerhalb der Client-Funktionen die <code>Socket</code>-Events und Metoden verwenden
                                    </li>
                                    <li>
                                        Ggf. Klassen wie <code>EventEmitter</code> nutzen, um die richtige Reihenfolge sicherzustellen
                                    </li>
                                </lsx-ul>
                            </lsx-tab-page>

                            <lsx-tab-page title="Quellcode">
                                <source-code language="javascript">
                                    import net                from "net";

                                    import * as readline      from 'node:readline/promises';
                                    import {stdin as input}   from 'node:process';
                                    import {stdout as output} from 'node:process';

                                    import {EventEmitter}     from 'node:events';
                                    import {once}             from 'node:events';

                                    let rl           = readline.createInterface({input, output});
                                    let dataReceived = new EventEmitter();
                                    let connected    = false;

                                    // Verbindung mit Server herstellen und Protokoll abwickeln
                                    let socket = net.createConnection({host: "localhost", port: 7000}, async () => {
                                        socket.setNoDelay();
                                        connected = true;

                                        while (connected) {
                                            let input = await rl.question("Ihre Eingabe: ");
                                            if (!connected) break;

                                            // Daten an den Server schicken
                                            if (input) {
                                                socket.write(input);

                                                // Antwort vom Server anzeigen
                                                let response = await once(dataReceived, "data");
                                                console.log("Server:", response[0], "\n");
                                            } else {
                                                connected = false;
                                            }
                                        }

                                        // Verbindung trennen
                                        socket.end();
                                        socket.destroy();

                                        rl.close();
                                    });


                                    // Empfangene Daten an die Hauptschleife oben schicken
                                    socket.on("data", data => {
                                        data = data.toString();
                                        dataReceived.emit("data", data);
                                    });

                                    socket.on("error", err => console.error("\n", err));
                                    socket.on("end", () => connected = false);
                                </source-code>
                            </lsx-tab-page>
                        </lsx-tab-pages>
                    </lsx-accordion-page>

                    <lsx-accordion-page title="Ausgetauschte Rohdaten" bold>
                        <div class="markdown mb-4" detail-text>
                            In der Tradition klassischer Internetdienste nutzt die Beispielanwendung ein einfach
                            gestricktes, textbasiertes Protokoll zur Verständigung zwischen Client und Server.
                            Der Screenshot zeigt die zwischen beiden Seiten ausgetauschten Daten, wobei die Sitzung
                            immer mit einer `HELLO`-Nachricht vom Client an den Server beginnt. Für dieses Beispiel
                            wurde mit dem Programm [netcat](https://de.wikipedia.org/wiki/Netcat){target=_blank}
                            eine direkte Socketverbindung zum Server hergestellt, anstelle die JavaScript-Clientanwendung
                            zu verwenden.
                        </div>

                        <img src="02-architektur/socket-netcat.png" class="d-block w-100" alt="Ausgetauschte Rohdaten">
                    </lsx-accordion-page>
                </lsx-accordion>

                <div class="d-flex flex-column flex-md-row gap-3">
                    <img src="02-architektur/socket-server.png" class="img-thumbnail d-block w-100" alt="Serverprogramm">
                    <img src="02-architektur/socket-client.png" class="img-thumbnail d-block w-100" alt="Clientprogramm">
                </div>
            </div>
        </article>
    </section>

    <section data-title="Benutzeroberfläche des Beispiels">
        <article class="centered-content">
            <div style="width: 35em; max-width: 100%;">
                <img src="02-architektur/frontenders-and-backenders.jpeg" class="d-block w-100">
                <small>
                    <small>
                        Bildnachweis:
                        <a href="https://turnoff.us/geek/frontenders-and-backenders/" target="_blank">turnoff.us</a>
                    </small>
                </small>
            </div>
        </article>
    </section>

    <section data-title="Heute übliche Programmiermodelle">
        <article class="centered-content">
            <div class="limited-width2">

                <lsx-grid-fluid>
                    <lsx-row>
                        <lsx-col size="md">
                            <lsx-card title="App-Server / Frameworks" bold class="h-100">
                                <lsx-card-body class="h-100 d-flex flex-column">
                                    <lsx-ul emoji="🎙️">
                                        <li>Beinhalten für Business Apps übliche Grundfunktionen</li>
                                        <li>Unterstützen verschieden Schnittstellentechnologien</li>
                                        <li>Oft auf die Entwicklung von Webanwendungen ausgerichtet</li>
                                    </lsx-ul>

                                    <div style="flex: 1"></div>
                                    <img src="02-architektur/arten-appserver.png" alt="" class="w-100" />
                                </lsx-card-body>
                            </lsx-card>
                        </lsx-col>

                        <lsx-col size="md">
                            <lsx-card title="Entfernte Methodenaufrufe" bold class="h-100">
                                <lsx-card-body class="h-100 d-flex flex-column">
                                    <lsx-ul emoji="🎙️">
                                        <li>Direkter Aufruf von Funktionen/Methoden des Servers</li>
                                        <li>Sowohl prozedural als auch objekt-orientiert möglich</li>
                                        <li>Teilweise auch zwischen verschiedenen Programmiersprachen</li>
                                    </lsx-ul>

                                    <div style="flex: 1"></div>
                                    <img src="02-architektur/arten-methodenaufrufe.png" alt="" class="w-100" />
                                </lsx-card-body>
                            </lsx-card>
                        </lsx-col>
                    </lsx-row>

                    <lsx-row>
                        <lsx-col size="md">
                            <lsx-card title="Webservices" bold class="h-100">
                                <lsx-card-body class="h-100 d-flex flex-column">
                                    <lsx-ul emoji="🎙️">
                                        <li>Grundsätzlich dieselbe Idee wie bei entfernten Methodenaufrufen</li>
                                        <li>Jedoch auf Basis von Webstandards wie HTTP, XML, JSON</li>
                                        <li>Früher SOAP, heute überwiegend REST-Webservices</li>
                                    </lsx-ul>

                                    <div style="flex: 1"></div>
                                    <img src="02-architektur/arten-webservices.png" alt="" class="w-100" />
                                </lsx-card-body>
                            </lsx-card>
                        </lsx-col>

                        <lsx-col size="md">
                            <lsx-card title="Message Broker" bold class="h-100">
                                <lsx-card-body class="h-100 d-flex flex-column">
                                    <lsx-ul emoji="🎙️">
                                        <li>Grundsätzlich asynchroner Nachrichtenaustausch</li>
                                        <li>Mehrere Empfänger für eine Nachricht möglich und üblich</li>
                                        <li>Store and Forward der Nachrichten in einer FIFO-Warteschlange</li>
                                    </lsx-ul>

                                    <div style="flex: 1"></div>
                                    <img src="02-architektur/arten-pubsub.png" alt="" class="w-100" />
                                </lsx-card-body>
                            </lsx-card>
                        </lsx-col>
                    </lsx-row>
                </lsx-grid-fluid>
            </div>
        </article>
    </section>

    <section data-title="Historische Entwicklung">
        <article class="centered-content">
            <div class="centered-content flex-row flex-wrap gap-3">
                <!-- Host-to-Host -->
                <lsx-modal>
                    <lsx-thumbnail style="height: 14em;" class="mw-100">
                        <img src="02-architektur/historie-abb1.jpg" class="d-block h-100 mw-100 dhbw-thumbnail"/>
                    </lsx-thumbnail>
                    <lsx-content>
                        <lsx-card title="Host-to-Host" bold class="mh-100 mw-100" style="width: 35em;">
                            <lsx-card-body class="overflow-scroll">
                                <p style="text-align: justify; hyphens: auto;">
                                    Vor Erfindung des ARPANET und ähnlicher Computernetze in den 1960er-Jahren gab es noch kein
                                    anerkanntes Modell, wie zwei Computer untereinander Daten austauschen können. Die einzige
                                    Möglichkeit war, eine direkte Kabelverbindung „host-to-host” herzustellen, wobei hierfür
                                    Hard- und Software auf beiden Seiten komplett selbst entwickelt werden mussten.
                                </p>

                                <lsx-ul emoji="🔌" class="lead mb-4">
                                    <li>Direkte Kabelverbindung zwischen zwei Rechnern</li>
                                    <li>Keine Unterstützung durch das Betriebssystem</li>
                                </lsx-ul>

                                <img src="02-architektur/historie-kabel.svg" alt="Zwei VS-Knoten mit direkter Kabelverbindung" style="width: 100%; margin-bottom: 1em;" />
                                <img src="02-architektur/historie-abb1.jpg" alt="" style="width: 100%;" />
                            </lsx-card-body>
                        </lsx-card>
                    </lsx-content>
                </lsx-modal>

                <!-- Packet Switching -->
                <lsx-modal>
                    <lsx-thumbnail style="height: 14em;" class="mw-100">
                        <img src="02-architektur/historie-abb2.jpg" class="d-block h-100 mw-100 dhbw-thumbnail"/>
                    </lsx-thumbnail>
                    <lsx-content>
                        <lsx-card title="Packet Switching" bold class="mh-100 mw-100" style="width: 35em;">
                            <lsx-card-body class="overflow-scroll">
                                <p style="text-align: justify; hyphens: auto;">
                                    In den ausgehenden 1960er-Jahren wurde für die neuentwickelten Computernetzwerke das auch heute
                                    noch gültige Prinzip des Packet Switching erfunden. Die Idee dahinter ist, die zu versendenden
                                    Daten in kleine Pakete zu zerlegen und jedes Paket seinen eigenen Weg durch das Netzwerk vom
                                    Sender zum Empfänger suchen zu lassen. Heute haben wir Router für diese Aufgabe. Im ARPANET hießen
                                    diese „Interface Message Processor” und waren so groß wie ein Schrank.
                                </p>

                                <lsx-ul emoji="📦" class="lead mb-4">
                                    <li>NCP und später TCP als Vorläufer von TCP/IP</li>
                                    <li>Weltweiter Datenaustausch zwischen allen Hosts</li>
                                    <li>Anschluss des Computers hierfür an einen <a href="https://en.wikipedia.org/wiki/Interface_Message_Processor" target="_blank">IMP</a></li>
                                </lsx-ul>

                                <img src="02-architektur/imp-subnet.svg" alt="Netzwerktopologie des früheren ARPANET" style="width: 100%; margin-bottom: 1em;" />

                                <!-- <lsx-youtube class="img-thumbnail embed-responsive" video="yU9oMOcRsuE"></lsx-youtube> -->
                                <div class="centered-content">
                                    <div class="embed-responsive ratio ratio-16x9 limited-width">
                                        <iframe class="d-block" src="https://www.youtube-nocookie.com/embed/yU9oMOcRsuE?rel=0&amp;showinfo=0" allowfullscreen></iframe>
                                    </div>
                                </div>
                            </lsx-card-body>
                        </lsx-card>
                    </lsx-content>
                </lsx-modal>

                <!-- Sockets- und Middleware -->
                <lsx-modal>
                    <lsx-thumbnail style="height: 14em;">
                        <img src="02-architektur/historie-abb3.jpg" class="d-block h-100 mw-100 dhbw-thumbnail"/>
                    </lsx-thumbnail>
                    <lsx-content>
                        <lsx-card title="Streams und Sockets" bold class="mh-100 mw-100" style="width: 35em;">
                            <lsx-card-body class="overflow-scroll">
                                <p style="text-align: justify; hyphens: auto;">
                                    Obwohl die heute vorherrschenden Streams und Sockets noch nicht erfunden waren (dies geschah erst 1983 mit
                                    Veröffentlichung der Socket API für BSD Unix), suchte man bereits in den 1970er-Jahren nach Möglichkeiten,
                                    die Netzwerkprogrammierung zu vereinfachen. In dieser Zeit wurde der „entfernte Prozeduraufruf“ erfunden,
                                    bei dem die Unterprogramme (bzw. Funktionen bzw. Methoden, je nach Programmiersprache) eines Serverprogramms
                                    über das Netzwerk direkt aufgerufen werden können, ohne den konkreten Datenaustausch auf Byte-Ebene hierfür
                                    kennen zu müssen.
                                </p>

                                <lsx-ul emoji="📃" class="lead mb-4">
                                    <li><a href="https://de.wikipedia.org/wiki/Remote_Procedure_Call" target="_blank">Remote Procedure Call</a> ab den 1970ern</li>
                                    <li>Zunächst konkurrierende Programmiermodelle</li>
                                    <li>Streams und Sockets ab 1983 in BSD Unix</li>
                                </lsx-ul>

                                <img src="02-architektur/historie-sockets.svg" alt="Zwei VS-Knoten mit Middleware" style="width: 100%; margin-bottom: 1em;" />
                                <img src="02-architektur/historie-abb3.jpg" alt="" style="width: 100%;" />
                            </lsx-card-body>
                        </lsx-card>
                    </lsx-content>
                </lsx-modal>

                <!-- Applikationsserver -->
                <lsx-modal>
                    <lsx-thumbnail style="height: 14em;">
                        <img src="02-architektur/historie-abb4.jpg" class="d-block h-100 mw-100 dhbw-thumbnail"/>
                    </lsx-thumbnail>
                    <lsx-content>
                        <lsx-card title="Applikationsserver" bold class="mh-100 mw-100" style="width: 35em;">
                            <lsx-card-body class="overflow-scroll">
                                <p style="text-align: justify; hyphens: auto;">
                                    Mit zunehmendem Umfang der Anforderungen stieg spätestens ab Mitte der 1990er-Jahre auch die
                                    Komplexität typischer verteilter Anwendungen deutlich an. In Folge daraus versuchte man über
                                    den Datenaustauschs hinausgehende Querschnittsfunktionen typischer Informationssysteme in sog.
                                    Applikationsserver auszugliedern, die als generische Laufzeitumgebung frei programmierbar an
                                    den jeweiligen Anwendungsfall angepasst werden konnten.
                                </p>
                                <p style="text-align: justify; hyphens: auto;">
                                    Aus heutiger Sicht vereinfacht das damit verbundene Programmiermodell die Erstellung neuer
                                    Anwendungen zwar drastisch, wird aber dennoch als schwerfällig und komplex empfunden. Heute
                                    geht der Trend stattdessen mehr in die Richtung, die ehemals vom Applikationsserver bereitgestellten
                                    Funktionen in Form Quellcode-Bibliotheken oder Micro-Frameworks zu integrieren.
                                </p>

                                <lsx-ul emoji="🚢" class="lead mb-4">
                                    <li>Große Applikationsserver ab den 1990ern</>
                                    <li>Zunächst RPC später Webtechnologien</li>
                                    <li>Heute eher leichtgewichtigere Micro-Frameworks</li>
                                </lsx-ul>

                                <img src="02-architektur/historie-appserver.svg" alt="Drei VS-Knoten von denen einer ein Applikationsserver ist" style="width: 100%; margin-bottom: 1em;" />
                                <img src="02-architektur/historie-abb4.jpg" alt="" style="width: 100%;" />
                            </lsx-card-body>
                        </lsx-card>
                    </lsx-content>
                </lsx-modal>
            </div>
        </article>
    </section>

    <section data-title="Grundlegende Architekturmodelle">
        <article class="centered-content">
            <div class="limited-width2">
                <lsx-tab-pages class="w-100">
                    <lsx-tab-page title="Client/Server">
                        <div class="markdown dhbw-text-columns mb-4" detail-content>
                            Dies ist die einfachste Architektur von allen. Sie besteht lediglich aus einem Server,
                            der einen Dienst anbietet und den Clients, welche den Dienst konsumieren. Die Kommunikation
                            folgt dabei häufig einem einfachen **Request/Response**-Verfahren, obwohl Sockts prinzipiell
                            jede Reihenfolge zulassen.

                            Früher wurden die Aufrufe clientseitig synchron programmiert. Dies sollte das Konzept eines
                            einfachen Methodenaufrufs simulieren, indem der rufende Thread für die Dauer einer Anfrage
                            blockiert und erst nach Eintreffer der Serverantwort wieder aufgeweckt wurde. In etwa so:

                            <src-code language="javascript">
                                let response = send_http_request("GET", "http://localhost:8080/");
                                // Hier geht es erst weiter, wenn die Antwort empfangen wurde
                            </src-code>

                            Da das aber sehr inneffizient ist, folgend moderne Bibliotheken einem asynchronen Ansatz, bei
                            dem der Clientthread wahlweise warten oder parallel weiterarbeiten kann. {.mt-4}
                        </div>


                        <lsx-grid-fluid class="p-0">
                            <lsx-row>
                                <lsx-col size="md" class="d-flex justify-content-center mb-4 mb-md-0">
                                    <img src="02-architektur/architektur-client-server.svg" alt="Skizze eines Servers und dreier Clients" class="d-block m-auto" style="max-width: 45em;" />
                                </lsx-col>
                                <lsx-col size="md" class="d-flex justify-content-center align-items-center">
                                    <lsx-card title="Fallbeispiele" style="flex: 1;">
                                        <lsx-ul emoji="✅">
                                            <li>
                                                Browser und Webserver im World Wide Web
                                            </li>
                                            <li>
                                                Browser App mit Zugriff auf den Server via Websockets
                                            </li>
                                            <li>
                                                Wartungszugang auf einen Rechner per Secure Shell
                                            </li>
                                            <li>
                                                Zugriff auf ein E-Mailpostfach mit IMAP
                                            </li>
                                            <li>
                                                Zentrale Quellcodeverwaltung mit Subversion
                                            </li>
                                            <li>
                                                WebDAV-Zugriff auf einen geteilten Onlineordner
                                            </li>
                                        </lsx-ul>
                                    </lsx-card>
                                </lsx-col>
                            </lsx-row>
                        </lsx-grid-fluid>
                    </lsx-tab-page>

                    <lsx-tab-page title="Dreischichtenarchitektur">
                        <p class="dhbw-text-columns mb-4" detail-content>
                            Hierbei handelt es sich ebenfalls um eine Client/Server-Architektur, jedoch greift der Server zusätzlich
                            auf eine Datenbank zu. Client, Server und Datenbank werden daher den drei Schichten <b>Darstellung</b>,
                            <b>Anwendungslogik</b> und <b>Datenhaltung</b> zugeordnet. Für die Darstellung wurden früher ausschließlich
                            native Clients verwendet, die heute zunehmend von Webanwendungen und mobilen Apps verdrängt werden. Die
                            Schichten für die Anwendungslogik und Datenhaltung können hingegen auch mehrere Server umfassen.
                        </p>

                        <lsx-grid-fluid class="p-0">
                            <lsx-row>
                                <lsx-col size="md" class="d-flex justify-content-center mb-4 mb-md-0">
                                    <img src="02-architektur/architektur-3schichten.svg" alt="Skizze einer Dreischichtenarchitektur" class="d-block limited-width m-auto" />
                                </lsx-col>
                                <lsx-col size="md" class="d-flex justify-content-center align-items-center">
                                    <lsx-card title="Fallbeispiele" style="flex: 1;">
                                        <lsx-ul emoji="✅">
                                            <li>
                                                Jede Webanwendung mit einer Datenbank im Hintergrund
                                            </li>
                                            <li>
                                                Informationssysteme ohne eigenständigen Präsentationsserver
                                            </li>
                                            <li>
                                                Die meisten ERP- und CRM-Systeme (SAP S/4HANA, Navision, …)
                                            </li>
                                            <li>
                                                Per Webservice erreichbare Microservices
                                            </li>
                                        </lsx-ul>
                                    </lsx-card>
                                </lsx-col>
                            </lsx-row>
                        </lsx-grid-fluid>
                    </lsx-tab-page>

                    <lsx-tab-page title="Vierschichtenarchitektur">
                        <p class="dhbw-text-columns mb-4" detail-content>
                            Hierbei handelt es sich um eine Variation der Dreischichtenarchitektur, bei der die mittlere Sicht
                            in eine <b>Präsentations-</b> und eine <b>Anwendungsschicht</b> zerlegt wurde. Dieses Modell
                            findet man häufig bei ERP-Systemen, die mehrere Clienttechnologien unterstützen müssen.
                        </p>

                        <lsx-grid-fluid class="p-0">
                            <lsx-row>
                                <lsx-col size="md" class="d-flex justify-content-center mb-4 mb-md-0">
                                    <img src="02-architektur/architektur-4schichten.svg" alt="Skizze einer Dreischichtenarchitektur" class="d-block limited-width m-auto" />
                                </lsx-col>
                                <lsx-col size="md" class="d-flex justify-content-center align-items-center">
                                    <lsx-card title="Fallbeispiele" style="flex: 1;">
                                        <lsx-ul emoji="✅">
                                            <li>
                                                ERP- und CRM-Systeme mit Präsentationsserver
                                            </li>
                                            <li>
                                                Typische Single Page Apps mit Webservice-Backend
                                            </li>
                                        </lsx-ul>
                                    </lsx-card>
                                </lsx-col>
                            </lsx-row>
                        </lsx-grid-fluid>
                    </lsx-tab-page>

                    <lsx-tab-page title="Microservices">
                        <!-- Eigene Folie hieraus machen und die anderen Architekturmuster zurückstellen? -->
                        <!--
                        ChatGPT:

                        Die Definition deckt viele zentrale Aspekte ab, insbesondere die
                        Entkopplung eines Monolithen in eigenständige, fachlich fokussierte
                        Services sowie die Bedeutung von Automatisierung und
                        teamübergreifender Verantwortung. Dennoch könnten einige Punkte noch
                        ergänzt oder präzisiert werden:

                        Dezentrale Datenhaltung und Zuständigkeiten:
                        Microservices sollten idealerweise auch ihre eigene Datenhaltung
                        haben, um enge Kopplungen und Abhängigkeiten zu vermeiden. Jeder
                        Service ist für seinen eigenen Datenbestand verantwortlich, was die
                        Unabhängigkeit und Skalierbarkeit erhöht.

                        Kommunikation und Schnittstellendesign:
                        Neben der gut dokumentierten und versionierten API ist es wichtig,
                        dass die Kommunikation zwischen den Services über leichtgewichtige
                        Protokolle (z. B. HTTP/REST, gRPC oder Messaging-Systeme) erfolgt.
                        Dies fördert die lose Kopplung und ermöglicht flexible Interaktionen.

                        Fehlertoleranz und Resilienz:
                        Da Microservices in einer verteilten Umgebung betrieben werden, sind
                        Konzepte wie Circuit Breaker, Wiederholungsmechanismen und
                        Service-Discovery essenziell, um Ausfälle einzelner Services
                        abzufedern und das Gesamtsystem robust zu gestalten.

                        Unabhängige Deployment-Zyklen:
                        Ein wesentlicher Vorteil von Microservices ist die Möglichkeit,
                        einzelne Komponenten unabhängig voneinander zu entwickeln, zu testen
                        und bereitzustellen. Dies erfordert entsprechende Infrastruktur, z. B.
                        Containerisierung (wie Docker) und Orchestrierung (wie Kubernetes).

                        Technologische Heterogenität:
                        Teams haben oft die Freiheit, für jeden Microservice die am besten
                        geeigneten Technologien, Programmiersprachen oder Datenbanksysteme zu
                        wählen, was zur Optimierung der jeweiligen Funktionalität beiträgt.

                        Domain-Driven Design (DDD) und Business-Fokus:
                        Häufig werden Microservices um sogenannte „bounded contexts“ herum
                        entworfen, was bedeutet, dass jeder Service einen klar definierten
                        Geschäftsbereich abdeckt. Dies fördert ein besseres Verständnis der
                        Geschäftslogik und erleichtert die Modellierung komplexer Systeme.

                        Betriebsüberwachung und Logging:
                        In einer verteilten Architektur ist es besonders wichtig, umfassende
                        Monitoring-, Logging- und Tracing-Lösungen zu implementieren, um den
                        Überblick über die Interaktionen und den Zustand der einzelnen
                        Services zu behalten.

                        Zusammengefasst:
                        Die Definition trifft den Kern von Microservices, könnte aber um
                        Aspekte wie dezentrale Datenhaltung, spezifische
                        Kommunikationsmechanismen, Resilienzstrategien, unabhängige
                        Deployment-Prozesse sowie den geschäftsorientierten Ansatz (bspw.
                        durch Domain-Driven Design) erweitert werden. Diese Ergänzungen helfen
                        dabei, das volle Potenzial und die Herausforderungen von Microservices
                        in der Praxis besser zu verstehen.
                        -->
                        <p class="dhbw-text-columns mb-4" detail-content>
                            Microservices zerlegen eine große, monolithische Anwendung in viele kleine Teilanwendungen. Jeder Microservice hat
                            ein klar umrissenes Aufgabengebiet, besitzt eine gut dokumentierte und versionierte Schnittstelle und wird in der
                            Regel von einem eigenen Team entwickelt und betrieben. Entwicklung, Test und Betrieb sind sehr stark automatisiert.
                            Microservices eignen sich daher oft für große Firmen mit mehreren, unabhängigen Entwicklungsmannschaften.
                        </p>

                        <div class="form-check form-switch mb-4 fw-bold">
                            <input class="form-check-input" type="checkbox" role="switch" id="microservices-switch">
                            <label class="form-check-label microservices-switch-off" for="microservices-switch">Beschreibung</label>
                            <label class="form-check-label microservices-switch-on hidden" for="microservices-switch">Fallbeispiel</label>
                        </div>

                        <lsx-grid-fluid class="p-0 microservices-switch-off">
                            <lsx-row>
                                <lsx-col size="md" class="d-flex justify-content-center mb-4 mb-md-0">
                                    <img src="02-architektur/microservices.png" alt="Skizze einer Microservice-Architektur" class="d-block limited-width m-auto" />
                                </lsx-col>
                                <lsx-col size="md" class="d-flex justify-content-center align-items-center">
                                    <lsx-card title="Fallbeispiele" style="flex: 1;">
                                        <lsx-ul emoji="✅">
                                            <li>
                                                Amazon gilt als Erfinder, obwohl sie den Begriff nicht verwenden
                                            </li>
                                            <li>
                                                Große Internetplattformen wie eBay, Netflix, SoundCloud, Spotify, …
                                            </li>
                                            <li>
                                                So gut wie jede größere Cloud-Anwendung
                                            </li>
                                        </lsx-ul>
                                    </lsx-card>
                                </lsx-col>
                            </lsx-row>
                        </lsx-grid-fluid>

                        <img src="02-architektur/microservices-beispiel.png" alt="Fallbeispiel für eine Microservice-Architektur" class="d-block w-100 hidden microservices-switch-on">

                        <script>
                            window.toggle_microservices_content = function() {
                                let checkbox = document.querySelector("#microservices-switch");

                                for (let element of document.querySelectorAll(".microservices-switch-off, .microservices-switch-on")) {
                                    element.classList.add("hidden");
                                }

                                for (let element of document.querySelectorAll(checkbox.checked ? ".microservices-switch-on" : ".microservices-switch-off")) {
                                    element.classList.remove("hidden");
                                }
                            }

                            window.addEventListener("ls-slide-changed", () => {
                                window.setTimeout(function() {
                                    let checkbox = document.querySelector("#microservices-switch");
                                    if (!checkbox) return;

                                    checkbox.addEventListener("change", toggle_microservices_content);
                                }, 1000);
                            });
                        </script>
                    </lsx-tab-page>

                    <lsx-tab-page title="Reverse Proxy / API-Gateway">
                        <p class="dhbw-text-columns mb-4" detail-content>
                            Serverseitig kann ein Reverse Proxy als API-Gateway eingesetzt werden, um die eingehenden Anfragen
                            zu bündeln. Dadurch wird es möglich, zusätzliche Sicherheitsprüfungen zu implementieren, häufig
                            angefragte Inhalte zu cachen oder eine transparente Lastverteilung vorzunehmen.
                        </p>

                        <lsx-grid-fluid class="p-0">
                            <lsx-row>
                                <lsx-col size="md" class="d-flex justify-content-center mb-4 mb-md-0">
                                    <img src="02-architektur/proxy-serverseitig.png" alt="Architekturskizze mit serverseitigem Proxy" style="max-height: 16em; max-width: 100%;" />
                                </lsx-col>
                                <lsx-col size="md" class="d-flex justify-content-center align-items-center">
                                    <lsx-card title="Fallbeispiele" style="flex: 1;">
                                        <lsx-ul emoji="✅">
                                            <li>
                                                Steigerung der Performance durch Caching häufig angefragter Daten
                                            </li>
                                            <li>
                                                Implementierung von Zugangsbeschränkungen und Upload Filtern
                                            </li>
                                            <li>
                                                Realisierung von Paywalls zum Ausfiltern kostenpflichtiger Inhalte
                                            </li>
                                            <li>
                                                Sicherstellen einer vorgelagerten, zentralen Authentifizierung
                                            </li>
                                            <li>
                                                Überlöastung vermeiden durch Rate Limiting / Throttling
                                            </li>
                                            <li>
                                                Monitoring und statistische Aufzeichnung der Nutzung
                                            </li>
                                            <li>
                                                <u>Serverseitige</u> Lastverteilung
                                            </li>
                                        </lsx-ul>
                                    </lsx-card>
                                </lsx-col>
                            </lsx-row>
                        </lsx-grid-fluid>
                    </lsx-tab-page>

                    <lsx-tab-page title="Proxy">
                        <p class="dhbw-text-columns mb-4" detail-content>
                            Ein clientseitiger Proxy bildet die Schnittstelle eines entfernten Servers innerhalb
                            des lokalen Netzwerks ab. Die Anfragen der Clients werden nicht direkt an den Server
                            sondern an den lokalen Proxy gesendet, der daraufhin entscheiden kann, ob er die
                            Anfragen weiterleitet oder selbst beantwortet.
                        </p>

                        <lsx-grid-fluid class="p-0">
                            <lsx-row>
                                <lsx-col size="md" class="d-flex justify-content-center mb-4 mb-md-0">
                                    <img src="02-architektur/proxy-clientseitig.png" alt="Architekturskizze mit clientseitigem Proxy" style="max-height: 16em; max-width: 100%;" />
                                </lsx-col>
                                <lsx-col size="md" class="d-flex justify-content-center align-items-center">
                                    <lsx-card title="Fallbeispiele" style="flex: 1;">
                                        <lsx-ul emoji="✅">
                                            <li>
                                                Steigerung der Performance durch Caching häufig angefragter Daten
                                            </li>
                                            <li>
                                                Implementierung von Zugangsbeschränkungen und Content Filtern
                                            </li>
                                            <li>
                                                <u>Clientseitige</u> Lastverteilung
                                            </li>
                                        </lsx-ul>
                                    </lsx-card>
                                </lsx-col>
                            </lsx-row>
                        </lsx-grid-fluid>
                    </lsx-tab-page>
                </lsx-tab-pages>
            </div>
        </article>
    </section>
</section>

<section data-title="Monolith vs. Microservices">
    <section data-title="Anwendungsarchitektur früher">
        <article class="centered-content">
            <div class="limited-width2">
                <div>
                    <p detail-content>
                        Frühere Anwendungsarchitekturen, bei denen sämtliche Funktionen in einer großen Codebasis
                        untergebracht waren, werden heute als Monolith bezeichnet. Zwar kann der Quellcode
                        durchaus modular aufgebaut und somit leicht um neue Funktionen erweiterbar sein. Jedoch
                        kann die Anwendung nur als Ganzes deployed und in Betrieb genommen werden.
                    </p>

                    <img src="02-architektur/monolith.png" class="d-block limited-width m-auto mb-3" />

                    <p detail-content>
                        Verteilte Anwendungen werden daher häufig mit einer Microservice-Architektur gestaltet.
                        Für kleine Entwicklerteams kann ein Monolith dennoch die bessere Wahl sein, da nicht
                        jedes Unternehmen organisatorisch auf Microservices vorbereitet ist. Vor allem, wenn
                        die Entwicklung nicht auf mehrere Teams verteilt werden kann, sind die Voraussetzungen
                        meist nicht gegeben.
                    </p>
                </div>

                <lsx-grid-fluid class="p-0">
                    <lsx-row>
                        <lsx-col size="md">
                            <div class="card h-100">
                                <div class="card-header fw-bold">
                                    Vorteile von Monolithen
                                </div>
                                <div class="card-body markdown">
                                    * Einfache Anwendungsarchitektur mit wenigen Komponenten.
                                    * Insbesondere für kleine Entwicklerteams leicht handlebar.
                                    * Eine Programmiersprache für alle Teile der Anwendung.
                                    * Direkter Datenaustausch zwischen den Anwendungskomponenten.
                                    * Anwendungskomponenten können sich gegenseitig direkt aufrufen.
                                </div>
                            </div>
                        </lsx-col>

                        <lsx-col size="md">
                            <div class="card h-100">
                                <div class="card-header fw-bold">
                                    Nachteile von Monolithen
                                </div>
                                <div class="card-body markdown">
                                    * Unpraktisch für sehr große Anwendungen mit vielen Funktionen.
                                    * Die Auswirkungen einer Änderung sind oft schwer nachvollziehbar.
                                    * In großen Entwicklerteams kommt es oft zu gegenseitigen Störungen.
                                    * Kein getrenntes Deployment einzelner Anwendungsfunktionen möglich.
                                    * Vor jedem Deployment muss die ganze Anwendung getestet werden.
                                    * Fehlerkorrekturen brauchen daher lange, bis sie produktiv gehen.
                                    * Die Anwendung kann nur als Ganzes skaliert werden.
                                </div>
                            </div>
                        </lsx-col>
                    </lsx-row>
                </lsx-grid-fluid>
            </div>
        </article>
    </section>

    <section data-title="Probleme beim Deployment monolithischer Anwendungen">
        <article class="centered-content">
            <div class="limited-width">
                <div class="d-flex flex-column flex-md-row gap-5">
                    <img src="02-architektur/wanted-monolith.jpg" class="d-block w-100" alt="Wanted! The Monolith …">
                    <img src="02-architektur/code-freeze.jpg" class="d-block w-100" alt="It's really, really, really, really code freeze">
                </div>

                <small>
                    <small>
                        Bildnachweise:
                        <a href="https://turnoff.us/geek/not-wanted/" target="_blank">{turnoff.us} not wanted</a>,
                        <a href="https://geek-and-poke.com/geekandpoke/2015/3/25/code-freeze" target="_blank">Geek & Poke: Code Freeze</a>
                    </small>
                </small>
            </div>
        </article>
    </section>

    <section data-title="Anwendungsarchitektur heute">
        <article class="centered-content">
            <div class="limited-width2">
                <lsx-accordion>
                    <lsx-accordion-page title="Definition: Microservices" class="markdown" bold active>
                        Moderne Anwendungen werden heute oft als Microservice-Architektur ausgeführt, in welcher die
                        Teilfunktionen einer Anwendung in einzelne Serverdienste ausgelagert werden. Microservice-basierte
                        Anwendungen sind daher immer verteilte Anwendungen. Dabei bildet jeder Microservice eine getrennte
                        Einheit, die weitgehend unabhängig entwickelt, deployed und betrieben wird. Meistens besitzt jeder
                        Microservice deshalb eine eigene Datenbank, auf deren Inhalte nur über die öffentliche Schnittstelle
                        des Microservices entfernt zugegriffen werden kann. Martin Fowler definiert Microservices
                        [auf seiner Webseite](https://martinfowler.com/microservices/){target=_blank} daher wie folgt:

                        * Entfernte Serverdienste als Teilkomponenten einer Anwendung
                        * Dezentralisierte Verwaltung und dezentrales Datenmanagement
                        * Entsprechen oft organisatorischer Unternehmenseinheiten
                        * Deshalb meist langfristig durch eigenständige Teams betreut
                        * Über eine öffentliche Schnittstelle entfernt aufrufbar
                        * Fehlertoleranter Entwurf mit evolutionärem Design
                        * Hoher Automatisierungsgrad für Betrieb und Weiterentwicklung
                    </lsx-accordion-page>

                    <lsx-accordion-page title="Beispiele" bold>
                        <lsx-tab-pages>
                           <lsx-tab-page title="Single Page App mit API-Gateway">
                               <div class="markdown">
                                   Heutige Webanwendungen trennen sehr strickt zwischen der Frontend genannten Benutzeroberfläche
                                   und der zentralen Anwendungsfunktionen im Backend. Oft handelt es sich beim Frontend um eine
                                   als Single Page App ausgeführte Webanwendung, die vollständig im Browser des Clientgeräts läuft.
                                   Aber auch mobile Anwendungen, native Desktopanwendungen oder eine Kombination aus allem sind
                                   weit verbreitet.

                                   Frontend und Backend kommunizieren daher über das Netzwerk, wobei die Verteilung des Backends
                                   hinter einem API-Gateway verborgen wird. Das API-Gateway bietet hierfür einen zentralen
                                   Zugriffspunkt, über den alle Backendservices einheitlich angebsprochen werden können, ohne
                                   die eigentlichen Backendstrukturen kennen zu müssen (oder dürfen).
                               </div>
                               <img id="microservices-bilder-1" src="02-architektur/microservices-gateway.png" class="d-block w-100 mt-4" />
                           </lsx-tab-page>
                           <lsx-tab-page title="Webanwendung mit Composite UI">
                               <div class="markdown">
                                   Ein früherer Ansatz, wie er heute unter Anderem von Amazon genutzt wird, konzentriert
                                   sich ausschließlich auf Webanwendungen. Meist handelt es sich dabei um serverseitig
                                   gerenderte Multi Page Apps ohne die eben besprochene Trennung von Frontend und Backend.

                                   Als Besonderheit setzt sich die Benutzeroberfläche allerdings wie bei einem Puzzle aus
                                   unterschiedlichen Teilen zusammen, die jeweils von einem anderen Microservice bereitgestellt
                                   werden. Praktisch bedeutet dies, dass es ein vorgelagerter Webserver eine mehr oder weniger
                                   leere HTML-Seite mit nur allgemeinen Dingen wie dem Seitenkopf oder einem einfachen
                                   Navigationsmenü zur Verfügung stellt. In diese werden dann von den Microservices gelieferte
                                   HTML-Fragemente (sog. Microfrontends) eingebettet, um die Ansicht zu vervollständigen.
                               </div>
                               <img id="microservices-bilder-2" src="02-architektur/microservices-compositeui.png" class="d-block w-100 mt-4" />
                           </lsx-tab-page>
                       </lsx-tab-pages>
                    </lsx-accordion-page>

                    <lsx-accordion-page title="Vor- und Nachteile" bold>
                        <lsx-grid-fluid class="p-0">
                             <lsx-row>
                                 <lsx-col size="md">
                                     <div class="card h-100">
                                         <div class="card-header fw-bold">
                                             Vorteile von Microservices
                                         </div>
                                         <div class="card-body markdown">
                                             * Die Services sind durch ihre Schnittstellen klar gekapselt.
                                             * Jeder Service kann einzeln deployed und skaliert werden.
                                             * Sprachen, Bibliotheken, … können passend zum Service ausgewählt werden.
                                             * Schwergewichtige Appliktionsserver und Frameworks können oft vermieden werden.
                                             * Microservices lassen sich meist leicht als Docker-Container o.ä. verpacken.
                                         </div>
                                     </div>
                                 </lsx-col>

                                 <lsx-col size="md">
                                     <div class="card h-100">
                                         <div class="card-header fw-bold">
                                             Nachteile von Microservices
                                         </div>
                                         <div class="card-body markdown">
                                             * Verteilte Systeme mit vielen Komponenten sind schwer zu programmieren.
                                             * Microservices müssen eventuellkonsistent und fehlertolerant programmiert werden.
                                             * Deployment, Betrieb und Überwachung bringen zusätzliche Komplexität.
                                             * Die Kommunikation zwischen Microservices ist grundsätzlich latenzbehaftet.
                                             * Kleinere und unerfahrene Teams können mit der Komplexität überfordert sein.
                                         </div>
                                     </div>
                                 </lsx-col>
                             </lsx-row>
                         </lsx-grid-fluid>

                         <div class="markdown">
                             Laut Martin Fowler lohnt sich eine Microservice-Architektur daher nur, wenn eine Anwendung hinreichend
                             groß ist und von mehreren Entwicklerteams betreut werden kann. Vgl.
                             [Martin Fowler: Microservice Guide](https://martinfowler.com/microservices/){target=_blank}
                         </div>
                    </lsx-accordion-page>
                </lsx-accordion>
            </div>
        </article>
    </section>

    <section data-title="Herausforderungen bei der Nutzung von Microservices">
        <article class="centered-content">
            <div class="limited-width2">
                <div class="d-flex flex-column flex-md-row gap-3">
                    <img src="02-architektur/valentines-day.png" class="d-block w-100" alt="Happy Valentines Day">
                    <img src="02-architektur/microservices-and-monolithic.png" class="d-block w-100" alt="Are you ready for microservices?">
                </div>

                <small>
                    <small>
                        Bildnachweise:
                        <a href="https://turnoff.us/geek/valentines-day/" target="_blank">{turnoff.us} valentine's day at the kernel</a>,
                        <a href="https://turnoff.us/geek/are-you-ready-for-microservices/" target="_blank">{turnoff.us} are you ready for microservices?</a>
                    </small>
                </small>
            </div>
        </article>
    </section>

    <section data-title="Skalierung von Microservices">
        <article class="centered-content">
            <div class="limited-width">
                <lsx-carousel class="carousel-fade">
                    <lsx-carousel-page>
                        <img src="02-architektur/skalierung-1.png" class="d-block w-100 mb-5">
                        <p>
                            Microservice-Architekturen lassen sich grundsätzlich einfacher skalieren als monolithische Anwendungen,
                            da jeder Service getrennt deployed wird. Für jeden Service kann daher eine optimale Ressourcenzuteilung
                            entsprechend dem tatsächlichen Bedarf vorgenommen werden.
                        </p>
                    </lsx-carousel-page>
                    <lsx-carousel-page>
                        <img src="02-architektur/skalierung-2.png" class="d-block w-100 mb-5">
                        <p>
                            Bei leicht ansteigender Last könnte die Laufzeitumgebung beispielsweise den laufenden Instanzen mehr
                            Leistung zur Verfügung stellen.
                        </p>
                    </lsx-carousel-page>
                    <lsx-carousel-page>
                        <img src="02-architektur/skalierung-3.png" class="d-block w-100 mb-5">
                        <p>
                            In der Regel werden so genannte Skalierungstrigger, wie die Anzahl HTTP-Anfragen je Sekunde, jedoch
                            genutzt, um weitere Serviceinstanzen zu starten. Die eingehenden Anfragen werden dann durch einen Load
                            Balancer gleichmäßig auf die Instanzen verteilt.
                        </p>
                    </lsx-carousel-page>
                    <lsx-carousel-page>
                        <img src="02-architektur/skalierung-4.png" class="d-block w-100 mb-5">
                        <p>
                            Damit diese Art der Skalierung funktioniert, dürfen die Services allerdings keine temporären Sitzungdaten
                            im Hauptspeicher ablegen. Denn es kann in der Regel nicht garantiert werden, dass zusammengehörige Anfragen
                            stets dieselbe Instanz erreichen. Außerdem können die Instanzen jederzeit neugestartet werden, wodurch die
                            im Hauptspeicher liegenden Daten ebenfalls verloren gingen.
                        </p>
                    </lsx-carousel-page>
                    <lsx-carousel-page>
                        <img src="02-architektur/skalierung-5.png" class="d-block w-100 mb-5">
                        <p>
                            Cloud-Anwendungen, welche serverseitige Sitzungsdaten verwalten, persistieren diese daher meist in einer
                            Datenbank. Oft wird hierfür dieselbe Datenbank genutzt, in der auch die originären Nutzdaten des jeweiligen
                            Microservices liegen. Genauso oft kommen allerdings auch spezialisierte Datenbanken oder Objektspeicher
                            wie Redis zum Einsatz.
                        </p>
                    </lsx-carousel-page>
                    <lsx-carousel-page>
                        <img src="02-architektur/skalierung-6.png" class="d-block w-100 mb-5">
                        <p>
                            Idealerweise benötigt eine Anwendung überhaupt keine serverseitigen Sitzungsdaten, sondern verwaltet diese
                            rein clientseitig. Dadurch werden der Server entlastet und Zeitverzögerungen aufgrund einer langsamen
                            Internetverbindung vermieden. Gemäß
                            <a href="https://martinfowler.com/articles/distributed-objects-microservices.html" target="_blank">Martin Fowler's „First Law of Distributed Objects”</a>
                            funktioniert dies am besten, wenn die Kommunikation mit dem Backend auf wenige Anfragen mit gebündelten
                            Inhalten reduziert wird.
                        </p>
                    </lsx-carousel-page>

                    <lsx-carousel-page>
                        <img class="active d-block w-25 m-auto" src="shared/finish.svg" />
                        <p>
                            Wird eine Anwendung nach den vorgenannten Prinzipien serverseitig möglichst zustandslos implementiert,
                            kann sie jederzeit problemlos hoch- oder runterskaliert werden.
                        </p>
                    </lsx-carousel-page>
                </lsx-carousel>
            </div>
        </article>
    </section>
</section>

<section data-title="Nicht-fachliche Services">
    <section data-title="Typische nicht-fachliche Microservices">
        <article class="centered-content">
            <div class="limited-width2 markdown">
                Je größer eine verteilte Anwendung ist oder im Laufe der Zeit wird, desto wichtiger ist es,
                dass über die funktionalen Anforderungen hinaus auch eine Vielzahl technischer Anforderungen
                abgedeckt werden, die einen zuverlässigen Betrieb überhaupt erst möglich machen. Neben einer
                zentralen Benutzer- und Berechtigungsverwaltung gehören hierzu die Überwachung des laufenden
                Betriebs und viele mehr. {detail-content}

                In traditionellen, monolithischen Anwendungen müssen derartige Funktionen entweder selbst
                entwickelt oder durch entsprechende Frameworks bzw. Applikationsserver bereitgestellt werden.
                Entsprechend groß und schwergewichtig fallen diese aus. Microservices haben hingegen den Vorteil,
                diese unterstützenden Services von anderen Microservices „out-of-process“ konsumieren zu können.
                Oft kommen dabei Drittprodukte von spezialisierten Anbietern oder die Plattformservices¹ der
                großen Cloudanbieter zum Einsatz, die hierfür lediglich über speziell hierfür bereitgestellte
                Code-Bibliotheken in die eigene Anwendung integriert werden müssen. {detail-content}

                <lsx-tab-pages>
                    <lsx-tab-page title="Beispiel-Architektur">
                        <img src="02-architektur/fallbeispiel-naas-planes.png" class="d-block w-100 mt-4" />
                    </lsx-tab-page>
                    <lsx-tab-page title="Service-Arten">
                        <img src="02-architektur/fallbeispiel-naas-services.png" class="d-block w-100 mt-4" />
                    </lsx-tab-page>
                    <lsx-tab-page title="Service Mesh">
                        <img src="02-architektur/fallbeispiel-naas-mesh.png" class="d-block w-100 mt-4" />
                    </lsx-tab-page>
                </lsx-tab-pages>

                Das obige Beispiel zeigt eine typische Architektur, bei welcher die nicht-funktionalen
                Anforderungen durch zusätzliche von der Plattform bereitgestellte Microservices abgedeckt werden. {detail-content}

                ¹
                <small>
                    Der Begriff „Plattform” steht sinnbildlich für alles, was für Entwicklung und Betrieb einer
                    Anwendung vorab gegeben sein muss. Plattformservices sind daher von den Cloudanbietern gegen
                    Bezahlung bereitgestellte Funktionen zur Unterstützung der in der jeweiligen Cloudumgebung
                    ausgeführten Anwendungen. Beispiele hierfür können Authentifikationsserver, Monitoring-Angebote,
                    Proxy-Server uvm. sein.
                </small> {detail-content}
            </div>
        </article>
    </section>

    <section data-title="Zwei-Faktor-Authentifizierung ja oder nein?">
        <article class="centered-content">
            <div style="max-width: 40em;">
                <img src="02-architektur/ct-schlagseite-2fa.jpg" class="d-block w-100" alt="Jeden Tag verschwindet einer …">

                <small>
                    <small>
                        Bildnachweis:
                        <a href="https://www.heise.de/select/ct/2022/11/2200714175714756235" target="_blank">c't 11/2022, S. 13 (Schlagseite)</a>
                    </small>
                </small>
            </div>
        </article>
    </section>

    <section data-title="Überwachung von Microservices">
        <article class="centered-content">
            <div>
                <div class="markdown limited-width m-auto mb-5">
                    Typische Services in der **Kontrollebene** sind jene zur Überwachung des laufenden
                    Betriebs einer verteilten Anwendung. Diese unterteilen sich typischerweise in:

                    * **Metriken:**: Kennzahlen wie Speicherverbrauch, Anzahl Requests je Sekunde, CPU-Auslastung, ...
                    * **Logging:** Protokollausgaben der einzelnen Services, um Fehler nachvollziehen zu können
                    * **Tracing:** Nachverfolgung von Aufrufketten, um komplexe Fehlersituationen analysieren zu können
                </div>
                <div class="d-flex align-items-stretch" style="gap: 1em;">
                    <img src="02-architektur/metriken.png" class="d-block w-100 img-thumbnail" />
                    <img src="02-architektur/logging.png" class="d-block w-100 img-thumbnail" />
                    <img src="02-architektur/tracing.png" class="d-block w-100 img-thumbnail" />
                </div>
            </div>
        </article>
    </section>

    <!-- TODO: Quellcode anpassen, dann hier freischalten und Beschreibung ergänzen -->
    <!--
    <section data-title="Fallbeispiel: Webflicks">
        <article class="centered-content">
            <div>
                <div class="mb-3">
                    <lsx-github-edit
                        url="Beispiele/Webflicks"></lsx-github-edit>
                </div>

                <div class="d-flex flex-column flex-md-row gap-3">
                    <img src="02-architektur/beispiel-webflicks-1.png" class="img-thumbnail d-block w-100">
                    <img src="02-architektur/beispiel-webflicks-2.png" class="img-thumbnail d-block w-100">
                    <img src="02-architektur/beispiel-webflicks-3.png" class="img-thumbnail d-block w-100">
                </div>
            </div>
        </article>
    </section>
    -->
</section>

<section data-title="Das Cloud-Betriebsmodell">
    <section data-title="Die Cloud aus Konsumentensicht">
        <article class="centered-content">
            <div class="limited-width2">
                <img src="02-architektur/cloud-storage.png" class="d-block w-100 mb-5">

                <div class="d-flex flex-column flex-md-row gap-2">
                    <img src="02-architektur/cat1.jpg" class="d-block w-100 img-thumbnail">
                    <img src="02-architektur/cat2.jpg" class="d-block w-100 img-thumbnail">
                    <img src="02-architektur/cat3.jpg" class="d-block w-100 img-thumbnail">
                    <img src="02-architektur/cat4.jpg" class="d-block w-100 img-thumbnail">
                </div>

                <small>
                    <small>
                        Zitat gefunden auf:
                        <a href="https://docs.kraudcloud.com/technology/storage/" target="_blank">kraudcloud.com</a>, <br>

                        Bildnachweise:
                        <a href="https://pixabay.com/photos/cat-pet-licking-animal-tabby-cat-323262/" target="_blank">Pixabay: TeamK</a>,
                        <a href="https://pixabay.com/photos/cat-kitten-pets-animals-housecat-2934720/" target="_blank">Pixabay: Kirgiz03</a>,
                        <a href="https://pixabay.com/photos/cat-siamese-cat-fur-kitten-2068462/" target="_blank">Pixabay: webandi</a>,
                        <a href="https://pixabay.com/photos/cat-tired-yawn-stretch-814952/" target="_blank">Pixabay: jonathansautter</a>
                    </small>
                </small>
            </div>
        </article>
    </section>

    <section data-title="Abgrenzung von typischen Onlinediensten">
        <article class="centered-content">
            <div class="limited-width2">
                <div class="markdown mb-4" detail-content>
                    Anwendungen zum Synchronisieren von Dateien wie Dropbox, OneDrive oder Owncloud
                    werden umgangssprachlich oft als Cloud bezeichnet. Man sagt, dass die Dateien
                    _mit der Cloud synchronisiert_ werden. Dies ist jedoch problematisch, da „Cloud”
                    hier lediglich sinnbildlich für einen irgendwie gearteten Onlinedienst steht.
                    Hinzu kommt, dass zumindest Owncloud gar keine Cloud-Anwendung ist, sondern eine
                    in PHP implementierte, traditionelle Webanwendung. Nach dieser Definition müsste
                    demnach jede Webanwendung auch eine Cloud-Anwendung sein.
                </div>

                <lsx-grid-fluid class="p-0">
                    <lsx-row>
                        <lsx-col size="md">
                            <img src="02-architektur/dropbox-screenshot.png" class="d-block img-thumbnail" style="height: 100%;"/>
                        </lsx-col>
                        <lsx-col size="md">
                            <img src="02-architektur/owncloud-screenshot.png" class="d-block img-thumbnail" style="height: 100%;"/>
                        </lsx-col>
                    </lsx-row><lsx-row>
                        <lsx-col size="md">
                            <img src="02-architektur/owncloud-quellcode.png" class="d-block img-thumbnail" style="height: 100%;"/>
                        </lsx-col>
                        <lsx-col size="md">
                            <img src="02-architektur/owncloud-installation.png" class="d-block img-thumbnail" style="height: 100%;"/>
                        </lsx-col>
                    </lsx-row>
                </lsx-grid-fluid>
            </div>
        </article>
    </section>

    <section data-title="Abgrenzung von klassischem Hosting">
        <article class="centered-content">
            <div class="limited-width2">
                <div class="markdown mb-4" detail-content>
                    Schon früher war es insbesondere für kleinere Unternehmen üblich, die Hardware zur
                    Bereitstellung eines Onlinedienstes nicht selbst zu betreiben. Dieses Modell wird
                    Hosting genannt, da der Anbieter zwar die Hardwareplattform (den Host) zur Verfügung
                    stellt, Installation und Betrieb der Anwendung aber immer noch selbst vorgenommen
                    werden müssen.
                </div>

                <div class="d-flex gap-3 flex-column flex-md-row">
                    <div class="card flex-grow-1 w-100">
                        <img src="02-architektur/hosting-dedicated.jpg" class="card-img-top">
                        <div class="card-header border-top fw-bold">
                            Dedicated Root Server
                        </div>
                        <div class="card-body markdown small">
                            Hier vermietet der Anbieter einen dedizierten Computer an den Kunden.
                            Installation und Einrichtung müssen, sofern es kein „managed” Angebot
                            mit zusätzlicher Dienstleistung ist, aus der Ferne selbst erledigt werden.
                            Im Gegenzug können jedes beliebige Betriebsystem und jede Software
                            aufgespielt werden.
                        </div>
                    </div>

                    <div class="card flex-grow-1 w-100">
                        <img src="02-architektur/hosting-vserver.png" class="card-img-top">
                        <div class="card-header border-top fw-bold">
                            Virtual Private Server
                        </div>
                        <div class="card-body markdown small">
                            Hier steht eine virtuelle Maschine zur Verfügung, die sich weitgehend wie
                            dedizierte Hardware nutzen lässt. Die Ressourcen können jedoch geringer
                            ausfallen, da die Hardware von vielen Kunden geteilt wird. Die Installation
                            eines eigenen Betriebssystems kann ebenfalls mit Einschränkungen verbunden sein.
                        </div>
                    </div>

                    <div class="card flex-grow-1 w-100">
                        <img src="02-architektur/hosting-web.png" class="card-img-top">
                        <div class="card-header border-top fw-bold">
                            Web Hosting
                        </div>
                        <div class="card-body markdown small">
                            Hier wird lediglich der Webserver virtualisiert und etwas Speicherplatz in
                            einer vorkonfigurierten Serverfarm angeboten. Die Einstellungsmöglichkeiten
                            sind sehr begrenzt und oft auf traditionelle Webanwendungen mit PHP als
                            Programmiersprache und MariaDB als Datenbank zugeschnitten.
                        </div>
                    </div>
                </div>

                <small>
                    <small>
                        ¹ Bildnachweis:
                        <a href="https://pixabay.com/photos/technology-servers-server-1587673/" target="_blank">Pixabay: heladodementa</a>
                    </small>
                </small>
            </div>
        </article>
    </section>

    <section data-title="Grundidee der Cloud">
        <article>
            <lsx-grid-fluid class="p-0">
                <lsx-row>
                    <lsx-col size="md-9" class="mb-3">
                        <img src="02-architektur/cloud-betriebsmodell.png" class="d-block w-100" />
                    </lsx-col>
                    <lsx-col size="md" class="d-flex flex-column gap-3">
                        <lsx-card title="Automatisierung" bold class="markdown small">
                            Die Grundidee der Cloud ist, die Bereitstellung und den Betrieb verteilter
                            Anwendungen so weit wie möglich zu automatisieren. Eine Cloudumgebung besteht
                            daher aus einem großen Rechencluster, dessen Ressourcen auf viele Anwendungen
                            aufgeteilt werden. Manuelle Installationsschritte sollen vermieden werden.
                            {.mb-0}
                        </lsx-card>

                        <lsx-card title="Isolation" bold class="markdown small">
                            Die physischen und virtuellen Maschinen sowie Speicherressourcen einer Cloudumgebung
                            werden vollständig abstrahiert, wodurch jede Anwendung einen eigenen, **virtuellen
                            Computercluster** erhält. Häufig (aber nicht immer) wird dabei auch das Netzwerk
                            virtualisiert, wodurch interne Services in einem **privaten Netzwerk** vor öffentlichen
                            Zugriffen geschützt werden können.
                            {.mb-0}
                        </lsx-card>

                        <lsx-card title="Skalierung und Elastizität" bold class="markdown small">
                            **Skalierung** beschreibt die Anpassung der zur Verfügung gestellten Ressourcen
                            entsprechend dem Leistungsbedarf einer Anwendung. Beim klassischen Hosting und
                            bei sehr einfachen Cloud-Installationen ist dies nur durch manuelles Eingreifen
                            möglich. Echte Cloud-Anwendungen sind jedoch **elastisch**, so dass der Cluster
                            die Ressourcen automatisch skalieren kann.
                            {.mb-0}
                        </lsx-card>

                        <lsx-card title="Variable Kosten" bold class="markdown small">
                            Aufgrund der dynamischen Ressourcenzuteilung bieten viele Cloud-Angebote eine
                            **nutzungsabhängige Abrechnung**, die sich nach Anzahl der tatsächlich genutzten
                            Minuten zur Ausführung von Programmcode, tatsächlich belegtem Speicherplatz
                            oder Netzwerktraffic richtet. Im Vergleich zu klassischem Hosting fallen die
                            durchschnittlichen Kosten daher oft geringer aus.
                            {.mb-0}
                        </lsx-card>
                    </lsx-col>
                </lsx-row>
            </lsx-grid-fluid>
        </article>
    </section>

    <section data-title="Pet vs. Cattle">
        <article class="centered-content">
            <div class="limited-width2">
                <div class="d-flex gap-3 flex-column flex-md-row">
                    <div class="card flex-grow-1 w-100">
                        <img src="02-architektur/pet-vs-cattle-1.jpg" class="card-img-top">
                        <div class="card-header border-top fw-bold">
                            Hosting
                        </div>
                        <div class="card-body small">
                            Die Software wird gehegt und gepflegt wie ein Haustier.
                        </div>
                    </div>

                    <div class="card flex-grow-1 w-100">
                        <img src="02-architektur/pet-vs-cattle-2.jpg" class="card-img-top">
                        <div class="card-header border-top fw-bold">
                            Cloud
                        </div>
                        <div class="card-body small">
                            Die Software wird wie Vieh in der Massentierhaltung behandelt.
                        </div>
                    </div>
                </div>

                <small>
                    <small>
                        Bildnachweise:
                        <a href="https://pixabay.com/photos/children-dog-pet-cute-footwear-1866531/" target="_blank">Pixabay: Pexels</a>,
                        <a href="https://pixabay.com/photos/sheeps-animals-mammals-live-stock-6828766/" target="_blank">Pixabay: smoms_photography</a>
                    </small>
                </small>
            </div>
        </article>
    </section>

    <section data-title="Das As-a-Service-Geschäftsmodell">
        <article class="centered-content">
            <div class="limited-width2">
                <div class="markdown mt-3 mb-5" detail-content>
                    Cloudangebote werden häufig mit dem Namenszusatz „as-a-Service” angeboten,
                    wie beispielsweise „Database-as-a-Service“ oder „Software-as-a-Service".
                    Damit ist gemeint, dass die jeweilige Software **nicht klassisch lizenziert,
                    sondern als Dienstleistung** vermarktet wird. Installation, Betrieb und Pflege
                    werden fallen in die Verantwortung des Anbieters, wodurch diese aus Kundensicht
                    komplett ausgelagert werden können.
                </div>

                <div class="d-flex gap-3 flex-column flex-md-row mb-4">
                    <div class="flex-grow-1 w-100 markdown small">
                        ### Infrastructure-as-a-Service {.mb-3}

                        <img src="02-architektur/modelle-iaas.png" class="w-100 mb-3">

                        Im einfachsten Fall stellt die Cloud virtuelle Maschinen zur manuellen Einrichtung
                        sowie dazugehörige Dienste wie Objektspeicher und Netzwerkrouting zur Verfügung.
                        Lediglich die Bereitstellung aus Sicht des Cloudanbieters wird dabei automatisiert.
                    </div>
                    <div class="flex-grow-1 w-100 markdown small">
                        ### Platform-as-a-Service {.mb-3}

                        <img src="02-architektur/modelle-paas.png" class="w-100 mb-3">

                        Auf die Entwicklung von Cloudanwendungen zugeschnittene Angebote bieten eine
                        vorkonfigurierte Laufzeitumgebung für selbstgeschriebenen Quellcode. Deployment
                        und Betrieb werden weitgehend automatisiert. Es besteht jedoch die Gefahr von
                        Vendor Lock-In aufgrund der Verwendung anbieterspezifischer Bibliotheken.
                    </div>
                    <div class="flex-grow-1 w-100 markdown small">
                        ### Software-as-a-Service {.mb-3}

                        <img src="02-architektur/modelle-saas.png" class="w-100 mb-3">

                        Am weitesten abstrahiert sind SaaS-Angebote zur Bereitstellung ganzer Anwendungspakete.
                        Als Kunde registriert man sich lediglich für eine Anwendung, die gegen eine monatliche
                        Gebühr zur Verfügung gestellt wird. Alle Kunden teilen sich meist den Quellcode, während
                        die Daten getrennt werden.
                    </div>
                </div>

                <div class="markdown" detail-content>
                    Angebote wie **Function-as-a-Service** (auch **Serverless** genannt, da die Verwaltung von Serverinstanzen komplett
                    wegabstrahiert wird) oder **Database-as-a-Service** richten ebenfalls an Anwendungsentwickler und zählen deshalb zu
                    Platform-as-a-Service.

                    Die großen Anbieter wie Amazon, Google oder Microsoft bieten grundsätzlich eine Mischung aus allen Modellen, während
                    sich kleinere Anbieter wie [Heroku](https://heroku.com/){target="_blank"}, [Render](https://render.com/){target="_blank"},
                    [Fly.io](https://fly.io/){target="_blank"} meist auf Plattformdienste beschränken.
                    [MongoDB Atlas](https://www.mongodb.com/de-de/atlas){target="_blank"}, [Auth0](https://auth0.com/){target="_blank"}
                    und viele mehr zielen hingegen auf ganz spezielle Anwendungsfälle ab.
                </div>
            </div>
        </article>
    </section>

    <section data-title="Vertiefende Videos" class="centered-content">
        <div class="limited-width2">
            <lsx-grid-fluid>
                <lsx-row>
                    <lsx-col size="md">
                        <lsx-youtube video="_epyprLse_4" aspect-ratio="16x9" class="w-100"></lsx-youtube>
                        <a href="https://youtu.be/_epyprLse_4" target="_blank">Link zum Video</a>
                    </lsx-col>
                    <lsx-col size="md">
                        <lsx-youtube video="Q7580888ce4" aspect-ratio="16x9" class="w-100"></lsx-youtube>
                        <a href="https://youtu.be/Q7580888ce4" target="_blank">Link zum Video</a>
                    </lsx-col>
                </lsx-row>
            </lsx-grid-fluid>

            <lsx-info-box type="warning" class="mt-3">
                Die Videos beziehen sich an manchen Stellen noch auf die Entwicklung mit Java und
                dem Spring-Framework. Auch wenn wir inzwischen Node.js/JavaScript in der Vorlesung
                verwenden, sind die Grundprinzipien jedoch dieselben.
            </lsx-info-box>
        </div>
    </section>
</section>

<section data-title="Übungsaufgaben" data-background-color="rgb(231, 221, 141)">
    <section data-title="Aufgabe 1: Ein kleines Cloud-Quiz">
        <article>
            <lsx-tab-pages>
                <lsx-tab-page title="Aufgabe 1.1">
                    <lsx-quiz>
                        <lsx-exercise title="Monolith vs. Microservice">
                            <lsx-question
                                type = "multiple-choice"
                                text = "a) Welche der folgenden Aussagen treffen auf monolithische Anwendungen zu?"
                            >
                                <lsx-answer correct>Ein einzelner Server beinhaltet einen Großteil der Anwendungslogik.</lsx-answer>
                                <lsx-answer>Die Entwicklung erfolgt mit speziellen hierfür vorgesehenen Frameworks.</lsx-answer>
                                <lsx-answer correct>Monolithische Anwendungen lassen sich oft weniger gut skalieren.</lsx-answer>
                                <lsx-answer correct>Monolithen besitzen oft einen über Jahre gewachsenen Umfang.</lsx-answer>
                            </lsx-question>

                            <lsx-question
                                type = "multiple-choice"
                                text = "b) Welche Vorteile haben Microservices gegenüber monolithischen Anwendungen?"
                            >
                                <lsx-answer>Die Gesamtarchitektur der Anwendung lässt sich deutlich vereinfachen.</lsx-answer>
                                <lsx-answer correct>Microservices können getrennt voneinander entwickelt und deployed werden.</lsx-answer>
                                <lsx-answer correct>Für jeden Microservice kann die am besten geeignete Technologie gewählt werden.</lsx-answer>
                                <lsx-answer correct>Eine Microservice-Anwendung kann wesentlich bedarfsgerechter skaliert werden.</lsx-answer>
                            </lsx-question>

                            <lsx-question
                                type = "multiple-choice"
                                text = "c) Welche Nachteile können Microservices gegenüber Monolithen haben?"
                            >
                                <lsx-answer correct>Microservices können für kleine Entwicklerteams schwer zu handhaben sein.</lsx-answer>
                                <lsx-answer>Microservices setzen besonders leistungsfähige Hardware voraus.</lsx-answer>
                                <lsx-answer correct>Die Programmierung wird durch die vielen Service-Schnittstellen eher komplexer.</lsx-answer>
                                <lsx-answer>Ältere Programmiersprachen und Bibliotheken eignen sich nicht für ihre Entwicklung.</lsx-answer>
                            </lsx-question>

                            <lsx-question
                                type = "single-choice"
                                text = "d) Was ist eine so genannte „Sticky Session”?"
                            >
                                <lsx-answer correct>Sie sorgt dafür, dass alle Anfragen eines Clients von derselben Serverinstanz bearbeitet werden.</lsx-answer>
                                <lsx-answer>Sie sorgt dafür, dass alle Antworten einer Servierinstanz an denselben Client geschickt werden.</lsx-answer>
                                <lsx-answer>Sie sorgt dafür, dass ein Server nach einem Absturz automatisch neugestartet wird.</lsx-answer>
                            </lsx-question>

                            <lsx-question
                                type = "multiple-choice"
                                text = "e) Welche Gründe sprechen dafür, den Sitzungszustand clientseitig zu speichern?"
                            >
                                <lsx-answer correct>Die Serverseite kann komplett zustandslos gehalten werden.</lsx-answer>
                                <lsx-answer correct>Clientseitig bringt die Verwaltung des Sitzungszustands keine Nachteile.</lsx-answer>
                                <lsx-answer>Dadurch müssen serverseitig keine Daten persisteirt werden.</lsx-answer>
                                <lsx-answer correct>Insgesamt kann die Anwendung einfacher skaliert werden.</lsx-answer>
                            </lsx-question>

                            <lsx-question
                                type = "single-choice"
                                text = "f) Wie sollte die Kommunikation zwischen Frontend und Backend gestaltet sein?"
                            >
                                <lsx-answer>Möglichst viele Anfragen mit geringem Datenvolumen vom Frontend an das Backend.</lsx-answer>
                                <lsx-answer correct>Möglichst wenige Anfragen verschicken, die dafür ggf. größer ausfallen können.</lsx-answer>
                            </lsx-question>
                        </lsx-exercise>
                    </lsx-quiz>
                </lsx-tab-page>

                <lsx-tab-page title="Aufgabe 1.2">
                    <lsx-quiz>
                        <lsx-exercise title="Microservices im Detail">
                            <lsx-question
                                type = "single-choice"
                                text = "a) Welches Architekturmuster steckt hinter der Implementierung eine API-Gateways?"
                            >
                                <lsx-question-line>
                                    <lsx-answer>Drei-Schichten</lsx-answer>
                                    <lsx-answer>Vier-Schichten</lsx-answer>
                                    <lsx-answer correct>Reverse Proxy</lsx-answer>
                                    <lsx-answer>Forward Proxy</lsx-answer>
                                </lsx-question-line>
                            </lsx-question>

                            <lsx-question
                                type = "multiple-choice"
                                text = "b) Welche Aufgaben können durch ein API-Gateway typischerweise erbracht werden?"
                            >
                                <lsx-answer>Performance-Optimierung</lsx-answer>
                                <lsx-answer>Automatische Skalierung der Server</lsx-answer>
                                <lsx-answer>Verhindern von Verbiungsfehlern</lsx-answer>
                                <lsx-answer correct>Verschattung der Backend-Strukturen</lsx-answer>
                                <lsx-answer correct>Benutzerauthentifizierung</lsx-answer>
                                <lsx-answer correct>Bereitstellung statischer Web-Inhalte</lsx-answer>
                            </lsx-question>

                            <lsx-question
                                type = "multiple-choice"
                                text = "c) Welche Probleme werden hingegen eher durch ein Service-Mesh gelöst?"
                            >
                                <lsx-answer correct>Kommunikation zwischen den Services</lsx-answer>
                                <lsx-answer correct>Regelmäßige Health Checks der Services</lsx-answer>
                                <lsx-answer correct>Unterstützung bei der Überwachung der Services</lsx-answer>
                                <lsx-answer>Implementierung von Sicherheitsmechanismen</lsx-answer>
                            </lsx-question>

                            <lsx-question
                                type = "single-choice"
                                text = "d) Welches Sicherheitskonzept steckt hinter dem Begriff Zwei-Faktor-Authentifizierung?"
                            >
                                <lsx-answer>Zwei Passwörter sind sicherer als eines.</lsx-answer>
                                <lsx-answer>Lange Passwörter sind sicherer als kürzere.</lsx-answer>
                                <lsx-answer correct>Kombination mehrerer Authentifizierungsmethoden.</lsx-answer>
                            </lsx-question>

                            <lsx-question
                                type         = "assignment"
                                text         = "e) Ordnen Sie den folgenden Begriffen die richtige Bedeutung zu?"
                                label-length = "10em"
                                select-style = "background: rgb(228, 229, 230);"
                            >
                                <lsx-assignment answer="Feststellung der Benutzeridentität">Authentifizierung</lsx-assignment>
                                <lsx-assignment answer="Durchsetzung von Zugriffsberechtigungen">Authorisierung</lsx-assignment>
                            </lsx-question>

                            <lsx-question
                                type         = "assignment"
                                text         = "f) Welchen Zweck erfüllen die folgenden Arten, die Betrieb von Microservices zu überwachen?"
                                label-length = "10em"
                                select-style = "background: rgb(228, 229, 230);"
                            >
                                <lsx-assignment answer="Kennzahlen aus dem laufenden Betrieb ermitteln">Metriken</lsx-assignment>
                                <lsx-assignment answer="Auftretende Ereignisse im zeitlichen Verlauf protokollieren">Logging</lsx-assignment>
                                <lsx-assignment answer="Kommunikationsabläufe zwischen den Services aufzeichnen">Tracing</lsx-assignment>
                            </lsx-question>
                        </lsx-exercise>
                    </lsx-quiz>
                </lsx-tab-page>

                <lsx-tab-page title="Aufgabe 1.3">
                    <lsx-quiz>
                        <lsx-exercise title="Cloudanwendungen">
                            <lsx-question
                                type = "single-choice"
                                text = "a) Welche Beschreibung entspricht am ehesten der Grundidee der Cloud?"
                            >
                                <lsx-answer>Synchronisation von Dateien zwischen mehreren Geräten</lsx-answer>
                                <lsx-answer>Bereitstellung von Rechenleistung für manuell installierte Anwendungen</lsx-answer>
                                <lsx-answer correct>Weitgehende Automatisierung des Betriebs verteilter Anwendungen</lsx-answer>
                            </lsx-question>

                            <lsx-question
                                type = "single-choice"
                                text = "b) Eine Webanwendung wird händisch auf einer Maschine installiert."
                            >
                                <lsx-question-line>
                                    <lsx-answer correct>Pet</lsx-answer>
                                    <lsx-answer>Cattle</lsx-answer>
                                </lsx-question-line>
                            </lsx-question>

                            <lsx-question
                                type = "single-choice"
                                text = "c) Warum werden Webanwendungen von Laien häufig als Cloudanwendungen bezeichnet?"
                            >
                                <lsx-answer correct>Da die technischen Unterschiede für Laien meist nicht offensichtlich sind.</lsx-answer>
                                <lsx-answer>Weil Cloudanwendungen anfangs tatsächlich überwiegend Webanwendungen waren.</lsx-answer>
                                <lsx-answer>Weil die Begriffe Rechenzentrum und Cloud weitgehend identische Bedeutungen besitzen.</lsx-answer>
                            </lsx-question>

                            <lsx-question
                                type = "multiple-choice"
                                text = "d) Welches sind typische Eigenschaften eines klassischen Hosting-Angebots?"
                            >
                                <lsx-answer correct>Statisch zugewiesene Computerressourcen</lsx-answer>
                                <lsx-answer correct>Manuelle Inbetriebnahme und Installation</lsx-answer>
                                <lsx-answer>Variable nutzungsorientierte Kosten</lsx-answer>
                                <lsx-answer>Automatisierte, vertikale Skalierung</lsx-answer>
                                <lsx-answer correct>Backups meist in Kundenverantwortung</lsx-answer>
                            </lsx-question>

                            <lsx-question
                                type = "multiple-choice"
                                text = "e) Welches sind typische Eigenschaften des Cloud-Betriebs?"
                            >
                                <lsx-answer>Administration via Mobile Apps</lsx-answer>
                                <lsx-answer correct>Weitreichende Automatisierung</lsx-answer>
                                <lsx-answer correct>Skalierbarkeit der bereitgestellten Ressourcen</lsx-answer>
                                <lsx-answer>Händische Konfiguration virtueller Maschinen</lsx-answer>
                                <lsx-answer correct>Nutzungsabhängige Kostenabrechnung</lsx-answer>
                                <lsx-answer>Statisch zugewiesene Speicherkapazität</lsx-answer>
                            </lsx-question>

                            <lsx-question
                                type            = "assignment"
                                text            = "f) Ordnen Sie den nachfolgenden Angebotsbeschreibungen den richtigen Namen zu."
                                label-length    = "100%"
                                select-position = "below"
                                select-style    = "background: rgb(228, 229, 230);"
                            >
                                <lsx-assignment answer="Platform-as-a-Service">
                                    Auf die Entwicklung von Cloudanwendungen zugeschnittene Angebote bieten eine vorkonfigurierte Laufzeitumgebung für selbstgeschriebenen Quellcode.
                                </lsx-assignment>
                                <lsx-assignment answer="Infrastructure-as-a-Service">
                                    Bereitstellung virtueller Rechenleistung, Speicherkapazität und Netzressourcen durch die Cloud. Anwendungen müssen jedoch manuell deployed werden.
                                </lsx-assignment>
                                <lsx-assignment answer="Software-as-a-Service">
                                    Bereitstellung ganzer Anwendungspakete meist gegen eine variable, nutzungsabhängige Montatsgebühr. Keine sonstigen Aufwendungen auf Kundenseite.
                                </lsx-assignment>
                            </lsx-question>
                        </lsx-exercise>
                    </lsx-quiz>
                </lsx-tab-page>
            </lsx-tab-pages>
        </article>
        <aside>
            <p>
                Wie immer an dieser Stelle ein kleines Quiz zur Wiederholung der wichtigsten Begriffe.
                Schaffen Sie es, alle Fragen richtig zu beantworten?
            </p>
            <img src="shared/quiz.png" class="img-fluid d-block" style="max-width: 20em;"/>
            <p>
                <small>
                    Bildnachweis:
                    <a href="https://pixabay.com/illustrations/quiz-tiles-letters-red-game-test-2058883/" target="_blank">Pixabay: 905513</a>
                </small>
            </p>
        </aside>
    </section>

    <section data-title="Aufgabe 2: Notebook-as-a-Service">
        <article>
            <div class="mb-4">
                <lsx-github-edit url="Beispiele/Notebook-as-a-Service"></lsx-github-edit>
            </div>

            <img src="02-architektur/naas-screenshot1.png" class="img-thumbnail d-block w-100 mb-4" alt="Weboberfläche">

            <lsx-tab-pages>
                <lsx-tab-page title="Beschreibung" class="markdown">
                    Das Notebook-as-a-Service-Beispiel wurde auf den vorangegangenen Seiten immer wieder als
                    Fallbeispiel für eine Microservice-Architektur vorgestellt. In Einklang damit besteht der
                    Quellcode aus folgenden Teilanwendungen:

                    * __Frontend-Server (Port 8000):__ Dient als einfacher Webserver, der die clientseitig benötigten
                    HTML, CSS und JavaScript-Dateien zur Verfügung stellt. Serverseitig gibt es keine Logik,
                    obwohl dies im Sinne des „Backend for Frontend“ (BFF) Architekturansatzes durchaus
                    möglich wäre.

                    * __API-Gateway (Port 8010):__ Dies ist ein einfacher HTTP Reverse Proxy, der die Backendservices
                    nach außen hin verschattet. Die Backend-Server können dadurch über eine einheitliche
                    URL aufgerufen werden, ohne die genaue Backendstruktur kennen zu müssen. Im Idealfall
                    sorgt die Ausführumgebung durch ein virtuelles, privates Netzwerk sogar dafür, dass
                    die Backendservices aus dem öffentlichen Internet gar nicht erreichbar sind.

                    * __Katalog-Backend (Port 8020):__ Stellt eine einfache Datenbank für den Produktkatalog zur Verfügung.
                    In der Beispielanwendung verwaltet dieser Service die ausleihbaren Geräte.

                    * __Auftrags-Backend (Port 8030):__ Wickelt den Bestellvorgang ab und verwaltet die Bestellungen
                    in seiner eigenen kleinen Datenbank. Kommuniziert hierfür mit dem Katalog-Backend,
                    um zu prüfen, ob die bestellten Geräte tatsächlich vorhanden sind.
                </lsx-tab-page>

                <lsx-tab-page title="Start der Services">
                    <p>
                        Der Einfachheit halber sind alle Services in Node.js mit dem
                        <a href="http://expressjs.com/" target="_blank">Express-Framework</a>
                        realisiert. Somit wird nur Node.js benötigt, um die Anwendung auszuführen.
                        Hierfür müssen zunächst im Hauptverzeichnis und in den Unterverzeichnissen
                        die Node-Module installiert werden. Am einfachsten geht dies mit folgenden
                        Befehlen:
                    </p>
                    <source-code language="sh">
                        # Installation der Node-Module im Hauptverzeichnis
                        npm install

                        # Installation der Node-Module der einzelnen Services
                        npm run install
                    </source-code>
                    <p>
                        Danach können die Services in beliebiger Reihenfolge gestartet werden. Im Hauptverzeichnis kann hierfür
                        einfach <code>npm start</code> eingegeben werden. Dadurch starten alle Server parallel und teilen sich
                        das Konsolenfenster für ihre Ausgaben. Für die späteren Versuche sollte jedoch jeder Service in seinem
                        eigenen Terminalfenster gestartet werden.
                    </p>
                </lsx-tab-page>

                <lsx-tab-page title="Aufgabenstellung">
                    <p>
                        In dieser Aufgabe geht es nicht darum, den Quellcode zu verstehen, auch wenn Sie natürlich
                        gerne reinschauen können. Viel mehr sollen Sie die untenstehenden Versuche ausführen, um eine
                        Microservice-Architektur mit API-Gateway und Load Balancing praktisch kennenzulernen. Versuchen
                        Sie dabei auch die Verständnisfragen zu beantworten.
                    </p>

                    <lsx-accordion>
                        <lsx-accordion-page title="<b>Schritt 1:</b>&nbsp; Services starten">
                            <p>
                                Führen Sie im Hauptverzeichnis des Beispiels den Befehl <code>npm start</code> aus,
                                um alle Services zu starten. Beobachten Sie dabei die Konsolenausgaben.
                            </p>
                            <lsx-info-box>
                                Woran erkennen Sie, welche Protokollzeile zu welchem Service gehört?
                            </lsx-info-box>
                        </lsx-accordion-page>

                        <lsx-accordion-page title="<b>Schritt 2:</b>&nbsp; Webanwendung testen">
                            <p>
                                Rufen Sie nun die Adresse <a href="http://localhost:8000" target="_blank">http://localhost:8000</a>
                                im Browser auf, um die Anwendung zu testen. Spielen Sie den Ausleihprozess einmal komplett durch und
                                beobachten Sie die Protokollausgaben im Konsolenfenster.
                            </p>
                            <lsx-info-box>
                                Welche Aktionen führen zu einer Anfrage an das API-Gateway und welche zu einer Anfrage an
                                den Frontend-Server?
                            </lsx-info-box>
                        </lsx-accordion-page>

                        <lsx-accordion-page title="<b>Schritt 3:</b>&nbsp; Backend-Services testen">
                            <p>
                                Rufen Sie nun die Adressen <a href="http://localhost:8020" target="_blank">http://localhost:8020</a> und
                                <a href="http://localhost:8030" target="_blank">http://localhost:8030</a> im Browser auf, um die beiden
                                Backend-Services in Isolation zu testen. Klicken Sie auf die Links in der Übersichtsseite, um einfache
                                GET-Anfragen an die Services zu schicken.
                            </p>
                            <lsx-info-box>
                                Woran erkennen Sie, dass es sich um Webservices und keine Webanwendungen handelt?
                            </lsx-info-box>
                        </lsx-accordion-page>

                        <lsx-accordion-page title="<b>Schritt 4:</b>&nbsp; API-Gateway testen">
                            <p>
                                Rufen Sie nun die Adresse <a href="http://localhost:8010" target="_blank">http://localhost:8010</a> auf,
                                um die Services über das API-Gateway anzusprechen. Klicken Sie wieder auf die Links in der Übersichtsseite,
                                um ein paar GET-Anfragen an die Services zu schicken. Beobachten Sie dabei die Protokollausgaben im
                                Konsolenfenster.
                            </p>
                            <lsx-info-box>
                                Woher weiß das API-Gateway, an welchen Backendserver eine Anfrage weitergeleitet werden muss?
                            </lsx-info-box>
                            <lsx-info-box>
                                Wie ändert sich die URL bei einer erfolgreichen Weiterleitung?
                            </lsx-info-box>

                        </lsx-accordion-page>

                        <lsx-accordion-page title="<b>Schritt 5:</b>&nbsp; Routingregeln des API-Gateways">
                            <p>
                                Öffnen Sie die Datei <span class="fn">api-gateway/config/example.yml</span> in einem Editor und
                                versuchen Sie, diese nachzuvollziehen.
                            </p>
                            <lsx-info-box>
                                In wiefern bestätigen sich Ihre Antworten zum letzten Schritt hierdurch?
                            </lsx-info-box>
                        </lsx-accordion-page>

                        <lsx-accordion-page title="<b>Schritt 6:</b>&nbsp; Konfiguration anpassen">
                            <div class="markdown">
                                Schließen Sie sich in Zweiergruppen zusammen und versuchen Sie, die Services auf mehreren
                                Rechnern auszuführen. Kopieren Sie hierfür die Datei `api-gateway/config/example.yml`
                                nach `api-gateway/config/exercise.yml` und nehmen folgende Änderungen darin vor:

                                1. Kommentieren Sie in den Weiterleitungsregeln die weiteren Instanzen für den Katalog-Service
                                   ein. Es handelt sich um eine einfache Load-Balancing-Konfiguration, bei der alle Anfragen
                                   auf drei Backend-Instanzen aufgeteilt werden.

                                1. Passen Sie die Weiterleitungsregeln so an, dass die Backend-Services nicht auf `localhost`
                                   sondern auf einem fremden Rechner laufen. Ersetzen Sie das Wort `localhost` hierfür durch
                                   die IP-Adresse des fremden Rechners. Achten Sie jedoch darauf, die Portnummern beizubehalten!
                            </div>
                        </lsx-accordion-page>

                        <lsx-accordion-page title="<b>Schritt 7:</b>&nbsp; Ausführung auf mehreren Rechnern">
                            <div class="markdown">
                                Starten Sie nun auf dem eigenen Rechner Frontend und API-Gateway, und auf dem anderen Rechner
                                die Backend-Services:

                                <table>
                                    <tr>
                                        <td colspan="4"><b>Rechner 1</b>
                                    </tr>
                                    <tr>
                                        <td>
                                            Konsolenfenster 1
                                            <pre>cd frontend<br>npm start</pre>
                                        </td>
                                        <td>
                                            Konsolenfenster 2
                                            <pre>cd api-gateway<br>npm start:exercise</pre>
                                        </td>
                                        <td></td>
                                        <td></td>
                                    </tr>
                                    <tr>
                                        <td colspan="4"><b>Rechner 2</b>
                                    </tr>
                                    <tr>
                                        <td>
                                            Konsolenfenster 1
                                            <pre>cd catalogue-service<br>npm start</pre>
                                        </td>
                                        <td>
                                            Konsolenfenster 2
                                            <pre>cd catalogue-service<br>npm start1</pre>
                                        </td>
                                        <td>
                                            Konsolenfenster 3
                                            <pre>cd catalogue-service<br>npm start2</pre>
                                        </td>
                                        <td>
                                            Konsolenfenster 4
                                            <pre>cd order-service<br>npm start</pre>
                                        </td>
                                    </tr>
                                </table>

                                Im Gegensatz zu bisher sollten Sie auf dem zweiten Rechner nun drei Instanzen des
                                Katalog-Services laufen haben, die auf den Ports 8020, 8021 und 8022 aufrufbar sind.

                                **HINWEISE:** Wenn Sie Frontend und API-Gateway auf unterschiedlichen Rechnern laufen
                                lassen wollen, müssen Sie in der Datei `frontend/.env` die Zieladresse des API-Gateways
                                anpassen. Wenn Sie Katalog- und Auftrags-Service auf unterschiedlichen Rechnern
                                laufen lassen wollen, müssen Sie in der Datei `order-service/.env` die Zieladresse
                                des Katalog-Services anpassen.
                            </div>
                        </lsx-accordion-page>

                        <lsx-accordion-page title="<b>Schritt 8:</b>&nbsp; Neue Konfiguration testen">
                            <p>
                                Rufen Sie die Adresse <a href="http://localhost:8000" target="_blank">http://localhost:8000</a>
                                im Browser auf, um die Anwendung erneut zu testen. Spielen Sie den Bestellvorgang einmal komplett
                                durch. Es sollte zu keinen Fehlern kommen.
                            </p>
                            <lsx-info-box>
                                Welche Anfragen an den Katalogservice werden von welcher Instanz verarbeitet?
                            </lsx-info-box>
                        </lsx-accordion-page>

                        <lsx-accordion-page title="<b>Schritt 9:</b>&nbsp; Lastverteilung und Ausfallsicherheit">
                            <p>
                                Zum Schluss wollen wir noch die Ausfallsicherheit der Anwendung überprüfen. Denn zumindest
                                der Katalog-Service ist dreifach redundant ausgelegt. Öffnen Sie daher die Adresse
                                <a href="http://localhost:8010" target="_blank">http://localhost:8010</a> im Browser und
                                klicken Sie auf die Links, um ein paar Anfragen gegen den Katalog-Service zu schicken.
                                Beenden Sie dann nach und nach eine weitere Instanz des Katalogservices und schicken Sie
                                dann erneuut ein paar Anfragen über das API-Gateway.
                            </p>
                            <lsx-info-box>
                                Wie verhält sich das API-Gateway, wenn eine Instanz nicht erreicht werden kann?
                            </lsx-info-box>
                            <lsx-info-box>
                                Wie verhält sich das API-Gateway, wenn gar keine Instanz erreicht werden kann?
                            </lsx-info-box>
                            <lsx-info-box>
                                Was passiert, wenn eine Instanz später wieder verfügbar ist?
                            </lsx-info-box>
                        </lsx-accordion-page>
                    </lsx-accordion>
                </lsx-tab-page>
            </lsx-tab-pages>
        </article>
        <aside>
            <p>
                Auf den vorausgehenden Seiten wurde immer wieder eine Anwendung namens „Notebook-as-a-Service”
                als Beispiel für eine typische cloud-fähige Microservice-Architektur vorgestellt. Diese Anwendung
                gibt es wirklich. Zumindest als Beispiel in dieser Vorlesung, das Sie hier etwas erkunden sollen.
            </p>
            <img src="shared/github_atom.png" class="img-fluid d-block"/>
            <p>
                <small>
                    Bildnachweis:
                    <a href="https://atom.io/" target="_blank">Atom Webseite</a>
                </small>
            </p>
        </aside>
    </section>

    <!-- TODO Aufgabe 1 von Michael -->
    <!--
    <section data-title="Aufgabe 3: Wir programmieren einen Webserver">
        <article>
        </article>
        <aside>
            <p>
                In dieser Aufgabe wollen wir nochmal die Realisierung verteilter Systeme mit dem
                TCP/IP-Protokollstapel aufgreifen und verstehen, wie das Web auf technischer Ebene
                funktioniert. Hierfür nutzen wir die kennengelernten Sockets von Node.js, um ohne
                sonstige Hilfsmittel einen kleinen Webserver zu bauen.
            </p>
            <img src="shared/github_atom.png" class="img-fluid d-block"/>
            <p>
                <small>
                    Bildnachweis:
                    <a href="https://atom.io/" target="_blank">Atom Webseite</a>
                </small>
            </p>
        </aside>
    </section>
    -->
</section>

<!-- =============== -->
<!-- Gruppenarbeiten -->
<!-- =============== -->
<section data-use-template="teilkapitel" data-titel="Gruppenarbeiten"></section>

<section data-title="Aufgabe 1: Konzepte verteilter Systeme" data-background-color="rgb(179, 202, 223)">
    <article>
        <lsx-ul emoji="📕" class="mb-4">
            <li>Schließt euch ein kleine Gruppen zusammen und setzt euch an eine Tischinsel.</li>
            <li>Bearbeitet anschließend für ca. 10 Minuten eines der unten stehenden Themen.</li>
            <li>Anschließend präsenziert euer Ergebnis für ca. 5 Minuten euren Mitstudierenden.</li>
        </lsx-ul>

        <lsx-accordion>
            <lsx-accordion-page title="<b>Thema 1:</b>&nbsp;Das Client/Server-Modell in TCP/IP">
                <lsx-ul>
                    <li>
                        <p>
                            Lest euch die Seite über „Clients, Server und Peers“ hier im Skript durch. Alternativ lasst euch
                            die Begriffe von einem KI-Chatbot erklären. Verliert aber nicht zu viel Zeit dabei!
                        </p>
                    </li>
                    <li>
                        <p>
                            Versucht dann, die Aufgabe „Wir erkunden Streams und Sockets” auf zwei Rechnern zum Laufen zu bringen.
                            Ein Rechner soll den Client und der andere den Server ausführen.
                        </p>
                    </li>
                    <li>
                        <p>
                            Euer Ziel ist es, später das Beispiel vorführen und daran die Begriffe <i>Client</i>
                            und <i>Server</i> erklären zu können.
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>Bonusfrage:</b> Wie funktioniert der Verbindungsaufbau mit <code>SYN</code> und <code>ACK</code>
                            bei TCP/IP?
                        </p>
                    </li>
                </lsx-ul>
            </lsx-accordion-page>

            <lsx-accordion-page title="<b>Thema 2:</b>&nbsp;Microservices vs. Monolith">
                <lsx-ul>
                    <li>
                        <p>
                            Lest euch die Seiten über „Monolithen vs. Microservices” im Skript durch und versucht
                            insbesondere den Begriff „Microservices“ zu verstehen. Zusätzlich könnt ihr auch einen
                            KI-Chatbot befragen, wenn dies nicht zu lange dauert. Recherchiert dabei auch ein kleines
                            Fallbeispiel.
                        </p>
                    </li>
                    <li>
                        <p>
                            Euer Ziel ist es, eine Beispielarchitektur an die Tafel schreiben und daran die Begriffe
                            „Microservice“ bzw. „Monolith“ zu erklären.
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>Bonusfrage:</b> Was sind sog. 12-Faktor Apps?
                        </p>
                    </li>
                </lsx-ul>
            </lsx-accordion-page>
            
            <lsx-accordion-page title="<b>Thema 3:</b>&nbsp;Aufgaben und Funktionen eines API-Gateways">
                <lsx-ul>
                    <li>
                        <p>
                            Recherchiert die Frage, ob ein API-Gateway dasselbe wie ein HTTP Reverse Proxy sei,
                            indem ihr euch beispielsweise mit einem KI-Chatbot darüber unterhaltet.
                        </p>
                    </li>
                    <li>
                        <p>
                            Fasst eure Erkenntnisse in einer Folie oder eine Skizze zusammen, anhand derer ihr
                            die Funktionsweise und tyischen Aufgaben eines API-Gateways nacher erklären könnt.
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>Bonusfrage:</b> Was sind weit verbreitete API-Gateways und was zeichnet sie
                            jeweils aus?
                        </p>
                    </li>
                </lsx-ul>
            </lsx-accordion-page>
            
            <lsx-accordion-page title="<b>Thema 4:</b>&nbsp;Horizontale und vertikale Skalierung">
                <lsx-ul>
                    <li>
                        <p>
                            Lest euch die Seite über „Skalierbarkeit“ hier im Skript durch und schaut euch
                            dabei auch die einzelnen Fallbeispiele an. Falls genügend Zeit hierfür ist,
                            könnt ihr weitere Beispiele mit einem KI-Chatbot recherchieren.
                        </p>
                    </li>
                    <li>
                        <p>
                            Fasst eure Ergebnisse in einer Folie oder Skizze zusammen, anhand derer ihr die
                            Begriffe „horizontale Skalierung“ und „vertikale Skalierung“ mit Hilfe eines realen
                            Fallbeispiels erklären könnt.
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>Bonusfrage:</b> Sie rüsten Ihren Computer mit einer neuen CPU mit mehr Kernen
                            als davor auf. Ist dies horizontale oder vertikale Skalierung?
                        </p>
                    </li>
                </lsx-ul>
            </lsx-accordion-page>
            
            <lsx-accordion-page title="<b>Thema 5:</b>&nbsp;Sicherheitsanforderungen in verteilten Systemen">
                <lsx-ul>
                    <li>
                        <p>
                            Recherchieren Sie im Internet oder mit Hilfe eines KI-Chatbots gängiger Sicherheitsprobleme
                            verteilter Anwendungen und versuchen Sie, diese mögichst möglichst einfach zusammenzufassen.
                        </p>
                    </li>
                    <li>
                        <p>
                            Schreiben Sie anschließend eine Folie, mit der Sie die wichtigsten Sicherheitsproblme und
                            ihre Ursachen erklären können.
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>Bonusfrage:</b> Eine Nachricht wird mit einem symterischen Schlüssel chifriert. Wird
                            dadurch die <i>Vertraulichkeit</i>, <i>Integrität</i> oder <i>Authentizität</i> der
                            Nachricht gewährt? Begründen Sie Ihre Antwort.
                        </p>
                    </li>
                </lsx-ul>
            </lsx-accordion-page>
            
            <lsx-accordion-page title="<b>Thema 6:</b>&nbsp;Transparenz in verteilten Anwendungen">
                <lsx-ul>
                    <li>
                        <p>
                            Lest euch die Seite über „Transparenz“ hier im Skript durch und recherchiert
                            anschließend zum Beispiel mit einem KI-Chatbot weitere, reale Beispiele dazu.
                        </p>
                    </li>
                    <li>
                        <p>
                            Fasst eure Erkenntnisse auf einer Folie zusammen, so dass ihr das Thema nacher euren
                            Mitstudierenden daran erklären könnt.
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>Bonusfrage:</b> Findet ihr auch Gegenbeispiele, bei denen sich eine verteilte Anwendung
                            nicht transparent verhält, obwohl sie es besser sollte?
                        </p>
                    </li>
                </lsx-ul>
            </lsx-accordion-page>
            
            <lsx-accordion-page title="<b>Thema 7:</b>&nbsp;Praktische Beispiele für das CAP-Theorem">
                <lsx-ul>
                    <li>
                        <p>
                            Lest euch die Seite über das „CAP-Theorem“ hier im Skript durch und recherchiert
                            anschließend mit einem KI-Chatbot weitere, reale Beispiele dazu.
                        </p>
                    </li>
                    <li>
                        <p>
                            Findet dabei möglichst zwei gegensätzliche Beispiele, anhand derer sich das Konzept
                            gut erkären lässt. Fasst die Ergebnisse auf einer Folie oder Skizze zusammen, so
                            dass ihr es später mit dem gesamten Kurs teilen könnt.
                        </p>
                    </li>
                    <li>
                        <p>
                            <b>Bonusfrage:</b> Was sind so genannte „optimistische Sperren“ und was „pessimistische
                            Sperren“ und wie wirken sie sich auf das CAP-Theorem aus?
                        </p>
                    </li>
                </lsx-ul>
            </lsx-accordion-page>
        </lsx-accordion>
    </article>
    <aside>
        <p>
            „Wenn alles schläft und einer spricht, so nennt man dieses Unterricht“ 😴 soll
            schon Wilhelm Busch gesagt haben. Doch das muss ja nicht so sein, wenn wir
            alle zusammen arbeiten und voneinander lernen. In dieser Aufgabe geht es
            genau darum.
        </p>
        <img src="shared/books.svg" class="img-fluid d-block" style="width: 15em;"/>
        <p>
            <small>
                Bildnachweis:
                <a href="https://pixabay.com/vectors/books-literature-pile-study-2022464/" target="_blank">pixabay: OpenClipart-Vectors</a>
            </small>
        </p>
    </aside>
</section>

<section data-title="Aufgabe 2: Großbestellung bei McDonalds" data-background-color="rgb(179, 202, 223)">
    <article>
        <p>
            <a href="https://chatgpt.com/share/67a34ceb-7300-8007-9195-48e8782faca6" target="_blank">
                <button class="btn btn-dark">Beispielunterhaltung mit ChatGPT</button>
            </a>
        </p>

        <p>
            In dieser Aufgabe wollen wir das Fehlermanagement verteilter Systeme noch einmal beleuchten
            und anschließend in der Vorlesung besprechen. Schließt euch hierzu ein kleine Gruppen zusammen
            und folgt den untenstehenden Anweisungen. Ausgangslage ist eine Geschichte aus dem wahren Leben,
            die sich so oder so ähnlich an der DHBW Karlsruhe zugetragen hat. 👻
        </p>

        <lsx-grid-fluid class="p-0 mb-3">
            <lsx-row>
                <lsx-col size="md">
                    <lsx-card title="<span class='fw-bold dhbw-lightblue'>Schritt 1:</span> Strategien zum Fehlermanagement" class="h-100">
                        <p>
                            Besucht euren Lieblings-Chatbot und lasst euch mit einem Prompt wie dem folgenden die gängigen
                            Strategien zum Umgang mit Fehlern in verteilten Anwendungen erklären.
                        </p>
        
                        <p class="fst-italic text-muted">
                            In der Vorlesung "Verteilte Systeme" haben wir gelernt, dass es mehrere Strategien gibt, wie eine
                            verteilte Anwendung mit Fehlersituationen umgehen kann: Fehler vermeiden, Fehler erkennen, Fehler
                            maskieren, Fehler tolerieren, Fehler beheben. Kannst du mir ein paar Beispiele hierzu nennen?
                        </p>
                    </lsx-card>
                </lsx-col>

                <lsx-col size="md">
                    <lsx-card title="<span class='fw-bold dhbw-lightblue'>Schritt 2:</span> Realer Anwendungsfall" class="h-100">
                        <p>
                            Lest euch die Antwort des Chatbots aufmerksam durch. Anschließend stellt ihm eine Frage wie
                            die folgende, um die Strategien auf eine reale Alltagssituation zu übertragen. Das Ergebnis
                            besprechen wir gleich zusammen in der Vorlesung. 🥳
                        </p>
        
                        <p class="fst-italic text-muted">
                            Wow super. Stell dir folgende Situation als Metapher aus dem realen Leben vor: Eine Person fährt
                            mit dem Auto in den Drive In bei McDonalds und versucht eine große Bestellung vorzunehmen. Das will
                            aber nicht so recht klappen. Welche Fehlerbilder könnten sich hier zeigen und wie könnten die beteiligten
                            Personen damit umgehen?
                        </p>
                    </lsx-card>
                </lsx-col>
            </lsx-row>
        </lsx-grid-fluid>

        <img src="02-architektur/mcdonalds-chatgpt.png" alt="Screenshot von ChatGPT" class="d-block img-thumbnail w-100">
    </article>
    <aside>
        <p>
            Manche abstrakte Themen werden leichter verständlich, wenn man sie sich anhand gewöhnlicher
            Alltagssituationen vor Augen führt. Dies ist auch hier das Ziel mit einer sehr ungewöhnlichen
            Bestellung bei McDonalds. 🍔
        </p>
        <img src="02-architektur/mcdonalds.svg" class="img-fluid d-block" style="width: 20em;"/>
        <p>
            <small>
                Bildnachweis:
                <a href="https://pixabay.com/vectors/cheeseburger-coke-food-fries-155804/" target="_blank">pixabay: OpenClipart-Vectors</a>
            </small>
        </p>
    </aside>
</section>