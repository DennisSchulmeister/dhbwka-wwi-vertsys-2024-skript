<section data-chapter="h1" data-background-color="rgb(210,190,210)">
    <h1>Grundlagen verteilter Systeme</h1>
    <article class="markdown">
        ### Nach Abschluss dieses Kapitels k√∂nnen Sie ‚Ä¶
        
        * den Begriff verteiltes System erkl√§ren und von √§hnlichen Begriffen abgrenzen.
        * Beispiele f√ºr verteilte Anwendungen nennen und von normalen Anwendungen abgrenzen.
        * die wichtigsten Gr√ºnde f√ºr die Entwicklung verteilter Systeme nennen. üí∞
        * die Begriffe Client, Server und Peer definieren und voneinander abgrenzen.
        * die g√§ngigsten Architekturmuster verteilter Anwendungen beschreiben.
        * die Bedeutung des CAP-Theorem verstehen und seine Bedeutung wiedergeben.
        * die Schwierigkeiten zeitlicher Wechselwirkungen verteilter Anwendungen erkennen.

        <span style="font-size: 240px; color: white;" class="dhbw-text-shadow" >üèÅ</span>
    </article>
</section>

<section data-background-color="rgb(210,190,210)">
    <h1>Verteilte Anwendungen im Alltag</h1>
    <article>
        <lsx-grid-fluid>
            <lsx-row>
                <lsx-col size="md">
                    <img src="02-grundlagen/motivation-internet.png" class="img-thumbnail d-block" style="width: 100%" />
                    S√§mtliche Internetdienste
                    <p class="dhbw-fontsize-tiny">
                        <small>
                            Bildnachweis: <a href="https://pixabay.com/illustrations/email-newsletter-marketing-online-3249062/" target="_blank">Pixabay: ribkhan</a>
                        </small>
                    </p>
                </lsx-col>
                <lsx-col size="md">
                    <img src="02-grundlagen/motivation-mobile.jpg" class="img-thumbnail d-block" style="width: 100%" />
                    Mobile Kommunikation
                    <p class="dhbw-fontsize-tiny">
                        <small>
                            Bildnachweis: <a href="https://pixabay.com/photos/communication-communicate-3095538/" target="_blank">Pixabay: Bru-nO</a>
                        </small>
                    </p>
                </lsx-col>
            </lsx-row>
            <lsx-row>
                <lsx-col size="md">
                    <img src="02-grundlagen/motivation-forschung.jpg" class="img-thumbnail d-block" style="width: 100%" />
                    Forschung und Wissenschaft
                    <p class="dhbw-fontsize-tiny">
                        <small>
                            Bildnachweis: <a href="https://pixabay.com/photos/moon-landing-apollo-11-nasa-60582/" target="_blank">Pixabay: WikiImages</a>
                        </small>
                    </p>
                </lsx-col>
                <lsx-col size="md">
                    <img src="02-grundlagen/motivation-vod.jpg" class="img-thumbnail d-block" style="width: 100%" />
                    Video-on-Demand
                    <p class="dhbw-fontsize-tiny">
                        <small>
                            Bildnachweis: <a href="https://unsplash.com/photos/ngMtsE5r9eI" target="_blank">Unsplash: jenskreuter</a>
                        </small>
                    </p>
                </lsx-col>
            </lsx-row>
            <lsx-row>
                <lsx-col size="md">
                    <img src="02-grundlagen/motivation-autonomes-fahren.jpg" class="img-thumbnail d-block" style="width: 100%" />
                    Autonomes Fahren
                </lsx-col>
                <lsx-col size="md">
                    <img src="02-grundlagen/motivation-iot.jpg" class="img-thumbnail d-block" style="width: 100%" />
                    Internet of Things
                    <p class="dhbw-fontsize-tiny">
                        <small>
                            Bildnachweis: <a href="https://pixabay.com/photos/smarthome-smart-house-smart-4447520/" target="_blank">Pixabay: haus_automation</a>
                        </small>
                    </p>
                </lsx-col>
            </lsx-row>
        </lsx-grid-fluid>
    </article>
    <aside>
        <p>
            Auch wenn wir es inzwischen kaum noch merken, begleiten verteilte Systeme und Anwendungen
            schon seit langem unseren Alltag. Wie selbstverst√§ndlich surfen wir im Internet, teilen
            Bilder online oder verschicken Kurznachrichten mit dem Smartphone. Abends streamen wir dann
            die neuste Folge unserer Lieblingsserie ohne dabei auf feste Sendezeiten angewiesen zu sein. üçø
            Und geht es nach dem Willen der Hersteller, steuern wir schon bald s√§mtliche Haushaltsger√§te
            ganz bequem per Sprachbefehl vom Sofa aus, üõãÔ∏è optimieren den Stra√üenverkehr mit vernetzten
            selbstfahrenden Fahrzeugen und √ºberwachen unsere Umwelt mit immer mehr IoT-Devices.
        </p>
        <p>
            Ohne Zweifel leben wir in einer vernetzten Welt, in der immer mehr Computer, Smartphones,
            Smart TVs und viele andere Gegenst√§nde miteinander verbunden sind. Neu ist diese Entwicklung
            allerdings nicht, da die zugrunde liegenden Technologien oftmals schon seit Jahrzehnten
            eingesetzt und weiterentwickelt werden. üìÜ So waren bereits an der ersten Mondlandung 1969
            mindestens vier miteinander verbundene Computersysteme beteiligt, wodurch der Mondflug
            √ºberhaupt nur durchgef√ºhrt werden konnte. üöÄ Seither wurden nat√ºrlich immer mehr Anwendungsf√§lle
            gefunden, so dass verteilte Anwendungen heute nicht mehr die Ausnahme sondern in vielen
            Bereichen sogar die Regel sind.
        </p>
        <p>
            Technisch gesehen erfordern all diese Anwendungen in der Regel eine weit beachtlichere
            Infrastruktur, als wir aus Anwendersicht zun√§chst vermuten w√ºrden. Ziel dieses Kapitels
            soll daher sein, die ersten Geheimnisse √ºber das Wesen und die Beschaffenheit verteilter
            Systeme zu l√ºften, damit wir am Ende des Semesters wissen, wie all diese tollen Dinge
            funktionieren. üßô‚Äç‚ôÇÔ∏è
        </p>
    </aside>
</section>

<!-- ==================== -->
<!-- Begriffsdefinitionen -->
<!-- ==================== -->
<section data-use-template="teilkapitel" data-titel="Begriffsdefinitionen"></section>

<!-- TODO: Zu einer Folie zusammenfassen: Oben Tabs: Video, System, Tanenbaum, Unten: Kacheln mit Beispielen -->
<section data-title="Was ist ein System? (1)">
    <article class="centered-content">
        <div class="markdown limited-width">
            <lsx-youtube video="UWU14-EK9CE" aspect-ratio="16x9" style="width: 50em; max-width: 100%;"></lsx-youtube>

            [Link zum Video](https://youtu.be/UWU14-EK9CE)
        </div>
    </article>
</section>

<section data-title="Was ist ein System? (2)">
    <article class="centered-content">
        <div class="limited-width">
            <blockquote class="blockquote">
                <p>
                    Als System (altgriechisch s√Ωstƒìma ‚Äûaus mehreren Einzelteilen zusammengesetztes Ganzes‚Äú)
                    wird im Allgemeinen ein abgrenzbares, nat√ºrliches oder k√ºnstliches ‚ÄûGebilde‚Äú bezeichnet,
                    das aus verschiedenen Komponenten mit unterschiedlichen Eigenschaften besteht, die aufgrund
                    bestimmter geordneter Beziehungen untereinander als gemeinsames Ganzes betrachtet werden
                    (k√∂nnen).
                </p>
                <figcaption class="blockquote-footer">
                    <cite>Wikipedia zum Begriff ‚ÄûSystem‚Äù</cite>
                </figcaption>
            </blockquote>
        </div>
    </article>
</section>

<section data-title="Definition nach Andrew Tanenbaum">
    <article class="centered-content">
        <div class="limited-width">
            <div class="markdown mb-4">
                Ein **verteiltes System** ist ein System, in dem sich Hardware-
                und Softwarekomponenten auf **mehreren Computern** befinden (k√∂nnen)
                und diese nur √ºber den **Austausch von Nachrichten** untereinander
                kommunizieren, um ihre Aktionen zu koordinieren.
        
                <!-- Eine **verteilte Anwendung** ist eine Anwendung, die ein verteiltes
                System zur L√∂sung des Anwendungsproblems nutzt und aus mehreren
                Komponenten besteht, die √ºber definierte Schnittstellen mit anderen
                Komponenten des Systems und dem Anwender kommunizieren. {.mb-0} -->
            </div>
        
            <lsx-accordion>
                <lsx-accordion-page title="ARPANET / Internet" bold>
                    <img src="02-grundlagen/arpanet.png" class="d-block w-100"/>
                </lsx-accordion-page>

                <lsx-accordion-page title="Webanwendungen" bold>
                    <img src="02-grundlagen/webapp.png" class="d-block w-100" />
                </lsx-accordion-page>

                <lsx-accordion-page title="Internet of Things" bold>
                    <div class="container-fluid">
                        <div class="row gap-3">
                            <div class="col-md p-3">
                                <img src="02-grundlagen/pubsub-iot.png" class="d-block w-100" />
                            </div>
                        </div>
                        <div class="row gap-3">
                            <div class="col-md p-3">
                                <img src="02-grundlagen/iot.jpg" class="d-block w-100" />
                            </div>
                            <div class="col-md p-3">
                                <img src="02-grundlagen/iot-cartoon.png" class="d-block w-100" />
                            </div>
                        </div>
                    </div>
                </lsx-accordion-page>

                <lsx-accordion-page title="Blockchain" bold>
                    <div class="container-fluid">
                        <div class="row gap-3">
                            <div class="col-md p-3">
                                <img src="02-grundlagen/blockchain1.png" class="d-block w-100" />
                            </div>
                        </div>
                        <div class="row gap-3">
                            <div class="col-md p-3">
                                <img src="02-grundlagen/blockchain2.png" class="d-block w-100" />
                            </div>
                        </div>
                        <div class="row gap-3">
                            <div class="col-md p-3">
                                <img src="02-grundlagen/blockchain5.png" class="d-block w-100" />
                            </div>
                        </div>
                    </div>
                </lsx-accordion-page>

                <lsx-accordion-page title="MIDI" bold>
                    <lsx-youtube video="pzhh9_5iqB0" aspect-ratio="16x9" style="width: 100%;"></lsx-youtube>
                    <a href="https://youtu.be/pzhh9_5iqB0" target="_blank">Link zum Video</a>
                </lsx-accordion-page>
            </lsx-accordion>
        </div>    
    </article>
</section>
<!-- Bis hier -->

<section data-title="Von Clients, Servern und Peers">
    <article class="centered-content">
        <table class="m-auto mb-5">
            <tr>
                <td style="padding-right: 0.5em;">
                    üíø
                </td>
                <td style="padding-right: 0.5em;">
                    <b>Server</b>
                </td>
                <td>
                    Langlaufendes Programm, das einen Dienst zur Verf√ºgung stellt.
                    <span style="color: darkred;">
                        Wartet darauf, bis sich ein Client mit ihm verbindet.
                    </span>
                </td>
            </tr>
            <tr>
                <td style="padding-right: 0.33em;">
                    üíø
                </td>
                <td style="padding-right: 0.5em;">
                    <b>Client</b>
                </td>
                <td>
                    Kurzlebiges Programm, das den Dienst nutzt.
                    <span style="color: darkred;">
                        Stellt hierf√ºr eine Verbindung zum Server her.
                    </span>
                </td>
            </tr>
            <tr>
                <td style="padding-right: 0.5em; padding-bottom: 1em;">
                    üíø
                </td>
                <td style="padding-right: 0.5em; padding-bottom: 1em;">
                    <b>Peer</b>
                </td>
                <td style="padding-bottom: 1em;">
                    Spezielles Programm, das sowohl Client als auch Server ist.
                </td>
            </tr>
            <tr style="border: 0px dashed black; border-top-width: 1px;">
                <td style="padding-top: 1em; padding-right: 0.5em;">
                    üñ•
                </td>
                <td style="padding-top: 1em; padding-right: 0.5em;">
                    <b>Host</b>
                </td>
                <td style="padding-top: 1em;">
                    Der Rechner, auf dem die Software l√§uft.
                    <span style="color: darkred;">
                        Oft sagen die Leute ‚ÄûServer‚Äù und meinen damit den ‚ÄûHost‚Äù.
                    </span>
                </td>
            </tr>
        </table>

        <lsx-tab-pages>
            <lsx-tab-page title="Einfache Architekturmuster">
                <div class="d-flex gap-3">
                    <div class="card p-3">
                        <h3 class="mb-4">Client/Server-Architektur</h3>
                        <img src="02-grundlagen/client-server.svg" alt="Skizze mit vielen Clients und einem Server in der Mitte" class="d-block w-100" />
                    </div>
                    <div class="card p-3">
                        <h3 class="mb-4">Peer-to-Peer-Architektur</h3>
                        <img src="02-grundlagen/peer-to-peer.svg" alt="Skizze mit vielen untereinander verbundenen Peers" class="d-block w-100" />
                    </div>
                </div>
            </lsx-tab-page>
            <lsx-tab-page title="Fallbeispiel: Socketprogrammierung mit Node.js">
                <lsx-github-edit url="https://github.com/DennisSchulmeister/dhbwka-wwi-vertsys-2022-quellcodes/tree/main/Socketprogrammierung%20mit%20Node.js"></lsx-github-edit>

                <lsx-grid-fluid class="mt-3 p-0">
                    <lsx-row>
                        <lsx-col size="md">
                            <img src="02-grundlagen/socket-server.png" class="img-thumbnail d-block w-100" />
                        </lsx-col>
                        <lsx-col size="md">
                            <img src="02-grundlagen/socket-client.png" class="img-thumbnail d-block w-100" />
                        </lsx-col>
                        <lsx-col size="md">
                            <img src="02-grundlagen/socket-netcat.png" class="img-thumbnail d-block w-100" />
                        </lsx-col>
                    </lsx-row>
                </lsx-grid-fluid>
            </lsx-tab-page>
        </lsx-tab-pages>
    </article>
</section>

<section data-title="Grundlegende Architekturmodelle">
    <article class="centered-content">
        <div class="limited-width2">
            <lsx-tab-pages class="w-100">
                <lsx-tab-page title="Grundmodell">
                    <h2>Beschreibung</h2>
                    <p style="margin-bottom: 2em;">
                        Dies ist die einfachste Architektur von allen. Sie besteht lediglich aus einem Server,
                        der einen Dienst anbietet und den Clients, welche den Dienst konsumieren. Sehr oft kommt
                        dabei ein synchrones, den Client blockierendes Request/Reply-Verfahren zum Einsatz, das
                        besonders einfach zu programmieren ist. Technisch gesehen ist dies aber kein Muss, da
                        Sockets prinzipiell jede Kommunikationsreihenfolge zulassen.
                    </p>
                    <div class="d-flex justify-content-center">
                        <img src="02-grundlagen/architektur-client-server.svg" alt="Skizze eines Servers und dreier Clients" class="d-block m-auto" style="max-width: 45em;" />
                    </div>
                    
                    <h2 class="mt-4">Fallbeispiele</h2>
                    <lsx-ul emoji="‚úÖ">
                        <li>
                            Browser und Webserver im World Wide Web
                        </li>
                        <li>
                            Browser App mit Zugriff auf den Server via Websockets
                        </li>
                        <li>
                            Wartungszugang auf einen Rechner per Secure Shell
                        </li>
                        <li>
                            Zugriff auf ein E-Mailpostfach mit IMAP
                        </li>
                        <li>
                            Zentrale Quellcodeverwaltung mit Subversion
                        </li>
                        <li>
                            WebDAV-Zugriff auf einen geteilten Onlineordner
                        </li>
                    </lsx-ul>
                </lsx-tab-page>
    
                <lsx-tab-page title="Dreischichtenarchitektur">
                    <h2>Beschreibung</h2>
                    <p style="margin-bottom: 2em;">
                        Hierbei handelt es sich ebenfalls um eine Client/Server-Architektur, jedoch greift der Server zus√§tzlich
                        auf eine Datenbank zu. Client, Server und Datenbank werden daher den drei Schichten <b>Darstellung</b>,
                        <b>Anwendungslogik</b> und <b>Datenhaltung</b> zugeordnet. F√ºr die Darstellung wurden fr√ºher ausschlie√ülich
                        native Clients verwendet, die heute zunehmend von Webanwendungen und mobilen Apps verdr√§ngt werden. Die
                        Schichten f√ºr die Anwendungslogik und Datenhaltung k√∂nnen hingegen auch mehrere Server umfassen.
                    </p>
                    <div class="d-flex justify-content-center">
                        <img src="02-grundlagen/architektur-3schichten.svg" alt="Skizze einer Dreischichtenarchitektur" class="d-block dhbw-limited-width m-auto" />
                    </div>
                    
                    <h2 class="mt-4">Fallbeispiele</h2>
                    <lsx-ul emoji="‚úÖ">
                        <li>
                            Jede Webanwendung mit einer Datenbank im Hintergrund
                        </li>
                        <li>
                            Einfache Informationssysteme ohne eigenst√§ndigen Pr√§sentationsserver
                        </li>
                        <li>
                            Die meisten ERP- und CRM-Systeme (unter anderem SAP und Navision)
                        </li>
                        <li>
                            Per Webservice erreichbare Microservices
                        </li>
                    </lsx-ul>
                </lsx-tab-page>
    
                <lsx-tab-page title="Vierschichtenarchitektur">
                    <h2>Beschreibung</h2>
                    <p style="margin-bottom: 2em;">
                        Hierbei handelt es sich um eine Variation der Dreischichtenarchitektur, bei der die mittlere Sicht
                        in eine <b>Pr√§sentations-</b> und eine <b>Anwendungsschicht</b> zerlegt wurde. Dieses Modell
                        findet man h√§ufig bei ERP-Systemen, die mehrere Clienttechnologien unterst√ºtzen m√ºssen.
                    </p>
                    <div class="d-flex justify-content-center">
                        <img src="02-grundlagen/architektur-4schichten.svg" alt="Skizze einer Dreischichtenarchitektur" class="d-block dhbw-limited-width m-auto" />
                    </div>
                    
                    <h2 class="mt-4">Fallbeispiele</h2>
                    <lsx-ul emoji="‚úÖ">
                        <li>
                            ERP- und CRM-Systeme mit einem eigenst√§ndigen Pr√§sentationsserver
                        </li>
                        <li>
                            Java-Webanwendung mit getrenntem Deployment von Servlets und EJBs
                        </li>
                    </lsx-ul>
                </lsx-tab-page>
    
                <lsx-tab-page title="Microservices">
                    <h2>Beschreibung</h2>
                    <p>
                        Microservices zerlegen eine gro√üe, monolithische Anwendung in viele kleine Teilanwendungen. Jeder Microservice hat
                        ein klar umrissenes Aufgabengebiet, besitzt eine gut dokumentierte und versionierte Schnittstelle und wird in der
                        Regel von einem eigenen Team entwickelt und betrieben. Entwicklung, Test und Betrieb sind sehr stark automatisiert.
                        Microservices eignen sich daher oft f√ºr gro√üe Firmen mit mehreren, unabh√§ngigen Entwicklungsmannschaften.
                    </p>
                    <div class="d-flex justify-content-center">
                        <img src="02-grundlagen/microservices.png" alt="Skizze einer Microservice-Architektur" style="max-height: 26em; max-width: 100%;" />
                    </div>
                    
                    <h2 class="mt-4">Fallbeispiele</h2>
                    <lsx-ul emoji="‚úÖ">
                        <li>
                            Amazon gilt allgemein als Vorreiter, obwohl sie den Begriff selbst nicht verwenden
                        </li>
                        <li>
                            Gro√üe Internetplattformen wie eBay, Netflix, SoundCloud, Spotify, ‚Ä¶
                        </li>
                    </lsx-ul>
                </lsx-tab-page>
                
                <lsx-tab-page title="Reverse Proxy / API-Gateway">
                    <h2>Beschreibung</h2>
                    <p style="margin-bottom: 2em;">
                        Serverseitig kann ein Reverse Proxy als API-Gateway eingesetzt werden, um die eingehenden Anfragen
                        zu b√ºndeln. Dadurch wird es m√∂glich, zus√§tzliche Sicherheitspr√ºfungen zu implementieren, h√§ufig
                        angefragte Inhalte zu cachen oder eine transparente Lastverteilung vorzunehmen.
                    </p>
                    <div class="d-flex justify-content-center">
                        <img src="02-grundlagen/proxy-serverseitig.png" alt="Architekturskizze mit serverseitigem Proxy" style="max-height: 16em; max-width: 100%;" />
                    </div>
                    
                    <h2 class="mt-4">Anwendungsbeispiele</h2>
                    <lsx-ul emoji="‚úÖ">
                        <li>
                            Steigerung der Performance durch Caching h√§ufig angefragter Daten
                        </li>
                        <li>
                            Implementierung von Zugangsbeschr√§nkungen und Upload Filtern
                        </li>
                        <li>
                            Realisierung von Paywalls zum Ausfiltern kostenpflichtiger Inhalte
                        </li>
                        <li>
                            Sicherstellen einer vorgelagerten, zentralen Authentifizierung
                        </li>
                        <li>
                            Serverseitige Lastverteilung durch Weiterleitung an unterschiedliche Server
                        </li>
                    </lsx-ul>
                </lsx-tab-page>
                
                <lsx-tab-page title="Proxy">
                    <h2>Beschreibung</h2>
                    <p style="margin-bottom: 2em;">
                        Ein clientseitiger Proxy bildet die Schnittstelle eines entfernten Servers innerhalb
                        des lokalen Netzwerks ab. Die Anfragen der Clients werden nicht direkt an den Server
                        sondern an den lokalen Proxy gesendet, der daraufhin entscheiden kann, ob er die
                        Anfragen weiterleitet oder selbst beantwortet.
                    </p>
                    <div class="d-flex justify-content-center">
                        <img src="02-grundlagen/proxy-clientseitig.png" alt="Architekturskizze mit clientseitigem Proxy" style="max-height: 16em; max-width: 100%;" />
                    </div>
                    
                    <h2 class="mt-4">Anwendungsbeispiele</h2>
                    <lsx-ul emoji="‚úÖ">
                        <li>
                            Steigerung der Performance durch Caching h√§ufig angefragter Daten
                        </li>
                        <li>
                            Implementierung von Zugangsbeschr√§nkungen und Content Filtern
                        </li>
                        <li>
                            Clientseitige Lastverteilung durch Weiterleitung an unterschiedliche Server
                        </li>
                    </lsx-ul>
                </lsx-tab-page>
            </lsx-tab-pages>
        </div>
    </article>
</section>

<!-- ================== -->
<!-- Entwurfsprinzipien -->
<!-- ================== -->
<section data-use-template="teilkapitel" data-titel="Entwurfsprinzipien"></section>

<!-- TODO: Cards? -->
<section data-title="Anforderungen an den Systementwurf">
    <article>
        <lsx-grid-fluid>
            <lsx-row>
                <lsx-col size="md">
                    <h3>Optimale Ressourcennutzung</h3>
                    <img src="02-grundlagen/anforderung-ressourcennutzung.jpg" alt="" class="img-thumbnail" style="width: 100%;" />
                    Das System muss effizient mit den Ressourcen umgehen und m√∂glichst viele Ressourcen
                    f√ºr die eigentliche Anwendung zur Verf√ºgung stellen. Die Anwendung muss ebenfalls
                    intelligent damit umgehen und sie gut nutzen.
                </lsx-col>
                <lsx-col size="md">
                    <h3>Stabilit√§t und Fehlertoleranz</h3>
                    <img src="02-grundlagen/anforderung-stabilitaet.jpg" alt="" class="img-thumbnail" style="width: 100%;" />
                    Programmabst√ºrze und unvorhersehbares Verhalten sind unbedingt zu vermeiden.
                    Beim Programmieren muss man daher neben den fachlichen Fehlern auch die Fehler
                    ber√ºcksichtigen, die sich aus der Verteilung ergeben.
                </lsx-col>
            </lsx-row>
            <lsx-row>
                <lsx-col size="md">
                    <h3>Einfache Skalierbarkeit</h3>
                    <img src="02-grundlagen/anforderung-skalierbarkeit.jpg" alt="" class="img-thumbnail" style="width: 100%;" />
                    Es muss einfach m√∂glich sein, die Leistung des Systems zu erh√∂hen oder diese zu reduzieren,
                    wenn sie nicht mehr ben√∂tigt wird. Dies kann je nach System automatisch oder manuell erfolgen.
                </lsx-col>
                <lsx-col size="md">
                    <h3>Einfache Nutzung (Transparenz)</h3>
                    <img src="02-grundlagen/anforderung-transparenz.jpg" alt="" class="img-thumbnail" style="width: 100%;" />
                    Zumindest f√ºr den Anwender sollte die inher√§nte Komplexit√§t des Systems verborgen bleiben.
                    Entwickler und Administratoren freuen sich aber auch, wenn sie sich nicht um jede Kleinigkeit
                    k√ºmmern m√ºssen.
                </lsx-col>
            </lsx-row>
            <lsx-row>
                <lsx-col size="md">
                    <h3>Einfache Erweiterbarkeit</h3>
                    <img src="02-grundlagen/anforderung-erweiterbarkeit.jpg" alt="" class="img-thumbnail" style="width: 100%;" />
                    Die Architektur muss flexibel genug sein, um einzelne Teile jederzeit austauschen oder
                    verbessern zu k√∂nnen.
                </lsx-col>
                <lsx-col size="md">
                    <h3>Sicherheit</h3>
                    <img src="02-grundlagen/anforderung-sicherheit.jpg" alt="" class="img-thumbnail" style="width: 100%;" />
                    Die Vertraulichkeit, Integrit√§t und Authentizit√§t des Systems und seiner Daten muss
                    gew√§hrleistet bleiben.
                </lsx-col>
            </lsx-row>
            <lsx-row>
                <lsx-col size="md">
                    <small>
                        <small>
                            Bildnachweise:
                            <a href="https://pixabay.com/en/wallet-tape-measure-economical-levy-2383496/" target="_blank">Pixabay: Myriams-Fotos</a>,
                            <a href="https://pixabay.com/en/house-of-cards-fragile-patience-763246/" target="_blank">Pixabay: wilhei</a>,
                            <a href="https://pixabay.com/en/mixer-fader-digital-console-1631398/" target="_blank">Pixabay: michaelmep</a>,
                            <a href="https://pixabay.com/en/glass-water-napkin-sky-reflection-2875091/" target="_blank">Pixabay: Michael-T</a>,
                            <a href="https://pixabay.com/en/floor-plan-blueprint-house-home-1474454/" target="_blank">Pixabay: ElasticComputerFarm</a>,
                            <a href="https://pixabay.com/en/building-cctv-door-female-ladies-1839464/" target="_blank">Pixabay: Pexels</a>
                        </small>
                    </small>
                </lsx-col>
            </lsx-row>
        </lsx-grid-fluid>
    </article>
    <aside class="markdown">
        Hat man sich einmal zu einem verteilten System hinreisen lassen, will man nat√ºrlich, dass es die gew√ºnschte
        Aufgabe so gut wie m√∂glich unterst√ºtzt. Und hierf√ºr will man in den meisten F√§llen, dass folgende Anforderungen
        ber√ºcksichtigt werden, was uns beim Programmieren manchmal vor echte Herausforderungen stellen kann: ü§î

        ##### Optimale Ressourcennutzung

        Jeder einzelne Computer eines verteilten Systems stellt Ressourcen wie Rechenleistung oder Speicherkapazit√§t
        zur Verf√ºgung. Diese sollen effizient genutzt werden, um somit die Gesamtleistung des Systems zu steigern.
        Hardwareseitig muss das System daher m√∂glichst wenig Ressourcen f√ºr sich beanspruchen und softwareseitig muss man
        darauf achten, diese intelligent zu nutzen.

        ##### Einfache Skalierbarkeit

        Ein System, das mit kleinen Anforderungen heute beginnt, kann morgen schon riesengro√ü werden. Es muss daher einfach m√∂glich
        sein, die Leistung des Systems zu erh√∂hen oder diese zu reduzieren, wenn sie nicht mehr ben√∂tigt wird. Im einfachsten
        Fall bedeutet das, dass man einen schwachen Rechner einfach durch ein leistungsf√§higeres Modell ersetzen kann (vertikale
        Skalierung). Viel wichtiger ist jedoch, dass man einfach einen weiteren Rechner hinzuzuf√ºgen kann, ohne an den anderen
        etwas √§ndern zu m√ºssen (horizontale Skalierung).

        ##### Einfache Erweiterbarkeit

        Ver√§nderung ist die einzige Konstante in der Informatik! Anforderungen k√∂nnen sich jederzeit √§ndern und tun dies auch,
        weshalb agile Entwicklungsmethoden heute in fast allen Bereichen bevorzugt werden. Doch wer wirklich agil sein will,
        braucht eine Architektur, die Ver√§nderungen zul√§sst und sie nicht erschwert. Hardware und Software m√ºssen daher so
        gestaltet sein, dass jeder Bestandteil jederzeit ausgetauscht oder weiterentwickelt werden kann, ohne gleich alles
        auseinander nehmen zu m√ºssen. Bezogen auf den Code sollte man also keinen Spaghetticode hinlegen und auch keine Lasagne
        (Schichten √ºber Schichten, die sich stapeln). Tortellini w√§ren eher die Pasta der Wahl: üçù Viele kleine Module, die nur
        lose miteinander verbunden sind.

        ##### Stabilit√§t und Fehlertoleranz

        Das schlimmste was einem Programm passieren kann ist ein Absturz. üóØÔ∏è Dieser GAU sollte daher immer vermieden werden, auch
        wenn davon nur ein Teil einer verteilten Anwendung betroffen ist. Dummerweise bringen verteilte Anwendungen eine ganze
        Reihe weiterer Fehlerquellen mit sich, die man ebenfalls ber√ºcksichtigen muss:
        
        * Manchmal streikt das Netzwerk.
        * Ein anderes mal funktioniert es zwar, ist aber extrem langsam.
        * Oder ein Programm auf einem anderen Rechner wurde vergessen zu starten.
        * Oder die Putzfrau hat den Stecker gezogen, um den Serverraum zu saugen. ü§¶
        * Oder die Schnittstelle eines entfernten Programms hat sich ver√§ndert.

        Fehlerquellen gibt es also mehr als genug! Und das sind nur die technischen Fehler, die sich aus der Verteilung ergeben
        k√∂nnen. Hinzu kommen nat√ºrlich noch all die fachlichen Fehler wie Fehleingaben, ein nicht gedecktes Konto, fehlende Ware
        im Lager und so weiter. Der Umgang mit Fehlern ist daher sehr wichtig, weshalb sich in der Praxis folgende Strategien
        entwickelt haben:

        <dl>
            <dt>Fehler vermeiden</dt>
            <dd>
                Das ist der offensichtlichste Vorschlag und doch der n√ºtzlichste. Wenn immer es geht, sollte
                man Fehler gar nicht erst entstehen lassen. Das System sollte daher m√∂glichst selbsterkl√§rend sein und dem Anwender
                durch ein komfortables UI m√∂glichst viel Hilfestellung bieten. Aber auch auf technischer Seite sollten Stolperfallen
                vermieden werden und keine unsauberen L√∂sungen implementiert werden, weil ‚Äûdas ja eh so gut wie nie vorkommen kann‚Äù.
            </dd>
            <dt>Fehler erkennen</dt>
            <dd>
                Nat√ºrlich lassen sich Fehler nicht immer vermeiden. In diesem Fall m√ºssen sie aber wenigstens erkannt werden, um darauf
                reagieren zu k√∂nnen. Dass hei√üt zum Beispiel, dass Benutzereingaben auf Plausiblit√§t gepr√ºft oder empfangene Daten durch
                Checksummen abgesichert werden.
            </dd>
            <dt>Fehler maskieren</dt>
            <dd>
                Nicht jeder Fehler ist es wert, dem Anwender damit auf den Keks zu gehen. Gerade kleine
                Fehler lassen sich auch automatisch beheben, indem zum Beispiel nicht empfangene Daten erneut gesendet werden und
                so weiter.
            </dd>
            <dt>Fehler tolerieren</dt>
            <dd>
                Manchmal ist R√ºckzug der beste Angriff. Wenn ein Fehler keine wirkliche Bedeutung hat, kann es auch ganz sinnvoll
                sein, sich gar nicht erst darum zu k√ºmmern. Das mag zun√§chst widerspr√ºchlich klingen, ein Beispiel macht es aber
                deutlich: NoSQL Document Stores wie <a href="http://couchdb.apache.org/" target="_blank"> CouchDB</a> besitzen aus
                Performancegr√ºnden keinen Sperrmechanismus zur Vermeidung zeitgleicher √Ñnderungen. Es kann also durchaus vorkommen,
                dass ein Anwender die √Ñnderung eines anderen √ºberschreibt, wenn sich beide Aktionen √ºberschneiden. Dieser Fehler wird
                jedoch bewusst in Kauf genommen und es werden dann einfach zwei in Konflikt zueinander stehende Dokumentversionen
                gespeichert, wobei die letzte im Zweifelsfall gewinnt.
            </dd>
            <dt>Fehler beheben</dt>
            <dd>
                Und last but not least: Wann immer ein Fehler festgestellt wird, sollte dieser m√∂glichst ohne manuelle Eingriffe
                automatisch behoben werden. Beispielsweise indem verlorene Daten aus einer Sicherungskopie wiederhergestellt werden,
                oder ein abgest√ºrzter Rechner durch ein Hot Standby ersetzt wird.
            </dd>
        </dl>

        ##### Einfache Nutzung (Transparenz)

        Dieser Begriff ist sehr wichtig. Die Welt ist schon kompliziert genug, dann m√ºssen es nicht auch noch die IT-Systeme
        sein. Zumindest f√ºr den Anwender aber gerne auch die Entwickler sollte die inher√§nte Komplexit√§t einer verteilten Anwendung
        verborgen bleiben. Denn merke: In der Informatik bedeutet Transparenz nicht, dass man alle Details sehen kann (wie das in
        Politik und Wirtschaft oft gefordert wird, frag einfach mal deinen Chef üôâ), sondern dass man sich mit den Details gar nicht
        erst auseinandersetzen muss.

        ##### Sicherheit

        Ein weiterer wichtiger Aspekt ist die Sicherheit verteilter Systeme. <a href="https://www.youtube.com/watch?v=rXUlmP5MvnE"
        target="_blank">Denn das B√∂se ist immer und √ºberall.</a> Folgende Dinge muss eine Anwendung daher sicherstellen:
        
        <dl>
            <dt>Authentizit√§t</dt>
            <dd>
                Aus Sicht der Anwendung muss es m√∂glich sein, die Identiti√§t eines Benutzers √ºberrp√ºfen und nachweisen
                zu k√∂nnen. (Ist das wirklich der Benutzer, f√ºr den er sich ausgibt?) Aus Benutzersicht muss es umgekehrt
                m√∂glich sein, die Authentizit√§t der Gegenseite zu √ºberprfen.
            </dd>
            <dt>Vertraulichkeit</dt>
            <dd>
                Die Anwendung muss eine Benutzer- und Rechteverwaltung besitzen, so dass unbefugte Dritte keinen Zugriff auf
                sensitive Informationen bekommen. Sensible Informationen sollten zust√§zlich verschl√ºsselt werden.
            </dd>
            <dt>Integrit√§t</dt>
            <dd>
                Die Anwendung muss sicherstellen, dass ihre Daten im Nachhinein nicht verf√§lscht werden k√∂nnen.
                Oder falls sich dies nicht verhindern l√§sst (zum Beispiel w√§hrend der √úbertragung √ºber das Internet),
                muss es zumindest m√∂glich sein, die Manipulation zu erkennen. Public-Key-Verfahren und Signaturen
                k√∂nnen dies sicherstellen.
            </dd>
        </dl>
    </aside>
</section>

<section data-title="Die neun Arten der Transparenz">
    <article>
        <lsx-grid-fluid>
            <!-- Vergleich Wirtschaft vs. Informatik -->
            <lsx-row style="margin-bottom: 0;">
                <lsx-col size="md">
                    <h2>Transparenz in der Wirtschaft</h2>
                    <img src="02-grundlagen/transparenz1.jpg" alt="" class="img-thumbnail" style="width: 100%" />
                    Alle Informationen liegen offen.
                </lsx-col>
                <lsx-col size="md">
                    <h2>Transparenz in der Informatik</h2>
                    <img src="02-grundlagen/transparenz2.jpg" alt="" class="img-thumbnail" style="width: 100%" />
                    Ich muss nichts tun. Es l√§uft einfach.
                </lsx-col>
            </lsx-row>
            <lsx-row style="margin-bottom: 2.5em;">
                <lsx-col size="md">
                    <small>
                        <small>
                            Bildnachweise:
                            <a href="https://pixabay.com/en/tax-paperwork-accounting-business-739107/" target="_blank">Pixabay: stevepb</a>,
                            <a href="https://pixabay.com/en/dogs-carnival-humor-pet-ernst-1190015/" target="_blank">Pixabay: Chiemsee2016</a>,
                            <a href="https://pixabay.com/en/background-christmas-3009949/" target="_blank">Pixabay: monicore</a>
                        </small>
                    </small>
                </lsx-col>
            </lsx-row>
    
            <!-- Die neun Arten der Transparenz -->
            <lsx-row>
                <lsx-col size="md">
                    <lsx-accordion>
                        <lsx-accordion-page title="Zugriffstransparenz" bold>
                            <lsx-grid-fluid class="p-0">
                                <lsx-row>
                                    <lsx-col size="md">
                                        Falls eine Anwendung zwischen lokalen (auf dem eigenen Rechner befindlichen) und
                                        entfernten Ressourcen unterscheidet, m√ºssen beide auf dieselbe Art und Weise
                                        nutzbar sein.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-grundlagen/transparenz-foto.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Eine Fotoverwaltung erm√∂glicht den Zugriff auf lokal gespeicherte Fotoalben.
                                        Einzelne Bilder oder ganze Alben k√∂nnen aber auch auf einem entfernten Server
                                        abgelegt sein, ohne dass sich die Bedienung hierdurch ver√§ndert.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-grundlagen/transparenz-video.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Eine Video-Streaming-App erm√∂glicht es, einzelne Videos vor dem Anschauen herunterzuladen,
                                        damit diese auch bei langsamer Internetverbindung ruckelfrei abgespielt werden k√∂nnen.
                                        Suche und Wiedergabe der Videos ver√§ndern sich aus Benutzersicht dadurch aber nicht, da
                                        die Videos wie gewohnt aufgerufen und abgespielt werden k√∂nnen.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-grundlagen/transparenz-pwa.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Progressive Web Apps sind Webanwendungen, die nach dem ersten Aufruf im Browser auch lokal installiert
                                        werden k√∂nnen. S√§mtliche Dateien werden hierf√ºr in einen lokalen Anwendungscache geladen, der auch offline
                                        funktioniert. Die Entscheidung, ob eine Datei vom Server oder aus dem Cache geladen werden kann, erfolgt
                                        dabei automatisch, ohne dass dies im Quellcode ber√ºcksichtigt werden muss.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md">
                                        <small>
                                            <small>
                                                Bildnachweise:
                                                <a href="https://pixabay.com/photos/retro-photo-album-memory-family-1483781/" target="_blank">Pixabay: klimkin</a>,
                                                <a href="https://pixabay.com/photos/camera-video-tv-video-realization-1598620/" target="_blank">Pixabay: JosepMonter</a>,
                                                <a href="https://pixabay.com/photos/laptop-workstation-browsing-tablet-1483974/" target="_blank">Pixabay: Monoar</a>
                                            </small>
                                        </small>
                                    </lsx-col>
                                </lsx-row>
                            </lsx-grid-fluid>
                        </lsx-accordion-page>
    
                        <lsx-accordion-page title="Ortstransparenz" bold>
                            <lsx-grid-fluid class="p-0">
                                <lsx-row>
                                    <lsx-col size="md">
                                        Dienste und Ressourcen einer Anwendung k√∂nnen aufgerufen werden, ohne wissen zu m√ºssen,
                                        auf welchem Rechner sie sich befinden.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-grundlagen/transparenz-cdn.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Um die Ladezeit einer Webseite zu optimieren, werden h√§ufig ben√∂tigte Dateien durch
                                        Content Delivery Networks ausgeliefert. Hierf√ºr betreiben die Content Delivery Networks
                                        weltweit gespiegelte Rechenzentren, von denen automatisch das mit der k√ºrzesten Zugriffszeit
                                        ausgew√§hlt wird. Auf dieselbe Weise spielen nebenbei auch Video-Streaming-Portale und andere
                                        Onlinedienste ihre Inhalte aus.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-grundlagen/transparenz-dns.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Die Webseite der DHBW Karlsruhe ist immer unter der Domain
                                        <a href="https://karlsruhe.dhbw.de" target="_blank">karlsruhe.dhbw.de</a> erreichbar.
                                        Zwar muss die Domain zum Aufruf der Seite bekannt sein, diese enth√§lt jedoch keine Informationen
                                        dar√ºber, auf welchen Rechner hierf√ºr zugegriffen werden muss. Diese Information besorgt sich der
                                        Browser stattdessen durch ein DNS-Lookup.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-grundlagen/transparenz-drucker.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        <a href="https://en.wikipedia.org/wiki/Zero-configuration_networking" target="_blank">Zeroconf</a> erm√∂glicht die
                                        automatische Konfiguration von Netzwerkger√§ten, wodurch unter anderem auch netzwerkf√§hige Drucker und Scanner
                                        vom Betriebssystem erkannt und eingerichtet werden k√∂nnen. Selbst wenn ein Ger√§t komplett ausgetauscht wird,
                                        muss die Konfiguration auf dem Anwender-PC nicht angepasst werden.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md">
                                        <small>
                                            <small>
                                                Bildnachweise:
                                                <a href="https://pixabay.com/photos/earth-planet-front-side-back-11593/" target="_blank">Pixabay: WikiImages</a>,
                                                <a href="https://pixabay.com/illustrations/webdesign-design-web-website-3411373/" target="_blank">Pixabay: kreatikar</a>,
                                                <a href="https://pixabay.com/photos/printer-desk-office-fax-scanner-790396/" target="_blank">Pixabay: stevepb</a>
                                            </small>
                                        </small>
                                    </lsx-col>
                                </lsx-row>
                            </lsx-grid-fluid>
                        </lsx-accordion-page>
    
                        <lsx-accordion-page title="Mobilit√§tstransparenz" bold>
                            <lsx-grid-fluid class="p-0">
                                <lsx-row>
                                    <lsx-col size="md">
                                        Die Ressourcen einer verteilten Anwendung k√∂nnen jederzeit auf andere Maschinen
                                        umziehen, ohne dass sich dies auf die Anwendung auswirkt.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-grundlagen/transparenz-namensdienst.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Namensdienste wie das Domain Name System erm√∂glichen es, die damit verwalteten
                                        Ressourcen jederzeit umzuziehen, da die exakte Adresse einer Ressource vor jedem
                                        Zugriff darin nachgeschlagen werden muss. Aus diesem Grund kann sich zum Beispiel
                                        die IP-Adresse einer Webseite jederzeit √§ndern, ohne dass die meisten Besucher*innen
                                        dies merken.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-grundlagen/transparenz-backend.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Die Datenbank einer Webanwendung wurde bisher auf derselben Maschine wie der Webserver betrieben,
                                        soll nun aber auf eigene Hardware umziehen. Die Anwendung l√§uft nach dem Umzug wie gewohnt weiter,
                                        da lediglich ein Eintrag in einer Konfigurationsdatei ge√§ndert werden musste. Die Entscheidung
                                        der Programmierer, die Adresse des Datenbankservers nicht hart-codiert im Quellcode zu hinterlegen,
                                        hat sich an diesem Tag als sehr weitsichtig herausgestellt.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-grundlagen/transparenz-vm.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Der <a href="https://de.wikipedia.org/wiki/Hypervisor" target="_blank">Hypervisor</a> einer
                                        Virtualisierungsl√∂sung entscheidet, eine virtuelle Maschine auf einen leistungsf√§higeren
                                        Rechenknoten umzuziehen. Hierf√ºr wird die VM ohne Unterbrechung des laufenden Betriebs auf
                                        den neuen Host kopiert und dort weiter ausgef√ºhrt.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md">
                                        <small>
                                            <small>
                                                Bildnachweise:
                                                <a href="https://pixabay.com/photos/diary-appointment-address-pen-2080422/" target="_blank">Pixabay: jackmac34</a>,
                                                <a href="https://pixabay.com/photos/server-cloud-development-business-1235959/" target="_blank">Pixabay: ColossusCloud</a>,
                                                <a href="https://pixabay.com/illustrations/cloud-computing-network-internet-2001090/" target="_blank">Pixabay: wynpnt</a>
                                            </small>
                                        </small>
                                    </lsx-col>
                                </lsx-row>
                            </lsx-grid-fluid>
                        </lsx-accordion-page>
    
                        <lsx-accordion-page title="Persistenztransparenz" bold>
                            <lsx-grid-fluid class="p-0">
                                <lsx-row>
                                    <lsx-col size="md">
                                        Besonders benutzerfreundliche Anwendungen unterscheiden nicht zwischen gespeicherten und
                                        und nicht gespeicherten Daten. Die Speicherung erfolgt automatisch im Hintergrund.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-grundlagen/transparenz-google.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Cloudbasierte Officepakete wie Google Docs besitzen keinen Men√ºeintrag zum Speichern
                                        eines Dokuments. Jede √Ñnderung wird mit einem kleinen Zeitversatz automatisch gespeichert,
                                        so dass man nie wieder etwas verlieren kann, wenn man Abends zu schnell aus dem B√ºro flieht.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md">
                                        <small>
                                            <small>
                                                Bildnachweis:
                                                <a href="https://pixabay.com/illustrations/google-search-engine-browser-search-76517/" target="_blank">Pixabay: Simon</a>
                                            </small>
                                        </small>
                                    </lsx-col>
                                </lsx-row>
                            </lsx-grid-fluid>
                        </lsx-accordion-page>
    
                        <lsx-accordion-page title="Replikationstransparenz" bold>
                            <lsx-grid-fluid class="p-0">
                                <lsx-row>
                                    <lsx-col size="md">
                                        Aus Performancegr√ºnden oder zur Erh√∂hung der Ausfallsicherheit werden wichtige Daten auf
                                        mehrere Rechenknoten repliziert. Die Datenreplikation erfolgt vollautomatisch im Hintergrund,
                                        wobei das System bei jeder √Ñnderung die Aktualisierung aller Kopien sicherstellt.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-grundlagen/transparenz-weltkarte.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Weltweit genutzte Anwendungen wie die Googlesuche, Facebook oder Instagram werden in global
                                        verteilten Rechenzentren betrieben, um die Ladezeiten zu verk√ºrzen. Die innerhalb der Anwendung
                                        anfallenden Daten werden deshalb automatisch zwischen den Rechenzentren repliziert, damit jede*r
                                        Anwender*in m√∂glichst dieselben Daten sieht.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-grundlagen/transparenz-datenbank.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Die meisten Datenbanken erlauben einen automatischen Cluster-Betrieb, wodurch alle Daten auf mehrere
                                        Rechenknoten gespiegelt werden. Lesende Anfragen werden dann von irgend einem gerade verf√ºgbaren Knoten
                                        beantwortet, w√§hrend √§ndernde Anfragen an alle Knoten weitergereicht werden.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md">
                                        <small>
                                            <small>
                                                Bildnachweise:
                                                <a href="https://www.openstreetmap.org/#map=2/18.1/-20.7&layers=C" target="_blank">OpenStreetMap</a>,
                                                <a href="https://pixabay.com/photos/info-data-disk-server-database-1641937/" target="_blank">pixabay: FreePhotosART</a>,
                                            </small>
                                        </small>
                                    </lsx-col>
                                </lsx-row>
                            </lsx-grid-fluid>
                        </lsx-accordion-page>
    
                        <lsx-accordion-page title="Fehlertransparenz" bold>
                            <lsx-grid-fluid class="p-0">
                                <lsx-row>
                                    <lsx-col size="md">
                                        Fehlersituationen werden nicht als Ausnahme sondern als Normalfall betrachtet.
                                        Eine Anwendung sollte daher immer so entworfen werden, dass sie m√∂glichst viele
                                        Fehlersituationen abfangen und automatisch korrigieren kann. Keinesfalls darf
                                        eine Anwendung einfach abst√ºrzen, wenn ein Weiterbetrieb prinzipiell m√∂glich ist.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-grundlagen/transparenz-email.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Eine E-Mail kann nicht sofort zugestellt werden, da das Postfach des Empf√§ngers
                                        voll ist. Der Mailserver des Senders teilt deshalb mit, die Zustellung innerhalb
                                        der n√§chsten Tage zu wiederholen. Nur, wenn die Nachricht nach f√ºnf Tagen immer
                                        noch nicht zugestellt wurde, wird der Absender √ºber das endg√ºltige Scheitern
                                        informiert.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-grundlagen/transparenz-wetterstation.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Eine Wetterstation sammelt kontinuierlich Daten und sendet diese via UMTS an einen zentralen
                                        Server. Bei schlechtem Wetter besteht allerdings nur eine unzuverl√§ssige Internetverbindung,
                                        so dass die Daten nicht immer sofort verschickt werden k√∂nnen. S√§mtliche Daten werden daher
                                        in einem internen Ringbuffer gesammelt und so lange an den Server geschickt, bis dieser den
                                        Empfang best√§tigt.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-grundlagen/transparenz-apollo11.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Bereits bei den Apollo-Mondmissionen waren alle Computersysteme mehrfach redundant ausgelegt,
                                        so dass bei Versagen eines Teilsystems dieses vollautomatisch ersetzt werden konnte. Der
                                        <a href="https://en.wikipedia.org/wiki/Saturn_Launch_Vehicle_Digital_Computer" target="_blank">Saturn
                                        Launch Vehicle Digial Computer</a> f√ºhrte sogar jede Berechnung dreifach redundant aus und
                                        arbeitete stets mit dem Mehrheitsergebnis weiter, um katastrophale Folgen aufgrund von
                                        Hardwarefehlern zu vermeiden.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md">
                                        <small>
                                            <small>
                                                Bildnachweise:
                                                <a href="https://unsplash.com/photos/oeDH20DVb2A" target="_blank">Unsplash: Liam Truong</a>,
                                                <a href="https://pixabay.com/photos/anemometer-weather-station-3977718/" target="_blank">Pixabay: RitaE</a>,
                                                <a href="https://de.wikipedia.org/wiki/Datei:Apollo_11_rollout.jpg" target="_blank">Wikipedia: NASA</a>
                                            </small>
                                        </small>
                                    </lsx-col>
                                </lsx-row>
                            </lsx-grid-fluid>
                        </lsx-accordion-page>
    
                        <lsx-accordion-page title="Nebenl√§ufigkeitstransparenz" bold>
                            <lsx-grid-fluid class="p-0">
                                <lsx-row>
                                    <lsx-col size="md">
                                        Eine verteilte Anwendung sollte immer so entworfen werden, dass sie von vielen Benutzern
                                        gleichzeitig genutzt werden kann. Hierf√ºr notwendige Sperren und Synchronisationsmechanismen
                                        sollten dabei vor den Anwender*innen verborgen im Hintergrund ablaufen.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-grundlagen/transparenz-wikipedia.svg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Wikipedia verarbeitet pro Sekunde zwischen 25.000 und 60.000 Seitenzugriffe. Da die meisten
                                        Zugriffe nur lesend erfolgen, kann jeder Artikel auch dann gelesen werden, wenn er gerade von
                                        jemand anderem bearbeitet wird. Bearbeiten zwei Personen gleichzeitig denselben Artikel, wird
                                        beim Speichern ein Bearbeitungskonflikt angezeigt, der manuell aufgel√∂st werden muss.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-grundlagen/transparenz-etherpad.png" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Kollaborative Anwendungen wie Etherpad erlauben es mehreren Personen, gleichzeitig am selben
                                        Dokument zu arbeiten. Jede Person sieht dabei in Echtzeit die von den anderen vorgenommenen
                                        √Ñnderungen, weshalb auch niemand ein Dokument exklusiv sperren kann.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-grundlagen/transparenz-couchdb.svg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        CouchDB kennt keine Datenbanksperren, um gleichzeitige √Ñnderungen an einem Datensatz zu vermeiden.
                                        Tritt ein Konflikt auf, legt die Datenbank einfach zwei Versionen desselben Datensatzes an. Es obliegt
                                        dem Anwendungscode die Versionen bei Bedarf wieder zusammenzuf√ºhren.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md">
                                        <small>
                                            <small>
                                                Bildnachweise:
                                                <a href="https://commons.wikimedia.org/wiki/File:Wikipedia-logo-v2.svg" target="_blank">Wikimedia: Nohat</a>,
                                                <a href="https://etherpad.org/" target="_blank">etherpad.org</a>,
                                                <a href="https://commons.wikimedia.org/wiki/File:CouchDB.svg" target="_blank">Wikimedia: Apache Software Foundation</a>
                                            </small>
                                        </small>
                                    </lsx-col>
                                </lsx-row>
                            </lsx-grid-fluid>
                        </lsx-accordion-page>
    
                        <lsx-accordion-page title="Skalierbarkeitstransparenz" bold>
                            <lsx-grid-fluid class="p-0">
                                <lsx-row>
                                    <lsx-col size="md">
                                        Verteilte Systeme und Anwendungen sollten immer skalierbar sein. Im Idealfall k√∂nnnen im
                                        laufenden Betrieb Ressourcen hinzugef√ºgt oder entfernt werden, um die Leistung anzupassen.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-grundlagen/transparenz-linux.svg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Unter Linux bildet der
                                        <a href="https://de.wikipedia.org/wiki/Logical_Volume_Manager" target="_blank">Logical Volume Manager</a>
                                        eine Abstraktionsschicht zwsichen den tats√§chlich auf einem Datentr√§ger vorhandenen Partitionen und den
                                        f√ºr das Betriebssystem sichtbaren Dateisystemen. Dadurch wird es m√∂glich, ein Dateisystem jederzeit durch
                                        Hinzuf√ºgen weiterer Datentr√§ger zu vergr√∂√üern.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-grundlagen/transparenz-lastverteilung.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Im einfachsten Fall befinden sich die Dateien einer Webseite auf einem zentralen Webserver, von
                                        dem sie abgerufen werden k√∂nnen. Sollen jedoch sehr viele Anfragen gleichzeitig behandelt werden,
                                        k√∂nnen diese √ºber eine vorgeschaltete Lastverteilung auf mehrere Server verteilt werden. Die
                                        Leistungsf√§higkeit kann dabei jederzeit durch Starten und Stoppen weiterer Server angepasst werden.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row>
                                    <lsx-col size="md">
                                        <small>
                                            <small>
                                                Bildnachweise:
                                                <a href="https://pixabay.com/vectors/avatar-beak-black-cute-emotion-1295404/" target="_blank">Pixabay: OpenClipart-Vectors</a>,
                                                <a href="https://pixabay.com/illustrations/vpn-server-router-virtual-firewall-3406770/" target="_blank">Pixabay: kreatikar</a>
                                            </small>
                                        </small>
                                    </lsx-col>
                                </lsx-row>
                            </lsx-grid-fluid>
                        </lsx-accordion-page>
    
                        <lsx-accordion-page title="Leistungstransparenz" bold>
                            <lsx-grid-fluid class="p-0">
                                <lsx-row>
                                    <lsx-col size="md">
                                        Die Leistung eines verteilten Systems sollte nur von den verf√ºgbaren Ressourcen begrenzt
                                        sein. Innerhalb der gegebenen Grenzen sorgt das System dann selbstst√§ndig und ohne manuelle
                                        Eingriffe daf√ºr, die vorhandene Kapazit√§t bedarfsgerecht anzupassen.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-grundlagen/transparenz-cloud.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Cloudangebote unterscheiden sich vom traditionallen Hosting insbesondere durch die automatische
                                        Skalierbarkeit und nutzungsabh√§ngige Abrechnung aller Dienste. Die meisten Anbieter erlauben daher,
                                        Regeln zu definieren, bei welcher Auslastung weitere Kapazit√§ten hinzugef√ºgt oder wieder entfernt
                                        werden sollen. Einrichtung, Start und Stopp der notwendigen Rechenknoten laufen hierf√ºr komplett
                                        automatisiert.
                                    </lsx-col>
                                </lsx-row>
                                <lsx-row class="dhbw-fontsize-small">
                                    <lsx-col size="md-2">
                                        <img src="02-grundlagen/transparenz-3dfilm.jpg" class="img-thumbnail" style="width: 100%;" />
                                    </lsx-col>
                                    <lsx-col size="md">
                                        <b>Beispiel:</b>
                                        Nicht nur in Forschung und Wissenschaft sondern auch in der Filmwirtschaft werden Clustersysteme
                                        zur Bewerkstelligung der anfallenden Rechenaufgaben eingesetzt. Diese besitzen einen Job Scheduler
                                        zum Einspiesen abzuarbeitender Aufgaben. Die zur Verf√ºgung stehende Rechenleistung teilt der Scheduler
                                        automatisch auf alle aktiven Jobs auf. Sind zu einem Zeitpunkt nur wenige Jobs aktiv, laufen diese daher
                                        schneller durch, als wenn viele Jobs gleichzeitig laufen sollen.
                                    </lsx-col>
                                </lsx-row>
                                <div class="row">
                                    <div class="col">
                                        <small>
                                            <small>
                                                Bildnachweise:
                                                <a href="https://pixabay.com/photos/field-clouds-sky-agriculture-533541/" target="_blank">Pixabay: pcdazero</a>,
                                                <a href="https://pixabay.com/illustrations/super-woman-flying-3d-figure-female-1885016/" target="_blank">Pixabay: perianjs</a>
                                            </small>
                                        </small>
                                    </div>
                                </div>
                            </lsx-grid-fluid>
                        </lsx-accordion-page>
                    </lsx-accordion>
                </lsx-col>
            </lsx-row>
        </lsx-grid-fluid>
    </article>
    <aside>
        <blockquote cite="https://de.wikipedia.org/wiki/Clarkesche_Gesetze" class="text-end">
            <i>
                ‚ÄûJede hinreichend komplexe Technologie ist von Magie nicht zu unterscheiden.‚Äù
            </i>
            <br />
            ‚Äì Arthur C. Clarke
        </blockquote>
        <div class="embed-responsive embed-responsive-16by9 w-100">
            <video controls class="w-100">
                <source src="https://upload.wikimedia.org/wikipedia/commons/6/69/ABC_Clarke_predicts_internet_and_PC.ogv" type="video/ogg" />
                <source src="https://upload.wikimedia.org/wikipedia/commons/transcoded/6/69/ABC_Clarke_predicts_internet_and_PC.ogv/ABC_Clarke_predicts_internet_and_PC.ogv.240p.webm" type="video/webm" />
            </video>
        </div>
        <p>
            <small>
                Interview mit Arthur C. Clarke, 1974, in dem er die universelle Verf√ºgbarkeit des
                Internets voraussagt, obwohl es ein solches System damals noch gar nicht gab.
                Quelle: Australian Broadcasting Company auf Wikimedia Commons.
            </small>
        </p>
        <p>
            Auf der vorherigen Folie haben wir bereits den Begriff
            ‚Äû<a href="https://en.wikipedia.org/wiki/Transparency_(human%E2%80%93computer_interaction)" target="_blank">Transparenz</a>‚Äù
            im Zusammenhang mit der Benutzerfreundlichkeit kennengelernt. Doch wie kommen wir √ºberhaupt dazu, eine benutzerfreundliche
            Anwendung als transparent zu bezeichnen und warum ben√∂tigen wir einen eigenen Begriff daf√ºr? ü§î Um dies zu verstehen, m√ºssen
            wir uns erst √ºberlegen, was mit Transparenz tats√§chlich gemeint ist. Verteter aus Wirtschaft und Politik, verstehen darunter
            regelm√§√üig, dass alle Informationen √ºber einen Sachverhalt offen liegen. Jedes kleine Detail ist bekannt und kann (oder muss)
            nachgelesen werden. Denken wir daran, dass gute Dokumentation in der Informatik oftmals durch ihr Fehlen gl√§nzt, ‚ú® ist dies
            sicher erstrebenswert. Dennoch meinen wir etwas ganz anderes, n√§mlich dass die Komplexit√§t, die heute in jeder Hard- und
            Software ganz unweigerlich vorhanden ist, m√∂glichst verborgen bleibt und somit im besten Fall gar nicht erst wahrgenommen,
            auf jeden Fall aber nicht beachtet werden muss.
        </p>
        <p>
            Doch wie stellen wir sicher, dass die Komplexit√§t unserer Anwendungen verborgen bleibt? Und worum handelt es sich
            dabei √ºberhaupt? Welche Teile einer verteilten Anwendung sind eher muss-man-halt-haben-geht-nicht-anders und welche
            sind es Wert, den Anwender*innen pr√§sentiert zu werden? Schauen wir uns heute √ºbliche Anwendungen an, die wir selbst
            als besonders gelungen empfinden, bekommen wir sicher eine vage Vorstellung davon. 1996 wurde allerdings von ISO, IEC
            und ITU-T mit dem <b>Reference Model of Open Distributed Processing (RM-ODP, ISO/IEC 10746)</b> eine gemeinsame Norm
            verabschiedet, die genau diese und viele weitere Fragen beantwortet. Auch wenn sich die Technologie seit damals
            grundlegend gewandelt hat, sind es heute immer noch dieselben Aspekte, die wir bei der Implementierung zwar beachten,
            den Benutzer*innen aber doch eher sang- und klanglos abnehmen sollten. üéµ Nebenstehend findest du daher eine Liste mit
            den wichtigsten Punkten, in denen eine gute Anwendung transparent sein sollte, mitsamt einfachen Definitionen und
            aktuellen Beispielen.
        </p>
    </aside>
</section>

<section data-title="Ausfallsicherheit und Skalierung in der Cloud">
    <article>
        <div class="d-flex justify-content-between flex-wrap gap-3">
            <img src="02-grundlagen/cloud-betriebsmodell.png" class="d-block img-fluid" />
            <div class="col markdown">
                ## Cluster-Betrieb
    
                * Vollst√§ndige Virtualisierung von Rechenleistung und Speicherkapazit√§t
                * Kommunikation √ºber ein abgeschirmte, virtuelle App-Netzwerke
                * Automatische Replikation einzelner Komponenten je nach Bedarf
                * Lastverteilung zwischen mehreren Instanzen einer Komponente
    
                ## Ausfallsichere Deployment-Strategien
    
                * Blue/Green-Deployment
                * Rolling Deployment
                * Canary Releases
                * ‚Ä¶
            </div>
        </div>
    </article>
</section>

<section data-title="Die acht Irrt√ºmer verteilter Systeme">
    <article>
        <lsx-grid-fluid>
            <lsx-row>
                <lsx-col size="lg-7">
                    <div style="height: 100%; display: flex; align-items: center;">
                        <div class="markdown">
                            1. Das Netzwerk ist immer verf√ºgbar.
                            1. Es gibt keine Latenzzeiten.
                            1. Der Datendurchsatz ist unendlich schnell.
                            1. Die Kommunikation ist automatisch sicher.
                            1. Die Netzwerktopologie ist unver√§nderlich.
                            1. Es gibt nur einen Administrator.
                            1. Datentransfer kostet nichts.
                            1. Das Netzwerk ist homogen.
                        </div>
                    </div>
                </lsx-col>
                <lsx-col size="lg">
                    <img src="02-grundlagen/dilbert-1997-01-28.gif" class="d-block w-100 mb-3" />
                    <img src="02-grundlagen/dilbert-1997-01-29.gif" class="d-block w-100 mb-3" />
                    <img src="02-grundlagen/dilbert-2018-03-22.gif" class="d-block w-100 mb-3" />
    
                    <small>
                        <small>
                            Bildnachweise:
                            <a href="https://dilbert.com/strip/1997-01-28" target="_blank">Dilbert vom 28.01.1997</a>,
                            <a href="https://dilbert.com/strip/1997-01-29" target="_blank">Dilbert vom 29.01.1997</a>,
                            <a href="https://dilbert.com/strip/2018-03-22" target="_blank">Dilbert vom 22.03.2018</a>
                        </small>
                    </small>
                </lsx-col>
            </lsx-row>
        </lsx-grid-fluid>
    </article>
</section>

<section data-title="Fehlertoleranz in verteilten Systemen">
    <article>
        <lsx-tab-pages>
            <lsx-tab-page title="Das CAP-Theorem">
                <lsx-grid-fluid>
                    <lsx-row>
                        <lsx-col size="md-5">
                            <img src="02-grundlagen/cap-theorem.png" alt="Visualisierung des CAP-Theorems" style="width: 100%;" />
                        </lsx-col>
                        <lsx-col size="md">
                            <h4>Consistency (Konsistenz)</h4>
                            <p>
                                Alle Knoten sehen immer exakt dieselben, konsistenten Daten. Bei replizierten Datenbest√§nden
                                werden die √Ñnderungen daher erst sichtbar, wenn sie in allen Repliken nachgezogen wurden.
                            </p>
                
                            <h4>Availability (Verf√ºgbarkeit)</h4>
                            <p>
                                Das System ist jederzeit erreichbar und √ºberschreitet niemals die maximal zul√§ssige
                                Antwortzeit.
                            </p>
                
                            <h4>Partition Tolerance (Partitionstoleranz)</h4>
                            <p>
                                Die Anwendung funktioniert auch dann noch, wenn einzelne Teile ausgefallen sind.
                            </p>
                        </lsx-col>
                    </lsx-row>
                    <lsx-row>
                        <lsx-col size="md">
                            <p style="color: darkred;">
                                Eine verteilte Anwendung kann immer nur zwei dieser Anforderungen g√§nzlich erf√ºllen!
                            </p>
                            <p>
                                Moderne Anwendungen sind deshalb oft nur ‚Äûeventuell-konsistent‚Äù. Beispielsweise kann es
                                in Facebook vorkommen, dass ein Like in den ersten Sekunden nicht f√ºr alle Profilbesucher
                                sichtbar wird, da nicht alle auf derselben Datenreplik arbeiten.
                            </p>
                            <p>
                                eBay hingegen w√ºrde bei der Gebotsabgabe sicher lieber eine etwas l√§ngere Antwortzeit in
                                Kauf nehmen, anstatt sich √ºberschreibende Gebote zu riskieren.
                            </p>
                        </lsx-col>
                    </lsx-row>
                </lsx-grid-fluid>
            </lsx-tab-page>
    
            <lsx-tab-page title="Strategien zur Fehlerbehandlung">
                <lsx-grid-fluid>
                    <lsx-row>
                        <lsx-col size="md-4">
                            <h3>Fehler vermeiden</h3>
                            <img src="02-grundlagen/fehler-vermeiden.jpg" alt="" class="img-thumbnail" style="width: 100%;" />
                            Zum Beispiel durch Eingabehilfen oder einen sauberen Programmierstil
                        </lsx-col>
                        <lsx-col size="md-4">
                            <h3>Fehler erkennen</h3>
                            <img src="02-grundlagen/fehler-erkennen.jpg" alt="" class="img-thumbnail" style="width: 100%;" />
                            Zum Beispiel durch Checksummen, Plausipr√ºfungen oder Monitoring
                        </lsx-col>
                        <lsx-col size="md-4">
                            <h3>Fehler maskieren</h3>
                            <img src="02-grundlagen/fehler-maskieren.jpg" alt="" class="img-thumbnail" style="width: 100%;" />
                            Zum Beispiel durch sp√§tere Wiederholung des Vorgangs
                        </lsx-col>
                    </lsx-row>
                    <lsx-row>
                        <lsx-col size="md-4">
                            <h3>Fehler tolerieren</h3>
                            <img src="02-grundlagen/fehler-tolerieren.jpg" alt="" class="img-thumbnail" style="width: 100%;" />
                            href="https://de.wikipedia.org/wiki/Normalisierung_(Datenbank)" target="_blank">normalisierten Datenmodellen</a>
                            und                                    <a href="https://pixabay.com/en/rappelling-rope-safety-security-755400/" target="_blank">Pixabay:
                                        cegoh</a>,
                                    <a href="https://pixabay.com/en/equipment-hospital-ecg-3089883/" target="_blank">Pixabay:
                                        hioahelsefag</a>,
                                    <a href="https://pixabay.com/en/redirect-shield-tree-attention-2257746/" target="_blank">Pixabay:
                                        Digitalpfade</a>,
                                    <a href="https://pixabay.com/en/home-single-family-home-on-the-head-2308799/"
                                        target="_blank">Pixabay: ulleo</a>,
                                    <a href="https://pixabay.com/en/first-aid-frog-medic-nurse-funny-1732708/" target="_blank">Pixabay:
                                        Alexas_Fotos</a>
                                </small>
                            </small>
                        </lsx-col>
                    </lsx-row>
                </lsx-grid-fluid>
            </lsx-tab-page>
    
            <lsx-tab-page title="Fallbeispiel: Coffe Shop">
                <a href="https://ieeexplore.ieee.org/document/1407829" target="_blank">IEEE Software, Volume: 22, Issue: 2, Pages 64‚Äì66</a>
                <div class="d-flex gap-3">
                    <img src="02-grundlagen/coffeeshop1.png" class="img-thumbnail d-block w-100"/>
                    <img src="02-grundlagen/coffeeshop2.png" class="img-thumbnail d-block w-100" />
                    <img src="02-grundlagen/coffeeshop3.png" class="img-thumbnail d-block w-100" />
                </div>
            </lsx-tab-page>
        </lsx-tab-pages>
    </article>
    <aside class="markdown">
        Ein guter Datenbankentwurf beruht auf
        <a href="https://de.wikipedia.org/wiki/Normalisierung_(Datenbank)" target="_blank">normalisierten Datenmodellen</a>
        und <a href="https://de.wikipedia.org/wiki/Transaktion_(Informatik)" target="_blank">atomaren Transaktionen</a>,
        um jederzeit konsistente und widerspruchsfreie Daten zu garantieren. <span style="color: darkgreen">‚úîÔ∏è</span>
        Diese Grundregel lernt jede*r Informatiker*in gleich in der ersten Datenbankvorlesung. Und in den meisten F√§llen
        ist sie auch v√∂llig in Ordnung. Innerhalb einer verteilten Anwendung kann eine zu starke Fixierung auf konsistente
        Daten allerdings auch deutliche Nachteile nach sich ziehen, wie das im Jahr 2000 formulierte und 2002 bewiesene
        CAP-Theorem besagt. Denn aus ihm folgt, dass eine verteilte Anwendung niemals alle drei der folgenden Eigenschaften
        gleichzeitig erf√ºllen kann:
    
        * <b>Consistency (Konsistenz):</b> Werden die Daten einer Anwendung auf mehrere Rechner repliziert, kann es f√ºr einen
            kurzen Zeitpunkt zu lokalen Unterschieden kommen, so lange die neusten √Ñnderungen noch nicht komplett verteilt
            wurden. Will man das vermeiden, muss eine verteilte Transaktion genutzt werden, die erst als abgeschlossen gilt,
            wenn alle √Ñnderungen auf allen Rechnern nachgezogen wurden.
        
        * <b>Availability (Verf√ºgbarkeit):</b> Hiermit sind sowohl die generelle Verf√ºgbarkeit im Sinne, dass die Anwendung
            √ºberhaupt erreichbar ist, als auch die maximal zul√§ssige Antwortzeit gemeint. Beispielsweise kann es vorkommen,
            dass w√§hrend einer aktiven, verteilten Transaktionen lesende Anfragen warten m√ºssen. Dadurch kann es allerdings
            zu unerw√ºnschten Verz√∂gerungen kommen, wenn einzelne Transaktionen die Anwendung zu lange blockieren oder aufgrund
            von Deadlocks niemals zu Ende laufen.

        * <b>Partition Tolerance (Partitionstoleranz):</b> Zun√§chst w√ºrde man denken, damit sei die horizontale oder
            vertikale Partitionierung von Daten auf mehrere Rechner gemeint. Stattdessen geht es hier aber darum, dass
            eine Anwendung auch dann noch weiter arbeiten kann, wenn ein Teil ihrer Komponenten ausgefallen ist. Es kann
            nach einem teilweisen Systemausfall sozusagen auch ein kleinerer Teil der Anwendung (eine Partition) noch
            weiter genutzt werden.

        Das CAP-Theorem besagt, dass verteilte Systeme und Anwendungen immer nur zwei dieser Kriterien,
        niemals aber alle drei, g√§nzlich erf√ºllen k√∂nnen. Eine Verbesserung in einem Bereich f√ºhrt unweigerlich zu einer
        Verschlechterung in einem der anderen. <span style="color: deepskyblue;">‚¨ÜÔ∏è</span><span style="color: crimson;">‚¨áÔ∏è</span>
        Zwei einfache Beispiele sollen dies verdeutlichen:

        1. <b>Eventuelle Konsistenz:</b> In Facebook kann es vorkommen, dass ein Like in den ersten Sekunden nicht f√ºr alle
            Besucher sichtbar wird, da nicht alle auf derselben Datenreplik arbeiten. Daraus entsteht aber kein wirklicher
            Schaden, weshalb hier die Konsistenz zugunsten der Verf√ºgbarkeit aufgeweicht wird.
            
        1. <b>Verringerte Verf√ºgbarkeit:</b> eBay hingegen w√ºrde bei der Gebotsabgabe sicher lieber eine etwas l√§ngere Antwortzeit
            in Kauf nehmen, anstatt doppelte Gebote zu riskieren. Die Konsistenz ist hier also K√∂nig. üëë Daf√ºr kann es vorkommen, dass
            ein Gebot in letzter Sekunde nicht mehr rechtzeitig abgegeben werden kann.
    </aside>
</section>

<section data-title="Zeitsynchronisation verteilter Anwendungen">
    <article>
        <lsx-tab-pages>
            <lsx-tab-page title="Fallbeispiel">
                <img src="02-grundlagen/zeitproblem-karte.jpg" class="d-block img-fluid img-thumbnail" />
                <p>
                    <small>
                        <small>
                            Bildnachweise:
                            <a href="https://pixabay.com/illustrations/map-central-europe-europe-1804891/s"
                                target="_blank">Pixabay: Hans</a>,
                            <a href="https://pixabay.com/vectors/map-pin-illustrator-holder-place-42871/"
                                target="_blank">Pixabay: Clker-Free-Vector-Images</a>
                        </small>
                    </small>
                </p>
                <lsx-ul>
                    <li emoji="üå°Ô∏è">
                        Aufzeichnung von Umweltdaten zur Vorhersage von Unwettern und Naturkatastrophen
                    </li>
                    <li emoji="üó∫Ô∏è">
                        Aktuell 19 Messstationen in verschiedenen L√§ndern und Zeitzonen
                    </li>
                    <li emoji="üïí">
                        Messung und √úbermittlung eines kompletten Datensatzes alle f√ºnf Minuten
                    </li>
                    <li emoji="üíΩ ">
                        Speicherung aller Messwerte im Rechenzentrum in Frankfurt am Main
                    </li>
                </lsx-ul>
            </lsx-tab-page>
        
            <lsx-tab-page title="Fallstricke">
                <lsx-grid-fluid class="p-0">
                    <lsx-row>
                        <lsx-col size="md-6">
                            <img src="02-grundlagen/zeitproblem-latenz-deutschland.jpg" alt="" class="img-thumbnail" style="width: 100%" />
                            <small>
                                Latenz beim Zugriff auf wpvs.de aus Deutschland
                            </small>
                        </lsx-col>
                        <lsx-col size="md-6">
                            <img src="02-grundlagen/zeitproblem-latenz-spanien.jpg" alt="" class="img-thumbnail" style="width: 100%" />
                            <small>
                                Latenz beim Zugriff auf wpvs.de aus S√ºdspanien
                            </small>
                        </lsx-col>
                    </lsx-row>
                    <lsx-row>
                        <lsx-col size="md">
                            <lsx-ul emoji="üóØÔ∏è">
                                <li>
                                    Werden Datum und Uhrzeit der Messwerte vor Ort oder vom Server ermittelt?
                                </li>
                                <li>
                                    Wie kann die zeitliche Reihenfolge aller Messwerte garantiert werden?
                                </li>
                                <li>
                                    Wie k√∂nnen Latenzen in der Daten√ºbertragung ausgeglichen werden?
                                </li>
                                <li>
                                    Was passiert, wenn die Uhren der Messstationen nicht gleich gehen?
                                </li>
                                <li>
                                    Wie kann verhindert werden, dass die Uhren auseinander driften?
                                </li>
                                <li>
                                    Wie sollen die Zeitzonen oder die Sommer-/Winterzeit ber√ºcksichtigt werden?
                                </li>
                                <li>
                                    Wie k√∂nnen versp√§tet eintreffende Messwerte korrekt gespeichert werden?
                                </li>
                                <li>
                                    Wie sollen fehlende Messdaten (z.B. wegen dem Ausfall einer Station) behandelt werden?
                                </li>
                            </lsx-ul>
                        </lsx-col>
                    </lsx-row>
                </lsx-grid-fluid>
            </lsx-tab-page>
        
            <lsx-tab-page title="L√∂sungsans√§tze">
                <lsx-ul emoji="üåû">
                    <li>
                        Datum und Uhrzeit sowohl auf den Devices als auch dem Server ermitteln und vergleichen.
                    </li>
                    <li>
                        Alle Uhren in regelm√§√üigen Abst√§nden via
                        <a href="https://de.wikipedia.org/wiki/Network_Time_Protocol" target="blank">NTP</a>
                        synchronisieren.
                    </li>
                    <li>
                        S√§mtliche Messwerte zus√§tzlich zum Zeitstempel fortlaufend durchnummerieren.
                    </li>
                    <li>
                        Die Messwerte immer inklusive Zeitzone und Abweichung zur Normalzeit speichern.
                    </li>
                    <li>
                        Alternativ Datum und Uhrzeit immer in die Zeitzone des Servers umrechnen.
                    </li>
                    <li>
                        Nachtr√§gliches Einf√ºgen von Messwerten innerhalb eines gegebenen Zeitfensters zulassen.
                    </li>
                </lsx-ul>
        
                <h3 class="dhbw-lightblue" style="margin-top: 1em;">Beginn der Zeitrechnung</h3>
        
                <lsx-grid-fluid class="p-0">
                    <lsx-row>
                        <lsx-col size="md">
                            <img src="02-grundlagen/zeitproblem-beginn-wissenschaft.jpg" class="d-block img-fluid img-thumbnail" />
                            <b>Wissenschaft:</b> Mit dem Urknall
                        </lsx-col>
                        <lsx-col size="md">
                            <img src="02-grundlagen/zeitproblem-beginn-kirche.jpg" class="d-block img-fluid img-thumbnail" />
                            <b>Kirche:</b> Als Gott die Erde erschuf
                        </lsx-col>
                    </lsx-row>
                    <lsx-row>
                        <lsx-col size="md">
                            <img src="02-grundlagen/zeitproblem-beginn-sport.jpg" class="d-block img-fluid img-thumbnail" />
                            <b>Wettl√§ufer:</b> Ab dem Startschuss
                        </lsx-col>
                        <lsx-col size="md">
                            <img src="02-grundlagen/zeitproblem-beginn-entwickler.jpg" class="d-block img-fluid img-thumbnail" />
                            <b>Softwareentwickler:</b> <a href="https://de.wikipedia.org/wiki/Unixzeit"
                                target="_blank">01.01.1970 0:00 Uhr</a> ü•¥
                            <br />
                            <small>
                                <b>Youtube:</b>
                                <a href="https://www.youtube.com/watch?v=jNQXAC9IVRw" target="_blank">23.04.2005</a>
                            </small>
                        </lsx-col>
                    </lsx-row>
                    <lsx-row>
                        <lsx-col size="md">
                            <p>
                                <small>
                                    <small>
                                        Bildnachweise:
                                        <a href="https://pixabay.com/illustrations/universe-space-expansion-big-bang-11636/"
                                            target="_blank">Pixabay: WikiImages</a>,
                                        <a href="https://pixabay.com/photos/genesis-mosaic-iconography-2435989/"
                                            target="_blank">Pixabay: dimitrisvetsikas1969</a>,
                                        <a href="https://pixabay.com/photos/race-finish-line-athletes-695303/"
                                            target="_blank">Pixabay: skeeze</a>,
                                        <a href="https://commons.wikimedia.org/wiki/File:Vt100-adventure.jpg"
                                            target="_blank">Wikimedia: Shieldforyoureyes</a>
                                    </small>
                                </small>
                            </p>
                        </lsx-col>
                    </lsx-row>
                </lsx-grid-fluid>
            </lsx-tab-page>
        </lsx-tab-pages>
    </article>
    <aside class="markdown">
        Verteilte Systeme erstecken sich, je nach Anwendungsfall, h√§ufig √ºber mehrere L√§nder und Kontinente.
        Manchmal ergibt sich das einfach nur aus der weltweiten Nutzung einer Anwendung, selbst wenn sie nur
        an einem Standort betrieben wird. Oftmals ist die geografische Verteilung aber auch wesenticher
        Bestandteil der Systemarchitektur. üó∫Ô∏è Ein Problem, das in beiden F√§llen gerne mal √ºbersehen wird, ist
        die zeitliche Synchronisierung aller Systemkomponenten. Zwar klingt es zun√§chst trivial, die zeitliche
        Reihenfolge zweier oder mehr Ereignisse festzustellen. Werden die Ereignisse jedoch von unterschiedlichen
        Rechnern erzeugt, gen√ºgt ein einfacher Datums- und Uhrzeitvergleich l√§ngst nicht aus, da hierf√ºr erst
        einmal ein einheitliches Verst√§ndnis √ºber die aktuelle Zeit üïë in allen Knoten hergestellt werden muss.

        Anhand eines einfachen Fallbeispiels lassen sich die auftretenden Probleme anschaulich erkl√§ren. Wir
        gehen deshalb im Folgenden von einem Projekt zur Vorhersage von Unwettern und Naturkatastrophen aus,
        f√ºr das in ganz Europa an 19 verschiedenen Standorten aktuelle Umweltdaten gemessen und an einen Server
        in Frankfurt am Main geschickt werden. Jede Messstation schickt hierf√ºr alle f√ºnf Minuten aktuelle Messwerte
        an den Server, um diese zu speichern, wobei das genaue Intervall an dieser Stelle gar nicht wichtig ist.
        Die Karte auf der Folie ziegt die Standorte, an denen die Messwerte jeweils erhoben werden.

        Klar ist, dass zu jeder Messung folgende Daten gespeichert werden m√ºssen:

        * Standort der Messung
        * Datum und Uhrzeit der Messung
        * Gemessene Werte
        
        Daraus ergeben sich allerdings mehrere Fallstricke, die beim Systementwurf beachtet werden m√ºssen.
        Zun√§chst ist da zum Beispiel die Frage zu kl√§ren, ob Datum und Uhrzeit einer Messung auf Seiten
        der jeweiligen Messstation oder des Servers ermittelt werden und wie dabei die zeitliche Reihenfolge
        der Messwerte sichergestellt werden kann. Denn immerhin kann es ja sein, dass die Uhr einer Station
        etwas vor geht und ihre Messwerte somit f√§lschlich vor denen der anderen Stationen eingeordnet werden.
        Werden die Zeitstempel vom Server ermittelt, m√ºssen Verz√∂gerungen w√§hrend der Daten√ºbertragung, die
        so genannte Latenz, ausgeglichen werden, um die zeitliche Reihenfolge zu gew√§hren. Erfolgt die Ermittlung
        durch die Stationen, m√ºssen ihre Uhren regelm√§√üig synchronisiert werden. Au√üerdem m√ºssen die Auswirkungen
        unterschiedliche Zeitzonen sowie von Sommer- und Winterzeit ber√ºcksichtigt werden und es muss bedacht
        werden, dass Messwerte m√∂glicherweise verloren gehen oder erst mit Versp√§tung beim Server eintreffen. üò≤

        Die Beantwortung dieser Fragen h√§ngt immer vom konkreten Anwendungsfall ab. M√∂gliche L√∂sungsans√§tze,
        die hierbei in Erw√§gung gezogen werden k√∂nnen, sind folgende:
    
        * Datum und Uhrzeit k√∂nnten nicht einfach nur durch die Messstationen sondern zus√§tzlich auf dem Server
            ermittelt werden. Durch einen Vergleich beider Werte ·∏±ann, sofern die Uhren auf beiden Seiten richtig
            gehen und die Daten sofort versendet werden, die Latenz der Daten√ºbertragung abgeleitet werden.
            Diese sollte dabei niemals gr√∂√üer als ein/zwei Sekunden sein. Andernfalls geht eine der Uhren falsch
            oder es findet eine Replay-Attacke statt.
        
        * Die exakte Synchronisation aller Uhren kann mit dem
            <a href="https://de.wikipedia.org/wiki/Network_Time_Protocol" target="blank">Network Time Protocol</a>
            sichergestellt werden. Alle bekannten Betriebssysteme unterst√ºtzen dieses Verfahren, wodurch die
            Abweichungen zwischen den Uhren auf wenige Millisekunden reduziert werden k√∂nnen.
        
        * Zus√§tzlich sollten alle Messwerte mit einer fortlaufenden Nummer versehen werden, um Vertauschungen
            auch ohne korrekt eingestellte Uhren erkennen zu k√∂nnen.
        
        * F√ºr die Weiterverarbeitung der Daten sehr wichtig ist das Format, in dem die Zeitstempel √ºbertragen
            und gespeichert werden.¬π Hier ist zu pr√ºfen, ob das Format den erforderlichen Zeitraum √ºberhaupt mit
            einer ausreichenden Genauigkeit abdeckt. Au√üerdem sollten neben den Werten f√ºr Datum und Uhrzeit immer
            auch der Name der Zeitzone und/oder die Abweichung zur Normalzeit enthalten sein, um die Werte
            unterschiedlicher Standort miteinander vergleichen zu k√∂nnen.
        
        * Manche System konvertieren s√§mtliche Zeitstempel stattdessen in die Zeitzone des Servers, um somit
            Probleme aufgrund unterschiedlicher Zeitzonen zu umgehen. Prominentestes Beispiel hierf√ºr ist Youtube,
            wo sich das Uploaddatum eines Videos immer auf die aktuelle Uhrzeit in Kalifornien bezieht.
        
        * Sollte ein nachtr√§gliches Einf√ºgen von Messwerten aufgrund der verwendeten Technologie nicht m√∂glich
            oder nicht praktikabel sein, kann es ganz hilfreich zu sein, zun√§chst mehrere Datens√§tze auf dem
            Server zu sammeln, und diese zum Beispiel nur einmal je Minute zu sichern. Beispielsweise kann eine
            Blockchain nur aufeinander folgende Werte beinhalten. Durch die Speicherung in Bl√∂cken k√∂nnen aber
            w√§hrend eines kurzen Zeitraums nachtr√§glich noch Werte eingef√ºgt werden, solange diese noch nicht in
            der Blockchain persistiert wurden.
        
        ¬π
        <small>
            Diese Seite enth√§lt hierf√ºr ein paar mehr oder weniger ernst gemeinte Beispiele.
        </small>
    </aside>
</section>